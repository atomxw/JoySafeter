# Workflows

# Race Condition Workflows

## Target identification

- Map state-changing operations: balance transfers, purchases, coupon redemption, votes, likes, follows
- Identify "one per user" constraints: single-use tokens, unique registrations, limited inventory
- Review source code for missing locks: SELECT then UPDATE without FOR UPDATE, check-then-act patterns

## Single-endpoint limit-overrun

- turbo_intruder_race: concurrent_requests 20, gate "single_packet"
- Workflow:
  1. Record initial state (balance, inventory count, coupon status)
  2. Send N identical redemption/purchase requests simultaneously
  3. Compare final state: if more than 1 succeeded, race confirmed
- test_vectors:
  - Coupon redemption: apply same code 20x in parallel
  - Balance transfer: send full balance to recipient 20x
  - Inventory purchase: buy last item 20x simultaneously
  - Vote/like: submit same vote 20x

## Multi-endpoint TOCTOU

- aiohttp_race: concurrent 2 (one check, one use)
- Workflow:
  1. Identify check-then-act pairs (validate coupon → apply coupon)
  2. Send "use" request immediately after "check" returns success
  3. Repeat with increasing parallelism until window is hit
- test_vectors:
  - Check balance → transfer funds (drain beyond balance)
  - Validate coupon → apply coupon (reuse single-use code)
  - Check inventory → place order (oversell)

## Session-level races

- requests_threaded: threads 10, barrier True
- test_vectors:
  - Parallel password change + privileged action (act before session invalidates)
  - Simultaneous role downgrade + admin action
  - Concurrent session refresh + token rotation (obtain two valid tokens)
  - Parallel email change + password reset (reset sent to old email)

## Timing synchronization techniques

- Single-packet attack: pack all HTTP requests into one TCP packet (Turbo Intruder gate="single_packet")
- HTTP/2 multiplexing: send all requests on single connection via httpx_parallel http2=True
- Last-byte sync: send all requests minus final byte, then send all final bytes simultaneously
- Connection warming: pre-establish TCP connections, then fire requests in parallel

## Reporting and validation

- state_checker: verify before/after state for each race target
- Document: number of successful duplicate operations, financial impact, reproduction reliability
- Classify severity: financial double-spend (Critical), limit bypass (High), state confusion (Medium)
- Include timing requirements and success rate percentage in report
