# Workflows

## White-Box Code Review Patterns

## AI-assisted selection

1. Map application architecture and identify all entry points.
2. Inventory existing security controls and sanitization patterns.
3. Run 5 parallel vulnerability analysis tracks (injection, XSS, auth, authz, SSRF).
4. Score findings by taint chain completeness and impact.
5. Generate exploitation queue JSON for downstream exploit validation.

---

## taint_analysis

Backward taint analysis: start at dangerous sinks, trace backward to user-controlled sources.

- semgrep_taint: rules "p/owasp-top-ten"
- codeql_query: query "Security/CWE"
- test_vectors:
  - Identify all SQL query construction points (raw queries, string concatenation, template literals)
  - Identify all command execution sinks (exec, spawn, system, popen)
  - Identify all file system sinks (readFile, writeFile, open, unlink)
  - For each sink, trace backward through function calls to find user-controlled source
  - Classify each taint chain as: COMPLETE (source→sink), PARTIAL (intermediate sanitization), BROKEN (effective sanitization)

## injection_sinks

Classify injection sinks by slot type and verify sanitization adequacy.

- ripgrep_security: pattern "query\\(|exec\\(|system\\(|eval\\(|readFile\\("
- semgrep_taint: rules "p/sql-injection", "p/command-injection"
- test_vectors:
  - SQL-val: Find parameterized value positions using string concat or template literals
  - SQL-ident: Find dynamic table/column names in ORDER BY, GROUP BY, table references
  - CMD-argument: Find shell command construction with user input in arguments
  - FILE-path: Find file path construction using user-supplied path segments
  - TEMPLATE-expr: Find template engine expressions with unescaped user data
  - For each sink, document: slot_type, source_param, sanitization_present, bypass_likelihood

## xss_contexts

Classify XSS output points by render context and verify encoding.

- ripgrep_security: pattern "innerHTML|dangerouslySetInnerHTML|document\\.write|\\$\\{|<%="
- semgrep_taint: rules "p/xss"
- test_vectors:
  - HTML_BODY: Find unencoded user data between HTML tags
  - HTML_ATTRIBUTE: Find user data in attribute values without attribute encoding
  - JAVASCRIPT_STRING: Find user data inside JS string literals without JS escaping
  - URL_PARAM: Find user data in href/src attributes without URL encoding
  - CSS_VALUE: Find user data in style attributes without CSS encoding
  - For each output point, document: context, encoding_applied, encoding_correct, bypass_vectors

## auth_checklist

9-point authentication security checklist from source code review.

- ripgrep_security: pattern "bcrypt|argon2|pbkdf2|jwt\\.sign|session|cookie|rate.?limit"
- test_vectors:
  - Transport: Verify all auth endpoints enforce HTTPS, check HSTS headers
  - Rate limiting: Check for rate limiter middleware on login/register/reset endpoints
  - Session management: Trace session creation, storage backend, and cookie flags
  - Token properties: Verify JWT algorithm, expiry, audience, issuer claims
  - Session fixation: Check if session ID regenerates after authentication
  - Password policy: Find password validation rules, check minimum complexity
  - Login responses: Verify login failure messages don't leak user existence
  - Recovery: Review password reset token generation, expiry, and single-use enforcement
  - SSO/OAuth: Verify state parameter, redirect URI validation, token exchange security

## authz_model

3-type authorization model review from source code.

- ripgrep_security: pattern "authorize|permission|role|isOwner|canAccess"
- test_vectors:
  - Horizontal: Find object access patterns where user ID comes from request (IDOR candidates)
  - Horizontal: Check if ownership verification exists before data access/modification
  - Vertical: Find admin-only functions and verify role check enforcement
  - Vertical: Check for privilege escalation via parameter manipulation (role field in request body)
  - Context-workflow: Find state-dependent actions and verify state transition authorization
  - Context-workflow: Check if completed/cancelled workflows can be re-entered

## ssrf_sinks

Identify and classify SSRF sinks by type.

- ripgrep_security: pattern "fetch\\(|axios\\(|request\\(|http\\.get\\(|urllib"
- semgrep_taint: rules "p/ssrf"
- test_vectors:
  - Classic: Find direct URL construction from user input passed to HTTP client
  - Blind: Find outbound requests where response is not returned to user
  - Semi-blind: Find outbound requests where partial response info leaks (status, timing)
  - Stored: Find URL fields saved to database and fetched later (webhook URLs, avatar URLs)
  - For each sink, document: ssrf_type, url_construction, validation_present, bypass_vectors

## exploitation_queue_schema

JSON schema for the exploitation queue output consumed by pentest-exploit-validation.

- format: JSON array of finding objects
- required_fields:
  - id: Unique finding identifier (e.g., "INJ-001", "XSS-003")
  - vuln_type: "injection" | "xss" | "auth" | "authz" | "ssrf"
  - confidence: 0.0-1.0 (taint chain completeness × bypass likelihood)
  - endpoint: HTTP method + path
  - source_param: User-controlled input parameter name
  - sink_location: file:line of dangerous sink
  - slot_type: Slot type or render context classification
  - sanitization: Description of existing sanitization (or "none")
  - bypass_hypothesis: Proposed bypass approach
  - priority: "critical" | "high" | "medium" | "low"

## Reporting and validation

- Each finding includes complete taint chain: source → transformations → sink with file:line at each step
- Confidence score reflects: taint chain completeness (0.3), sanitization bypass likelihood (0.4), impact severity (0.3)
- Exploitation queue JSON validated against schema before handoff
- Findings grouped by vulnerability type for parallel exploitation
- False positive indicators documented for each finding
