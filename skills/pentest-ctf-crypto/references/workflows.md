# Cryptography Workflows

## 1. RSA CTF Challenge Workflow

### When to use
- Given: public key (n, e) and ciphertext
- Goal: Decrypt the flag

### Steps
1. **Extract key parameters**: Use `openssl_rsa_analyze` or manual parsing to get n and e.
2. **Check FactorDB**: Use `factordb_lookup(n)` to see if n is already factored.
3. **Run RsaCtfTool**: Use `RsaCtfTool_attack(public_key, cipher)` with automatic attack selection.
4. **If fails, try specific attacks**:
   - Small e (e=3): Cube root attack
   - Close primes: Fermat factorization
   - Large e: Wiener/Boneh-Durfee
   - Multiple keys: Common modulus attack
5. **Decrypt**: Once factors (p, q) are found, compute d and decrypt.

---

## 2. Hash Length Extension Workflow

### When to use
- Given: MAC = H(secret || message), length of secret, original message
- Goal: Forge valid MAC for extended message

### Steps
1. **Identify hash type**: Check if MD5, SHA1, or SHA256 (vulnerable types).
2. **Determine secret length**: May need to brute-force (8-32 bytes typical).
3. **Run hashpump**: `hashpump_attack(signature, data, key_length, append_data)`
4. **Submit forged payload**: Use the new signature and padded message.

---

## 3. Classical Cipher Breaking Workflow

### When to use
- Given: Ciphertext that looks like encoded/encrypted text
- Goal: Recover plaintext

### Steps
1. **Auto-detect with Ciphey**: `ciphey_auto_decrypt(ciphertext)` handles most common cases.
2. **If XOR suspected**: Use `xortool_analyze` to guess key length and recover key.
3. **If substitution cipher**: Frequency analysis + manual tweaking.
4. **If Vigenere**: Kasiski examination or known plaintext attack.

---

## 4. JWT Attack Workflow

### When to use
- Given: JWT token from web application
- Goal: Bypass authentication or escalate privileges

### Steps
1. **Analyze structure**: `jwt_analyzer(token)` to see header, payload, algorithm.
2. **Check for "none" algorithm**: Try `jwt_tool_attack(token, "none_alg")`.
3. **Check for algorithm confusion**: RS256 â†’ HS256 with public key as secret.
4. **Brute-force weak secrets**: `jwt_tool_attack(token, "brute", wordlist)`.

---

## 5. Padding Oracle Workflow

### When to use
- Given: Encrypted cookie/parameter, server responds differently to padding errors
- Goal: Decrypt ciphertext or forge new values

### Steps
1. **Confirm oracle**: Send modified ciphertext, check for distinct error responses.
2. **Run automated attack**: `padding_oracle_attack(url, param, block_size)`.
3. **Decrypt block by block**: Tool will recover plaintext and allow forging.
