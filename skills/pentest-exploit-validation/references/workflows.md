# Workflows

## Exploit Validation Patterns

## AI-assisted selection

1. Parse exploitation queue JSON and validate schema.
2. Prioritize findings by confidence score and impact severity.
3. Execute type-specific exploitation workflows in parallel.
4. Apply bypass exhaustion protocol for blocked attempts.
5. Escalate from PoC to real impact demonstration.
6. Collect mandatory evidence per type and classify findings.

---

## injection_exploit

Structured injection exploitation: confirm → fingerprint → enumerate → exfiltrate.

- sqlmap_exploit: level 3, risk 2, technique "BEUSTQ"
- curl_exploit: manual payload crafting
- test_vectors:
  - Confirm: Send tautology payload (e.g., `' OR 1=1--`) and observe response diff
  - Confirm: Send false condition (`' AND 1=2--`) and compare with tautology response
  - Fingerprint: Identify DBMS via error messages or behavioral differences
  - Enumerate: Extract database names, table names, column names
  - Exfiltrate: Demonstrate data extraction (limit to 3-5 rows as proof)
  - For SQL-ident slots: Test ORDER BY injection with known column names
  - For CMD-argument slots: Test command injection with sleep/ping for blind confirmation

## xss_exploit

Graph traversal exploitation: source → processing → sanitization → sink.

- playwright_xss: capture_console True, capture_cookies True
- curl_exploit: manual payload injection
- test_vectors:
  - HTML_BODY: Inject `<img src=x onerror=alert(1)>` and verify execution
  - HTML_ATTRIBUTE: Break out of attribute with `" onfocus=alert(1) autofocus="`
  - JAVASCRIPT_STRING: Break string with `';alert(1)//` or template literal `${alert(1)}`
  - URL_PARAM: Inject `javascript:alert(1)` in href/src attributes
  - CSS_VALUE: Inject `expression(alert(1))` or `url(javascript:alert(1))`
  - Demonstrate session hijack: capture document.cookie via injected payload

## auth_exploit

Attack authentication weaknesses and demonstrate account takeover.

- burp_repeater_exploit: modify auth tokens, session cookies
- curl_exploit: credential stuffing, token manipulation
- test_vectors:
  - Brute force: Test rate limiting on login endpoint with common credentials
  - Token forgery: Modify JWT claims (alg:none, key confusion, expired token reuse)
  - Session fixation: Set session cookie before authentication, verify it persists
  - Password reset: Test reset token predictability, expiry, and reuse
  - Account enumeration: Diff login responses for valid vs invalid usernames

## authz_exploit

Horizontal → vertical → workflow bypass exploitation.

- burp_repeater_exploit: swap user IDs, role tokens
- curl_exploit: direct object reference manipulation
- test_vectors:
  - Horizontal: Access user B's data with user A's session (swap ID in URL/body)
  - Horizontal: Modify object ownership fields in PUT/PATCH requests
  - Vertical: Access admin endpoints with regular user token
  - Vertical: Add role/isAdmin fields to profile update requests
  - Workflow: Access step N endpoint without completing steps 1..N-1
  - Workflow: Re-enter completed/cancelled workflow states

## ssrf_exploit

Exploit SSRF sinks by type: internal access → cloud metadata → network recon.

- curl_exploit: URL manipulation payloads
- test_vectors:
  - Classic: Replace URL parameter with internal addresses (127.0.0.1, localhost, 0.0.0.0)
  - Classic: Access cloud metadata endpoint (169.254.169.254/latest/meta-data/)
  - Blind: Use out-of-band callback (Burp Collaborator, interactsh) to confirm request
  - Semi-blind: Measure response timing differences for internal vs external URLs
  - Stored: Submit webhook URL pointing to internal service, trigger webhook
  - Bypass: Try URL encoding, IPv6 (::1), decimal IP, DNS rebinding

## bypass_exhaustion

Structured bypass protocol: 3 initial → 8-10 variations → automated tools.

- turbo_intruder: payload_generator "bypass_variations.py"
- test_vectors:
  - Phase 1 (3 payloads): Standard payload, case variation, encoding variation
  - Phase 2 (8-10 bypasses): Double encoding, null bytes, unicode normalization
  - Phase 2: Alternate syntax, comment injection, whitespace variations
  - Phase 2: Nested payloads, polyglot payloads, protocol-level tricks
  - Phase 3: Deploy sqlmap tamper scripts or nuclei templates
  - Document each attempt: payload, response code, response body diff

## evidence_collection

Mandatory evidence checklists per vulnerability type.

- validation:
  - Injection: Full HTTP request with payload, response showing data extraction, DBMS fingerprint
  - XSS: Payload, browser screenshot of execution, captured cookies or DOM state
  - Auth: Request/response pair showing bypass, account takeover proof
  - Authz: Two requests showing same resource accessed by unauthorized user
  - SSRF: Request with internal URL, response proving internal access or OOB callback

## classification_tree

Decision tree for final finding classification.

- decision_flow:
  - Was the vulnerability exploited with reproducible evidence? → YES → EXPLOITED (L3)
  - Was critical impact demonstrated (data exfil, RCE, account takeover)? → YES → EXPLOITED CRITICAL (L4)
  - Was a partial bypass achieved but full exploitation blocked? → YES → POTENTIAL (L2)
  - Was a code-level weakness identified but not exploitable? → YES → POTENTIAL (L1)
  - Did manual review confirm effective sanitization? → YES → FALSE_POSITIVE
  - Is the code path unreachable in production? → YES → FALSE_POSITIVE

## exploitation_queue_schema

JSON schema for the exploitation queue input consumed from pentest-whitebox-code-review.

- format: JSON array of finding objects
- required_fields:
  - id: Unique finding identifier (e.g., "INJ-001", "XSS-003")
  - vuln_type: "injection" | "xss" | "auth" | "authz" | "ssrf"
  - confidence: 0.0-1.0 (taint chain completeness × bypass likelihood)
  - endpoint: HTTP method + path
  - source_param: User-controlled input parameter name
  - sink_location: file:line of dangerous sink
  - slot_type: Slot type or render context classification
  - sanitization: Description of existing sanitization (or "none")
  - bypass_hypothesis: Proposed bypass approach
  - priority: "critical" | "high" | "medium" | "low"

## Reporting and validation

- Each EXPLOITED finding includes: full HTTP request/response, payload used, impact demonstrated
- Each POTENTIAL finding includes: code-level evidence, bypass attempts log, blocking control identified
- Each FALSE_POSITIVE includes: reason for dismissal, sanitization analysis
- Findings sorted by classification then severity: EXPLOITED CRITICAL → EXPLOITED → POTENTIAL → FALSE_POSITIVE
- Bypass exhaustion log attached for all non-FALSE_POSITIVE findings
