# Workflows

# Supply Chain Security Workflows

## Dependency audit

- snyk_test: path target, severity_threshold "high"
- npm_audit_scan: package_json_path target, production_only False
- pip_audit_scan: requirements_file target, strict True
- Check for:
  - Known CVEs in direct and transitive dependencies
  - Unmaintained packages (no updates >2 years)
  - Packages with abnormally low download counts
  - Version pinning — exact versions vs ranges
  - Dependency tree depth — deeply nested transitive risks

## Dependency confusion testing

- test_vectors:
  - Internal package enumeration: extract names from package.json, requirements.txt, go.mod
  - Public registry check: query npm registry, PyPI, Go proxy for matching names
  - Namespace squatting: check if org-scoped packages (@company/pkg) have unscoped equivalents
  - Version priority: test if higher-version public package overrides private registry
  - Scope confusion: test mixed scoped/unscoped resolution behavior
- validation:
  - Confirm .npmrc / pip.conf registry configuration restricts to private registries
  - Verify registry priority order in lockfiles
  - Check for missing registry-fence configurations

## CI/CD pipeline security

- actionlint_check: workflow_file target
- semgrep_supply_chain: path target, config "p/ci-cd"
- test_vectors:
  - Expression injection: search for ${{ github.event.pull_request.title }} in run: blocks
  - Unpinned actions: actions using @main or @master instead of SHA pinning
  - Secret exposure: secrets passed as environment variables to untrusted steps
  - Self-hosted runner abuse: workflows running on self-hosted without restrictions
  - Artifact poisoning: workflows consuming artifacts from untrusted sources
- validation:
  - Verify all third-party actions pinned to full commit SHA
  - Confirm GITHUB_TOKEN has minimal required permissions
  - Check for pull_request_target with checkout of PR head

## Lockfile integrity verification

- lockfile_lint: lockfile_path target, type "npm"
- test_vectors:
  - URL manipulation: check resolved URLs point to expected registries only
  - Integrity hash mismatch: compare lockfile integrity fields against actual package tarballs
  - Phantom dependencies: packages in lockfile not referenced in manifest
  - Version drift: lockfile versions diverging from manifest semver ranges
- validation:
  - Run `npm ci` vs `npm install` — ci enforces lockfile exactly
  - Diff lockfile before/after clean install to detect injected entries
  - Verify no `http://` URLs in lockfile (should all be `https://`)

## Install script and typosquatting analysis

- semgrep_supply_chain: path target, config "p/supply-chain"
- test_vectors:
  - Install hooks: check for preinstall/postinstall/prepare scripts executing binaries
  - Network calls in install: scripts making HTTP requests during npm install / pip install
  - Obfuscated code: base64-encoded or eval'd payloads in install scripts
  - Typosquatting candidates: generate permutations of popular package names (lodash → lodahs, lodassh)
  - Dependency hijacking: check maintainer email domains for expired registrations

## SBOM generation and artifact integrity

- syft_generate: target image/filesystem, output_format "cyclonedx-json"
- trivy_scan: target image, scan_type "image", severity "HIGH,CRITICAL"
- grype_scan: target image, output_format "json"
- test_vectors:
  - SBOM completeness: verify all transitive dependencies captured
  - Image tag mutability: check if :latest or version tags can be overwritten
  - Signature verification: validate cosign/Notary signatures on container images
  - Base image provenance: trace base images to official sources
  - Build reproducibility: rebuild from source and compare digests

## Reporting and validation

- Document: ecosystem (npm/pip/go), manifest files analyzed, registry configurations
- Map findings to MITRE ATT&CK T1195 sub-techniques
- Classify severity:
  - Critical: dependency confusion exploitable, CI/CD injection with secret access
  - High: known CVEs in production dependencies, unsigned build artifacts
  - Medium: unpinned actions, lockfile inconsistencies, install script risks
  - Low: unmaintained dependencies, missing SBOM, informational findings
