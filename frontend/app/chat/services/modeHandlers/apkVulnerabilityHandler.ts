/**
 * APK Vulnerability Handler
 *
 * Handles APK vulnerability detection mode
 * This is a simple handler that allows APK file uploads for direct chat
 */

import { agentService } from '@/app/workspace/[workspaceId]/[agentId]/services/agentService'
import { graphTemplateService } from '@/app/workspace/[workspaceId]/[agentId]/services/graphTemplateService'
import { graphKeys } from '@/hooks/queries/graphs'
import { toastError, toastSuccess } from '@/lib/utils/toast'

import { AndroidIcon } from '../../components/icons/AndroidIcon'
import { getModeConfig } from '../../config/modeConfig'

import type {
  ModeHandler,
  ModeContext,
  ModeSelectionResult,
  SubmitResult,
  ValidationResult,
  ModeMetadata,
  UploadedFile,
} from './types'



// Lock to prevent concurrent graph creation
let creatingGraphPromise: Promise<ModeSelectionResult> | null = null

/**
 * APK Vulnerability Mode Handler
 */
export const apkVulnerabilityHandler: ModeHandler = {
  metadata: {
    id: 'apk-vulnerability',
    label: 'chat.apkVulnerability',
    description: 'chat.apkVulnerabilityDescription',
    icon: AndroidIcon,
    type: 'template',
  },

  requiresFiles: false, // Allow APK uploads but don't require them

  async onSelect(context: ModeContext): Promise<ModeSelectionResult> {
    // Verify personalWorkspaceId exists first
    if (!context.personalWorkspaceId) {
      return {
        success: false,
        error: 'Personal workspace not found. Please ensure you have a personal workspace.',
      }
    }

    // Check if graph already exists in workspace (not just deployed graphs)
    // First try to get from query cache
    let workspaceGraphs: Array<{ id: string; name: string }> | undefined
    if (context.queryClient.getQueryData) {
      workspaceGraphs = context.queryClient.getQueryData<Array<{ id: string; name: string }>>(
        [...graphKeys.list(context.personalWorkspaceId)]
      )
    }

    // If not in cache, fetch from API
    if (!workspaceGraphs) {
      try {
        workspaceGraphs = await agentService.listGraphs(context.personalWorkspaceId)
      } catch (error) {
        console.error('Failed to fetch workspace graphs:', error)
        workspaceGraphs = []
      }
    }
    console.log('workspaceGraphs', workspaceGraphs)
    // Find APK Detector graph in workspace
    const apkDetectorGraph = workspaceGraphs?.find(
      (agent) => agent.name === 'APK Detector'
    )

    if (apkDetectorGraph) {
      // Graph already exists, return its ID
      return {
        success: true,
        stateUpdates: {
          mode: 'apk-vulnerability',
          graphId: apkDetectorGraph.id,
        },
      }
    }

    // If a creation is already in progress, wait for it to complete
    if (creatingGraphPromise) {
      return creatingGraphPromise
    }

    // Graph doesn't exist, need to create it from template
    const modeConfig = getModeConfig('apk-vulnerability')
    if (!modeConfig || !modeConfig.templateName || !modeConfig.templateGraphName) {
      return {
        success: false,
        error: 'APK Detector template configuration not found',
      }
    }

    // Create the graph creation promise and store it to prevent concurrent creation
    creatingGraphPromise = (async (): Promise<ModeSelectionResult> => {
      try {
        // Double-check after acquiring lock (in case another call already created it)
        // Refresh the workspace graphs query first to get the latest data
        if (context.queryClient.refetchQueries) {
          await context.queryClient.refetchQueries({
            queryKey: [...graphKeys.list(context.personalWorkspaceId!)],
          })
          
          // Get fresh workspace graphs from query cache if getQueryData is available
          if (context.queryClient.getQueryData) {
            const queryData = context.queryClient.getQueryData<Array<{ id: string; name: string }>>(
              [...graphKeys.list(context.personalWorkspaceId!)]
            )
            const freshApkDetectorGraph = queryData?.find(
              (agent: { id: string; name: string }) => agent.name === 'APK Detector'
            )

            if (freshApkDetectorGraph) {
              // Graph was created by another call, return its ID
              return {
                success: true,
                stateUpdates: {
                  mode: 'apk-vulnerability',
                  graphId: freshApkDetectorGraph.id,
                },
              }
            }
          }
        }

        // Create graph from template
        // modeConfig.templateName and modeConfig.templateGraphName are guaranteed to exist due to check above
        const createdGraph = await graphTemplateService.createGraphFromTemplate(
          modeConfig.templateName!,
          modeConfig.templateGraphName!,
          context.personalWorkspaceId!
        )

        // Refresh workspace graphs list
        // Use refetchQueries if available, otherwise use invalidateQueries
        if (context.queryClient.refetchQueries) {
          await context.queryClient.refetchQueries({
            queryKey: [...graphKeys.list(context.personalWorkspaceId!)],
          })
        } else {
          context.queryClient.invalidateQueries({
            queryKey: [...graphKeys.list(context.personalWorkspaceId!)],
          })
        }

        toastSuccess(
          `APK Detector graph created successfully`,
          'Graph Initialized'
        )

        // Return the created graph ID
        return {
          success: true,
          stateUpdates: {
            mode: 'apk-vulnerability',
            graphId: createdGraph.id,
          },
        }
      } catch (error) {
        const errorMessage =
          error instanceof Error
            ? error.message
            : 'Failed to create APK Detector graph'
        toastError(errorMessage, 'Graph Creation Failed')
        return {
          success: false,
          error: errorMessage,
        }
      } finally {
        // Clear the lock after completion
        creatingGraphPromise = null
      }
    })()

    return creatingGraphPromise
  },

  async onSubmit(
    input: string,
    files: UploadedFile[],
    context: ModeContext
  ): Promise<SubmitResult> {
    return {
      success: true,
      processedInput: input,
    }
  },

  validate(input: string, files: UploadedFile[]): ValidationResult {
    return { valid: true }
  },

  async getGraphId(context: ModeContext): Promise<string | null> {
    // Verify personalWorkspaceId exists
    if (!context.personalWorkspaceId) {
      return null
    }

    // Find graph in workspace by templateGraphName 'APK Detector'
    // First try to get from query cache
    let workspaceGraphs: Array<{ id: string; name: string }> | undefined
    if (context.queryClient.getQueryData) {
      workspaceGraphs = context.queryClient.getQueryData<Array<{ id: string; name: string }>>(
        [...graphKeys.list(context.personalWorkspaceId)]
      )
    }

    // If not in cache, fetch from API
    if (!workspaceGraphs) {
      try {
        workspaceGraphs = await agentService.listGraphs(context.personalWorkspaceId)
      } catch (error) {
        console.error('Failed to fetch workspace graphs:', error)
        return null
      }
    }

    const apkDetectorGraph = workspaceGraphs?.find(
      (agent) => agent.name === 'APK Detector'
    )
    
    if (apkDetectorGraph) {
      return apkDetectorGraph.id
    }

    // If not found, return null (backend will handle template creation if needed)
    return null
  },
}