{
  "skills": [
    {
      "id": "container_scanning-clair_vulnerability_scan",
      "name": "Clair Vulnerability Scan",
      "description": "Execute Clair for container vulnerability analysis. image: Container image to scan config: Clair configuration file output_format: Output format (json, yaml) additional_args: Additional Clair arguments",
      "license": "MIT",
      "content": "---\nname: clair_vulnerability_scan\ncapabilities: ['image', 'config', 'output-format', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'clair']\n---\n\n# Clair Vulnerability Scan\n\nExecute Clair for container vulnerability analysis. image: Container image to scan config: Clair configuration file output_format: Output format (json, yaml) additional_args: Additional Clair arguments\n\n## Parameters\n- **image** (string, Required): Container image to scan\n- **config** (string, Optional) (default: /etc/clair/config.yaml): Clair configuration file\n- **output_format** (string, Optional) (default: json): Output format (json, yaml)\n- **additional_args** (string, Optional): Additional Clair arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/clair`\n\n**Returns:** Container vulnerability analysis results\n\n## Files Included\n\n- `clair_vulnerability_scan.yaml` - Tool configuration\n- `clair_vulnerability_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: clair_vulnerability_scan\ncapabilities: ['image', 'config', 'output-format', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'clair']\n---\n\n# Clair Vulnerability Scan\n\nExecute Clair for container vulnerability analysis. image: Container image to scan config: Clair configuration file output_format: Output format (json, yaml) additional_args: Additional Clair arguments\n\n## Parameters\n- **image** (string, Required): Container image to scan\n- **config** (string, Optional) (default: /etc/clair/config.yaml): Clair configuration file\n- **output_format** (string, Optional) (default: json): Output format (json, yaml)\n- **additional_args** (string, Optional): Additional Clair arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/clair`\n\n**Returns:** Container vulnerability analysis results\n\n## Files Included\n\n- `clair_vulnerability_scan.yaml` - Tool configuration\n- `clair_vulnerability_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "clair_vulnerability_scan.yaml",
          "content": "name: clair_vulnerability_scan\ncategory: container_scanning\ntags: [vulnerability_assessment, penetration_testing, clair]\nendpoint: api/tools/clair\ndescription: 'Execute Clair for container vulnerability analysis. image: Container\n  image to scan config: Clair configuration file output_format: Output format (json,\n  yaml) additional_args: Additional Clair arguments'\nreturns: Container vulnerability analysis results\nparameters:\n- name: image\n  type: string\n  required: true\n  description: Container image to scan\n- name: config\n  type: string\n  required: false\n  description: Clair configuration file\n  default: /etc/clair/config.yaml\n- name: output_format\n  type: string\n  required: false\n  description: Output format (json, yaml)\n  default: json\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Clair arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "clair_vulnerability_scan.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass ClairHandler(AbstractHandler):\n    \"\"\"Handler for clair functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute clair with enhanced logging\"\"\"\n        try:\n            image = data.get(\"image\", \"\")\n            config = data.get(\"config\", \"/etc/clair/config.yaml\")\n            output_format = data.get(\"output_format\", \"json\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not image:\n                logger.warning(\"ðŸ³ Clair called without image parameter\")\n                return {\"error\": \"Image parameter is required\"}\n            command = f\"clairctl analyze {image}\"\n            if config:\n                command += f\" --config {config}\"\n            if output_format:\n                command += f\" --format {output_format}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ³ Starting Clair vulnerability scan: {image}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Clair scan completed for {image}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in clair endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182504
    },
    {
      "id": "web_application_scanning-nuclei_scan",
      "name": "Nuclei Scan",
      "description": "Execute Nuclei vulnerability scanner with enhanced logging and real-time progress. target: The target URL or IP severity: Filter by severity (critical,high,medium,low,info) tags: Filter by tags (e.g. cve,rce,lfi) template: Custom template path additional_args: Additional Nuclei arguments",
      "license": "MIT",
      "content": "---\nname: nuclei_scan\ncapabilities: ['target', 'severity', 'tags', 'template', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nuclei']\n---\n\n# Nuclei Scan\n\nExecute Nuclei vulnerability scanner with enhanced logging and real-time progress. target: The target URL or IP severity: Filter by severity (critical,high,medium,low,info) tags: Filter by tags (e.g. cve,rce,lfi) template: Custom template path additional_args: Additional Nuclei arguments\n\n## Parameters\n- **target** (string, Required): The target URL or IP\n- **severity** (string, Optional): Filter by severity (critical,high,medium,low,info)\n- **tags** (string, Optional): Filter by tags (e.g. cve,rce,lfi)\n- **template** (string, Optional): Custom template path\n- **additional_args** (string, Optional): Additional Nuclei arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/nuclei`\n\n**Returns:** Scan results with discovered vulnerabilities and telemetry\n\n## Files Included\n\n- `nuclei_scan.yaml` - Tool configuration\n- `nuclei_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: nuclei_scan\ncapabilities: ['target', 'severity', 'tags', 'template', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nuclei']\n---\n\n# Nuclei Scan\n\nExecute Nuclei vulnerability scanner with enhanced logging and real-time progress. target: The target URL or IP severity: Filter by severity (critical,high,medium,low,info) tags: Filter by tags (e.g. cve,rce,lfi) template: Custom template path additional_args: Additional Nuclei arguments\n\n## Parameters\n- **target** (string, Required): The target URL or IP\n- **severity** (string, Optional): Filter by severity (critical,high,medium,low,info)\n- **tags** (string, Optional): Filter by tags (e.g. cve,rce,lfi)\n- **template** (string, Optional): Custom template path\n- **additional_args** (string, Optional): Additional Nuclei arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/nuclei`\n\n**Returns:** Scan results with discovered vulnerabilities and telemetry\n\n## Files Included\n\n- `nuclei_scan.yaml` - Tool configuration\n- `nuclei_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "nuclei_scan.yaml",
          "content": "name: nuclei_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, nuclei]\nendpoint: api/tools/nuclei\ndescription: 'Execute Nuclei vulnerability scanner with enhanced logging and real-time\n  progress. target: The target URL or IP severity: Filter by severity (critical,high,medium,low,info)\n  tags: Filter by tags (e.g. cve,rce,lfi) template: Custom template path additional_args:\n  Additional Nuclei arguments'\nreturns: Scan results with discovered vulnerabilities and telemetry\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target URL or IP\n- name: severity\n  type: string\n  required: false\n  description: Filter by severity (critical,high,medium,low,info)\n  default: ''\n- name: tags\n  type: string\n  required: false\n  description: Filter by tags (e.g. cve,rce,lfi)\n  default: ''\n- name: template\n  type: string\n  required: false\n  description: Custom template path\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Nuclei arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "nuclei_scan.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass NucleiHandler(AbstractHandler):\n    \"\"\"Handler for nuclei functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute nuclei with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            severity = data.get(\"severity\", \"\")\n            tags = data.get(\"tags\", \"\")\n            template = data.get(\"template\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ Nuclei called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"nuclei -u {target}\"\n            if severity:\n                command += f\" -severity {severity}\"\n            if tags:\n                command += f\" -tags {tags}\"\n            if template:\n                command += f\" -t {template}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”¬ Starting Nuclei vulnerability scan: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Nuclei scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in nuclei endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182505
    },
    {
      "id": "web_application_scanning-jaeles_vulnerability_scan",
      "name": "Jaeles Vulnerability Scan",
      "description": "Execute Jaeles for advanced vulnerability scanning with custom signatures. url: The target URL signatures: Custom signature path config: Configuration file threads: Number of threads timeout: Request timeout additional_args: Additional Jaeles arguments",
      "license": "MIT",
      "content": "---\nname: jaeles_vulnerability_scan\ncapabilities: ['url', 'signatures', 'config', 'threads', 'timeout', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'jaeles']\n---\n\n# Jaeles Vulnerability Scan\n\nExecute Jaeles for advanced vulnerability scanning with custom signatures. url: The target URL signatures: Custom signature path config: Configuration file threads: Number of threads timeout: Request timeout additional_args: Additional Jaeles arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **signatures** (string, Optional): Custom signature path\n- **config** (string, Optional): Configuration file\n- **threads** (integer, Optional) (default: 20): Number of threads\n- **timeout** (integer, Optional) (default: 20): Request timeout\n- **additional_args** (string, Optional): Additional Jaeles arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/jaeles`\n\n**Returns:** Advanced vulnerability scanning results with custom signatures\n\n## Files Included\n\n- `jaeles_vulnerability_scan.yaml` - Tool configuration\n- `jaeles_vulnerability_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: jaeles_vulnerability_scan\ncapabilities: ['url', 'signatures', 'config', 'threads', 'timeout', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'jaeles']\n---\n\n# Jaeles Vulnerability Scan\n\nExecute Jaeles for advanced vulnerability scanning with custom signatures. url: The target URL signatures: Custom signature path config: Configuration file threads: Number of threads timeout: Request timeout additional_args: Additional Jaeles arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **signatures** (string, Optional): Custom signature path\n- **config** (string, Optional): Configuration file\n- **threads** (integer, Optional) (default: 20): Number of threads\n- **timeout** (integer, Optional) (default: 20): Request timeout\n- **additional_args** (string, Optional): Additional Jaeles arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/jaeles`\n\n**Returns:** Advanced vulnerability scanning results with custom signatures\n\n## Files Included\n\n- `jaeles_vulnerability_scan.yaml` - Tool configuration\n- `jaeles_vulnerability_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "jaeles_vulnerability_scan.yaml",
          "content": "name: jaeles_vulnerability_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, jaeles]\nendpoint: api/tools/jaeles\ndescription: 'Execute Jaeles for advanced vulnerability scanning with custom signatures.\n  url: The target URL signatures: Custom signature path config: Configuration file\n  threads: Number of threads timeout: Request timeout additional_args: Additional\n  Jaeles arguments'\nreturns: Advanced vulnerability scanning results with custom signatures\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL\n- name: signatures\n  type: string\n  required: false\n  description: Custom signature path\n  default: ''\n- name: config\n  type: string\n  required: false\n  description: Configuration file\n  default: ''\n- name: threads\n  type: integer\n  required: false\n  description: Number of threads\n  default: 20\n- name: timeout\n  type: integer\n  required: false\n  description: Request timeout\n  default: 20\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Jaeles arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "jaeles_vulnerability_scan.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass JaelesHandler(AbstractHandler):\n    \"\"\"Handler for jaeles functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute jaeles with enhanced logging\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            signatures = data.get(\"signatures\", \"\")\n            config = data.get(\"config\", \"\")\n            threads = data.get(\"threads\", 20)\n            timeout = data.get(\"timeout\", 20)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not url:\n                logger.warning(\"ðŸŒ Jaeles called without URL parameter\")\n                return {\"error\": \"URL parameter is required\"}\n            command = f\"jaeles scan -u {url} -c {threads} --timeout {timeout}\"\n            if signatures:\n                command += f\" -s {signatures}\"\n            if config:\n                command += f\" --config {config}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”¬ Starting Jaeles vulnerability scan: {url}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Jaeles vulnerability scan completed for {url}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in jaeles endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182507
    },
    {
      "id": "network_scanning-rpcclient_enumeration",
      "name": "Rpcclient Enumeration",
      "description": "Execute rpcclient for RPC enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication commands: Semicolon-separated RPC commands additional_args: Additional rpcclient arguments",
      "license": "MIT",
      "content": "---\nname: rpcclient_enumeration\ncapabilities: ['target', 'username', 'password', 'domain', 'commands', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'rpcclient']\n---\n\n# Rpcclient Enumeration\n\nExecute rpcclient for RPC enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication commands: Semicolon-separated RPC commands additional_args: Additional rpcclient arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **commands** (string, Optional) (default: enumdomusers;enumdomgroups;querydominfo): Semicolon-separated RPC commands\n- **additional_args** (string, Optional): Additional rpcclient arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/rpcclient`\n\n**Returns:** RPC enumeration results\n\n## Files Included\n\n- `rpcclient_enumeration.yaml` - Tool configuration\n- `rpcclient_enumeration.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: rpcclient_enumeration\ncapabilities: ['target', 'username', 'password', 'domain', 'commands', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'rpcclient']\n---\n\n# Rpcclient Enumeration\n\nExecute rpcclient for RPC enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication commands: Semicolon-separated RPC commands additional_args: Additional rpcclient arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **commands** (string, Optional) (default: enumdomusers;enumdomgroups;querydominfo): Semicolon-separated RPC commands\n- **additional_args** (string, Optional): Additional rpcclient arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/rpcclient`\n\n**Returns:** RPC enumeration results\n\n## Files Included\n\n- `rpcclient_enumeration.yaml` - Tool configuration\n- `rpcclient_enumeration.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "rpcclient_enumeration.yaml",
          "content": "name: rpcclient_enumeration\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, rpcclient]\nendpoint: api/tools/rpcclient\ndescription: 'Execute rpcclient for RPC enumeration with enhanced logging. target:\n  The target IP address username: Username for authentication password: Password for\n  authentication domain: Domain for authentication commands: Semicolon-separated RPC\n  commands additional_args: Additional rpcclient arguments'\nreturns: RPC enumeration results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address\n- name: username\n  type: string\n  required: false\n  description: Username for authentication\n  default: ''\n- name: password\n  type: string\n  required: false\n  description: Password for authentication\n  default: ''\n- name: domain\n  type: string\n  required: false\n  description: Domain for authentication\n  default: ''\n- name: commands\n  type: string\n  required: false\n  description: Semicolon-separated RPC commands\n  default: enumdomusers;enumdomgroups;querydominfo\n- name: additional_args\n  type: string\n  required: false\n  description: Additional rpcclient arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "rpcclient_enumeration.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass RpcclientHandler(AbstractHandler):\n    \"\"\"Handler for rpcclient functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute rpcclient with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            username = data.get(\"username\", \"\")\n            password = data.get(\"password\", \"\")\n            domain = data.get(\"domain\", \"\")\n            commands = data.get(\"commands\", \"enumdomusers;enumdomgroups;querydominfo\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ rpcclient called without target parameter\")\n                return {\"error\": \"Target parameter is required\"}\n            if username and password:\n                auth_string = f\"-U {username}%{password}\"\n            elif username:\n                auth_string = f\"-U {username}\"\n            else:\n                auth_string = \"-U ''\"  # Anonymous\n            if domain:\n                auth_string += f\" -W {domain}\"\n            command_sequence = commands.replace(\";\", \"\\n\")\n            command = f\"echo -e '{command_sequence}' | rpcclient {auth_string} {target}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting rpcclient: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š rpcclient completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in rpcclient endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182508
    },
    {
      "id": "web_application_scanning-zap_scan",
      "name": "Zap Scan",
      "description": "Execute OWASP ZAP with enhanced logging. target: Target URL scan_type: Type of scan (baseline, full, api) api_key: ZAP API key daemon: Run in daemon mode port: Port for ZAP daemon host: Host for ZAP daemon format_type: Output format (xml, json, html) output_file: Output file path additional_args: Additional ZAP arguments",
      "license": "MIT",
      "content": "---\nname: zap_scan\ncapabilities: ['target', 'scan-type', 'api-key', 'daemon', 'port', 'host', 'format-type', 'output-file', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'owasp', 'zap']\n---\n\n# Zap Scan\n\nExecute OWASP ZAP with enhanced logging. target: Target URL scan_type: Type of scan (baseline, full, api) api_key: ZAP API key daemon: Run in daemon mode port: Port for ZAP daemon host: Host for ZAP daemon format_type: Output format (xml, json, html) output_file: Output file path additional_args: Additional ZAP arguments\n\n## Parameters\n- **target** (string, Optional): Target URL\n- **scan_type** (string, Optional) (default: baseline): Type of scan (baseline, full, api)\n- **api_key** (string, Optional): ZAP API key\n- **daemon** (boolean, Optional): Run in daemon mode\n- **port** (string, Optional) (default: 8090): Port for ZAP daemon\n- **host** (string, Optional) (default: 0.0.0.0): Host for ZAP daemon\n- **format_type** (string, Optional) (default: xml): Output format (xml, json, html)\n- **output_file** (string, Optional): Output file path\n- **additional_args** (string, Optional): Additional ZAP arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/zap`\n\n**Returns:** ZAP scan results\n\n## Files Included\n\n- `zap_scan.yaml` - Tool configuration\n- `zap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: zap_scan\ncapabilities: ['target', 'scan-type', 'api-key', 'daemon', 'port', 'host', 'format-type', 'output-file', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'owasp', 'zap']\n---\n\n# Zap Scan\n\nExecute OWASP ZAP with enhanced logging. target: Target URL scan_type: Type of scan (baseline, full, api) api_key: ZAP API key daemon: Run in daemon mode port: Port for ZAP daemon host: Host for ZAP daemon format_type: Output format (xml, json, html) output_file: Output file path additional_args: Additional ZAP arguments\n\n## Parameters\n- **target** (string, Optional): Target URL\n- **scan_type** (string, Optional) (default: baseline): Type of scan (baseline, full, api)\n- **api_key** (string, Optional): ZAP API key\n- **daemon** (boolean, Optional): Run in daemon mode\n- **port** (string, Optional) (default: 8090): Port for ZAP daemon\n- **host** (string, Optional) (default: 0.0.0.0): Host for ZAP daemon\n- **format_type** (string, Optional) (default: xml): Output format (xml, json, html)\n- **output_file** (string, Optional): Output file path\n- **additional_args** (string, Optional): Additional ZAP arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/zap`\n\n**Returns:** ZAP scan results\n\n## Files Included\n\n- `zap_scan.yaml` - Tool configuration\n- `zap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "zap_scan.yaml",
          "content": "name: zap_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, owasp, zap]\nendpoint: api/tools/zap\ndescription: 'Execute OWASP ZAP with enhanced logging. target: Target URL scan_type:\n  Type of scan (baseline, full, api) api_key: ZAP API key daemon: Run in daemon mode\n  port: Port for ZAP daemon host: Host for ZAP daemon format_type: Output format (xml,\n  json, html) output_file: Output file path additional_args: Additional ZAP arguments'\nreturns: ZAP scan results\nparameters:\n- name: target\n  type: string\n  required: false\n  description: Target URL\n  default: ''\n- name: scan_type\n  type: string\n  required: false\n  description: Type of scan (baseline, full, api)\n  default: baseline\n- name: api_key\n  type: string\n  required: false\n  description: ZAP API key\n  default: ''\n- name: daemon\n  type: boolean\n  required: false\n  description: Run in daemon mode\n  default: false\n- name: port\n  type: string\n  required: false\n  description: Port for ZAP daemon\n  default: '8090'\n- name: host\n  type: string\n  required: false\n  description: Host for ZAP daemon\n  default: 0.0.0.0\n- name: format_type\n  type: string\n  required: false\n  description: Output format (xml, json, html)\n  default: xml\n- name: output_file\n  type: string\n  required: false\n  description: Output file path\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional ZAP arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "zap_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass ZapHandler(AbstractHandler):\n    \"\"\"Handler for zap functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute zap with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            scan_type = data.get(\"scan_type\", \"baseline\")\n            api_key = data.get(\"api_key\", \"\")\n            daemon = data.get(\"daemon\", False)\n            port = data.get(\"port\", \"8090\")\n            host = data.get(\"host\", \"0.0.0.0\")\n            format_type = data.get(\"format\", \"xml\")\n            output_file = data.get(\"output_file\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target and scan_type != \"daemon\":\n                logger.warning(\"ðŸŽ¯ ZAP called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required for scans\"\n                \n                }\n            if daemon:\n                command = f\"zaproxy -daemon -host {host} -port {port}\"\n                if api_key:\n                    command += f\" -config api.key={api_key}\"\n            else:\n                command = f\"zaproxy -cmd -quickurl {target}\"\n                if format_type:\n                    command += f\" -quickout {format_type}\"\n                if output_file:\n                    command += f\" -quickprogress -dir \\\"{output_file}\\\"\"\n                if api_key:\n                    command += f\" -config api.key={api_key}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting ZAP scan: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š ZAP scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in zap endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182510
    },
    {
      "id": "binary_vulnerability_analysis-xxd_hexdump",
      "name": "Xxd Hexdump",
      "description": "Create a hex dump of a file using xxd with enhanced logging. file_path: Path to the file offset: Offset to start reading from length: Number of bytes to read additional_args: Additional xxd arguments",
      "license": "MIT",
      "content": "---\nname: xxd_hexdump\ncapabilities: ['file-path', 'offset', 'length', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'xxd']\n---\n\n# Xxd Hexdump\n\nCreate a hex dump of a file using xxd with enhanced logging. file_path: Path to the file offset: Offset to start reading from length: Number of bytes to read additional_args: Additional xxd arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file\n- **offset** (string, Optional) (default: 0): Offset to start reading from\n- **length** (string, Optional): Number of bytes to read\n- **additional_args** (string, Optional): Additional xxd arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/xxd`\n\n**Returns:** Hex dump results\n\n## Files Included\n\n- `xxd_hexdump.yaml` - Tool configuration\n- `xxd_hexdump.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: xxd_hexdump\ncapabilities: ['file-path', 'offset', 'length', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'xxd']\n---\n\n# Xxd Hexdump\n\nCreate a hex dump of a file using xxd with enhanced logging. file_path: Path to the file offset: Offset to start reading from length: Number of bytes to read additional_args: Additional xxd arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file\n- **offset** (string, Optional) (default: 0): Offset to start reading from\n- **length** (string, Optional): Number of bytes to read\n- **additional_args** (string, Optional): Additional xxd arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/xxd`\n\n**Returns:** Hex dump results\n\n## Files Included\n\n- `xxd_hexdump.yaml` - Tool configuration\n- `xxd_hexdump.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "xxd_hexdump.yaml",
          "content": "name: xxd_hexdump\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, xxd]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/xxd\ndescription: 'Create a hex dump of a file using xxd with enhanced logging. file_path:\n  Path to the file offset: Offset to start reading from length: Number of bytes to\n  read additional_args: Additional xxd arguments'\nreturns: Hex dump results\nparameters:\n- name: file_path\n  type: string\n  required: true\n  description: Path to the file\n- name: offset\n  type: string\n  required: false\n  description: Offset to start reading from\n  default: '0'\n- name: length\n  type: string\n  required: false\n  description: Number of bytes to read\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional xxd arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "xxd_hexdump.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass XxdHandler(AbstractHandler):\n    \"\"\"Handler for xxd functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute xxd with enhanced logging\"\"\"\n        try:\n            file_path = data.get(\"file_path\", \"\")\n            offset = data.get(\"offset\", \"0\")\n            length = data.get(\"length\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not file_path:\n                logger.warning(\"ðŸ”§ XXD called without file_path parameter\")\n                return {\n    \n                    \"error\": \"File path parameter is required\"\n                \n                }\n            command = f\"xxd -s {offset}\"\n            if length:\n                command += f\" -l {length}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {file_path}\"\n            logger.info(f\"ðŸ”§ Starting XXD hex dump: {file_path}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š XXD hex dump completed for {file_path}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in xxd endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182512
    },
    {
      "id": "binary_exploitation-libc_database_lookup",
      "name": "Libc Database Lookup",
      "description": "Execute libc-database for libc identification and offset lookup. action: Action to perform (find, dump, download) symbols: Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\") libc_id: Libc ID for dump/download actions additional_args: Additional arguments",
      "license": "MIT",
      "content": "---\nname: libc_database_lookup\ncapabilities: ['action', 'symbols', 'libc-id', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'libc-database']\n---\n\n# Libc Database Lookup\n\nExecute libc-database for libc identification and offset lookup. action: Action to perform (find, dump, download) symbols: Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\") libc_id: Libc ID for dump/download actions additional_args: Additional arguments\n\n## Parameters\n- **action** (string, Optional) (default: find): Action to perform (find, dump, download)\n- **symbols** (string, Optional): Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\")\n- **libc_id** (string, Optional): Libc ID for dump/download actions\n- **additional_args** (string, Optional): Additional arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/libc-database`\n\n**Returns:** Libc database lookup results\n\n## Files Included\n\n- `libc_database_lookup.yaml` - Tool configuration\n- `libc_database_lookup.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: libc_database_lookup\ncapabilities: ['action', 'symbols', 'libc-id', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'libc-database']\n---\n\n# Libc Database Lookup\n\nExecute libc-database for libc identification and offset lookup. action: Action to perform (find, dump, download) symbols: Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\") libc_id: Libc ID for dump/download actions additional_args: Additional arguments\n\n## Parameters\n- **action** (string, Optional) (default: find): Action to perform (find, dump, download)\n- **symbols** (string, Optional): Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\")\n- **libc_id** (string, Optional): Libc ID for dump/download actions\n- **additional_args** (string, Optional): Additional arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/libc-database`\n\n**Returns:** Libc database lookup results\n\n## Files Included\n\n- `libc_database_lookup.yaml` - Tool configuration\n- `libc_database_lookup.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "libc_database_lookup.yaml",
          "content": "name: libc_database_lookup\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, libc-database]\ncategory: binary_exploitation\nendpoint: api/tools/libc-database\ndescription: 'Execute libc-database for libc identification and offset lookup. action:\n  Action to perform (find, dump, download) symbols: Symbols with offsets for find\n  action (format: \"symbol1:offset1 symbol2:offset2\") libc_id: Libc ID for dump/download\n  actions additional_args: Additional arguments'\nreturns: Libc database lookup results\nparameters:\n- name: action\n  type: string\n  required: false\n  description: Action to perform (find, dump, download)\n  default: find\n- name: symbols\n  type: string\n  required: false\n  description: 'Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\")'\n  default: ''\n- name: libc_id\n  type: string\n  required: false\n  description: Libc ID for dump/download actions\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "libc_database_lookup.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass LibcDatabaseHandler(AbstractHandler):\n    \"\"\"Handler for libc_database functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute libc_database with enhanced logging\"\"\"\n        try:\n            action = data.get(\"action\", \"find\")  # find, dump, download\n            symbols = data.get(\"symbols\", \"\")  # format: \"symbol1:offset1 symbol2:offset2\"\n            libc_id = data.get(\"libc_id\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if action == \"find\" and not symbols:\n                logger.warning(\"ðŸ”§ libc-database find called without symbols\")\n                return {\"error\": \"Symbols parameter is required for find action\"}\n            if action in [\"dump\", \"download\"] and not libc_id:\n                logger.warning(\"ðŸ”§ libc-database called without libc_id for dump/download\")\n                return {\"error\": \"libc_id parameter is required for dump/download actions\"}\n            base_command = \"cd /opt/libc-database 2>/dev/null || cd ~/libc-database 2>/dev/null || echo 'libc-database not found'\"\n            if action == \"find\":\n                command = f\"{base_command} && ./find {symbols}\"\n            elif action == \"dump\":\n                command = f\"{base_command} && ./dump {libc_id}\"\n            elif action == \"download\":\n                command = f\"{base_command} && ./download {libc_id}\"\n            else:\n                return {\"error\": f\"Invalid action: {action}\"}\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting libc-database {action}: {symbols or libc_id}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š libc-database {action} completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in libc-database endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182514
    },
    {
      "id": "binary_exploitation-ropper_gadget_search",
      "name": "Ropper Gadget Search",
      "description": "Execute ropper for advanced ROP/JOP gadget searching. binary: Binary to search for gadgets gadget_type: Type of gadgets (rop, jop, sys, all) quality: Gadget quality level (1-5) arch: Target architecture (x86, x86_64, arm, etc.) search_string: Specific gadget pattern to search for additional_args: Additional ropper arguments",
      "license": "MIT",
      "content": "---\nname: ropper_gadget_search\ncapabilities: ['binary', 'gadget-type', 'quality', 'arch', 'search-string', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ropper']\n---\n\n# Ropper Gadget Search\n\nExecute ropper for advanced ROP/JOP gadget searching. binary: Binary to search for gadgets gadget_type: Type of gadgets (rop, jop, sys, all) quality: Gadget quality level (1-5) arch: Target architecture (x86, x86_64, arm, etc.) search_string: Specific gadget pattern to search for additional_args: Additional ropper arguments\n\n## Parameters\n- **binary** (string, Required): Binary to search for gadgets\n- **gadget_type** (string, Optional) (default: rop): Type of gadgets (rop, jop, sys, all)\n- **quality** (integer, Optional) (default: 1): Gadget quality level (1-5)\n- **arch** (string, Optional): Target architecture (x86, x86_64, arm, etc.)\n- **search_string** (string, Optional): Specific gadget pattern to search for\n- **additional_args** (string, Optional): Additional ropper arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/ropper`\n\n**Returns:** Advanced ROP/JOP gadget search results\n\n## Files Included\n\n- `ropper_gadget_search.yaml` - Tool configuration\n- `ropper_gadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: ropper_gadget_search\ncapabilities: ['binary', 'gadget-type', 'quality', 'arch', 'search-string', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ropper']\n---\n\n# Ropper Gadget Search\n\nExecute ropper for advanced ROP/JOP gadget searching. binary: Binary to search for gadgets gadget_type: Type of gadgets (rop, jop, sys, all) quality: Gadget quality level (1-5) arch: Target architecture (x86, x86_64, arm, etc.) search_string: Specific gadget pattern to search for additional_args: Additional ropper arguments\n\n## Parameters\n- **binary** (string, Required): Binary to search for gadgets\n- **gadget_type** (string, Optional) (default: rop): Type of gadgets (rop, jop, sys, all)\n- **quality** (integer, Optional) (default: 1): Gadget quality level (1-5)\n- **arch** (string, Optional): Target architecture (x86, x86_64, arm, etc.)\n- **search_string** (string, Optional): Specific gadget pattern to search for\n- **additional_args** (string, Optional): Additional ropper arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/ropper`\n\n**Returns:** Advanced ROP/JOP gadget search results\n\n## Files Included\n\n- `ropper_gadget_search.yaml` - Tool configuration\n- `ropper_gadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "ropper_gadget_search.yaml",
          "content": "name: ropper_gadget_search\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, ropper]\ncategory: binary_exploitation\nendpoint: api/tools/ropper\ndescription: 'Execute ropper for advanced ROP/JOP gadget searching. binary: Binary\n  to search for gadgets gadget_type: Type of gadgets (rop, jop, sys, all) quality:\n  Gadget quality level (1-5) arch: Target architecture (x86, x86_64, arm, etc.) search_string:\n  Specific gadget pattern to search for additional_args: Additional ropper arguments'\nreturns: Advanced ROP/JOP gadget search results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Binary to search for gadgets\n- name: gadget_type\n  type: string\n  required: false\n  description: Type of gadgets (rop, jop, sys, all)\n  default: rop\n- name: quality\n  type: integer\n  required: false\n  description: Gadget quality level (1-5)\n  default: 1\n- name: arch\n  type: string\n  required: false\n  description: Target architecture (x86, x86_64, arm, etc.)\n  default: ''\n- name: search_string\n  type: string\n  required: false\n  description: Specific gadget pattern to search for\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional ropper arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "ropper_gadget_search.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass RopperHandler(AbstractHandler):\n    \"\"\"Handler for ropper functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute ropper with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            gadget_type = data.get(\"gadget_type\", \"rop\")  # rop, jop, sys, all\n            quality = data.get(\"quality\", 1)  # 1-5, higher = better quality\n            arch = data.get(\"arch\", \"\")  # x86, x86_64, arm, etc.\n            search_string = data.get(\"search_string\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ ropper called without binary parameter\")\n                return {\"error\": \"Binary parameter is required\"}\n            command = f\"ropper --file {binary}\"\n            if gadget_type == \"rop\":\n                command += \" --rop\"\n            elif gadget_type == \"jop\":\n                command += \" --jop\"\n            elif gadget_type == \"sys\":\n                command += \" --sys\"\n            elif gadget_type == \"all\":\n                command += \" --all\"\n            if quality > 1:\n                command += f\" --quality {quality}\"\n            if arch:\n                command += f\" --arch {arch}\"\n            if search_string:\n                command += f\" --search '{search_string}'\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting ropper analysis: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š ropper analysis completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in ropper endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182515
    },
    {
      "id": "binary_exploitation-ropgadget_search",
      "name": "Ropgadget Search",
      "description": "Search for ROP gadgets in a binary using ROPgadget with enhanced logging. binary: Path to the binary file gadget_type: Type of gadgets to search for additional_args: Additional ROPgadget arguments",
      "license": "MIT",
      "content": "---\nname: ropgadget_search\ncapabilities: ['binary', 'gadget-type', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ropgadget']\n---\n\n# Ropgadget Search\n\nSearch for ROP gadgets in a binary using ROPgadget with enhanced logging. binary: Path to the binary file gadget_type: Type of gadgets to search for additional_args: Additional ROPgadget arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **gadget_type** (string, Optional): Type of gadgets to search for\n- **additional_args** (string, Optional): Additional ROPgadget arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/ropgadget`\n\n**Returns:** ROP gadget search results\n\n## Files Included\n\n- `ropgadget_search.yaml` - Tool configuration\n- `ropgadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: ropgadget_search\ncapabilities: ['binary', 'gadget-type', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ropgadget']\n---\n\n# Ropgadget Search\n\nSearch for ROP gadgets in a binary using ROPgadget with enhanced logging. binary: Path to the binary file gadget_type: Type of gadgets to search for additional_args: Additional ROPgadget arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **gadget_type** (string, Optional): Type of gadgets to search for\n- **additional_args** (string, Optional): Additional ROPgadget arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/ropgadget`\n\n**Returns:** ROP gadget search results\n\n## Files Included\n\n- `ropgadget_search.yaml` - Tool configuration\n- `ropgadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "ropgadget_search.yaml",
          "content": "name: ropgadget_search\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, ropgadget]\ncategory: binary_exploitation\nendpoint: api/tools/ropgadget\ndescription: 'Search for ROP gadgets in a binary using ROPgadget with enhanced logging.\n  binary: Path to the binary file gadget_type: Type of gadgets to search for additional_args:\n  Additional ROPgadget arguments'\nreturns: ROP gadget search results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: gadget_type\n  type: string\n  required: false\n  description: Type of gadgets to search for\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional ROPgadget arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "ropgadget_search.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass RopgadgetHandler(AbstractHandler):\n    \"\"\"Handler for ropgadget functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute ropgadget with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            gadget_type = data.get(\"gadget_type\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ ROPgadget called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            command = f\"ROPgadget --binary {binary}\"\n            if gadget_type:\n                command += f\" --only '{gadget_type}'\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting ROPgadget search: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š ROPgadget search completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in ropgadget endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182516
    },
    {
      "id": "binary_exploitation-gdb_peda_debug",
      "name": "Gdb Peda Debug",
      "description": "Execute GDB with PEDA for enhanced debugging and exploitation. binary: Binary to debug commands: GDB commands to execute attach_pid: Process ID to attach to core_file: Core dump file to analyze additional_args: Additional GDB arguments",
      "license": "MIT",
      "content": "---\nname: gdb_peda_debug\ncapabilities: ['binary', 'commands', 'attach-pid', 'core-file', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'gdb', 'peda']\n---\n\n# Gdb Peda Debug\n\nExecute GDB with PEDA for enhanced debugging and exploitation. binary: Binary to debug commands: GDB commands to execute attach_pid: Process ID to attach to core_file: Core dump file to analyze additional_args: Additional GDB arguments\n\n## Parameters\n- **binary** (string, Optional): Binary to debug\n- **commands** (string, Optional): GDB commands to execute\n- **attach_pid** (integer, Optional): Process ID to attach to\n- **core_file** (string, Optional): Core dump file to analyze\n- **additional_args** (string, Optional): Additional GDB arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/gdb-peda`\n\n**Returns:** Enhanced debugging results with PEDA\n\n## Files Included\n\n- `gdb_peda_debug.yaml` - Tool configuration\n- `gdb_peda_debug.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: gdb_peda_debug\ncapabilities: ['binary', 'commands', 'attach-pid', 'core-file', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'gdb', 'peda']\n---\n\n# Gdb Peda Debug\n\nExecute GDB with PEDA for enhanced debugging and exploitation. binary: Binary to debug commands: GDB commands to execute attach_pid: Process ID to attach to core_file: Core dump file to analyze additional_args: Additional GDB arguments\n\n## Parameters\n- **binary** (string, Optional): Binary to debug\n- **commands** (string, Optional): GDB commands to execute\n- **attach_pid** (integer, Optional): Process ID to attach to\n- **core_file** (string, Optional): Core dump file to analyze\n- **additional_args** (string, Optional): Additional GDB arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/gdb-peda`\n\n**Returns:** Enhanced debugging results with PEDA\n\n## Files Included\n\n- `gdb_peda_debug.yaml` - Tool configuration\n- `gdb_peda_debug.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "gdb_peda_debug.yaml",
          "content": "name: gdb_peda_debug\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, gdb, peda]\ncategory: binary_exploitation\nendpoint: api/tools/gdb-peda\ndescription: 'Execute GDB with PEDA for enhanced debugging and exploitation. binary:\n  Binary to debug commands: GDB commands to execute attach_pid: Process ID to attach\n  to core_file: Core dump file to analyze additional_args: Additional GDB arguments'\nreturns: Enhanced debugging results with PEDA\nparameters:\n- name: binary\n  type: string\n  required: false\n  description: Binary to debug\n  default: ''\n- name: commands\n  type: string\n  required: false\n  description: GDB commands to execute\n  default: ''\n- name: attach_pid\n  type: integer\n  required: false\n  description: Process ID to attach to\n  default: 0\n- name: core_file\n  type: string\n  required: false\n  description: Core dump file to analyze\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional GDB arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "gdb_peda_debug.py",
          "content": "import os\nfrom typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass GdbPedaHandler(AbstractHandler):\n    \"\"\"Handler for gdb_peda functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        try:\n            binary = data.get(\"binary\", \"\")\n            commands = data.get(\"commands\", \"\")\n            attach_pid = data.get(\"attach_pid\", 0)\n            core_file = data.get(\"core_file\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n    \n            if not binary and not attach_pid and not core_file:\n                logger.warning(\"ðŸ”§ GDB-PEDA called without binary, PID, or core file\")\n                return {\"error\": \"Binary, PID, or core file parameter is required\"}\n    \n            # Base GDB command with PEDA\n            command = \"gdb -q\"\n    \n            if binary:\n                command += f\" {binary}\"\n    \n            if core_file:\n                command += f\" {core_file}\"\n    \n            if attach_pid:\n                command += f\" -p {attach_pid}\"\n    \n            # Create command script\n            if commands:\n                temp_script = \"/tmp/gdb_peda_commands.txt\"\n                peda_commands = f\"\"\"\n    source ~/peda/peda.py\n    {commands}\n    quit\n    \"\"\"\n                with open(temp_script, \"w\") as f:\n                    f.write(peda_commands)\n                command += f\" -x {temp_script}\"\n            else:\n                # Default PEDA initialization\n                command += \" -ex 'source ~/peda/peda.py' -ex 'quit'\"\n    \n            if additional_args:\n                command += f\" {additional_args}\"\n    \n            target_info = binary or f'PID {attach_pid}' or core_file\n            logger.info(f\"ðŸ”§ Starting GDB-PEDA analysis: {target_info}\")\n            result = execute_command(command)\n    \n            # Cleanup\n            if commands and os.path.exists(\"/tmp/gdb_peda_commands.txt\"):\n                try:\n                    os.remove(\"/tmp/gdb_peda_commands.txt\")\n                except:\n                    pass\n    \n            logger.info(f\"ðŸ“Š GDB-PEDA analysis completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in gdb-peda endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182518
    },
    {
      "id": "binary_vulnerability_analysis-radare2_analyze",
      "name": "Radare2 Analyze",
      "description": "Execute Radare2 for binary analysis and reverse engineering with enhanced logging. binary: Path to the binary file commands: Radare2 commands to execute additional_args: Additional Radare2 arguments",
      "license": "MIT",
      "content": "---\nname: radare2_analyze\ncapabilities: ['binary', 'commands', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'radare2']\n---\n\n# Radare2 Analyze\n\nExecute Radare2 for binary analysis and reverse engineering with enhanced logging. binary: Path to the binary file commands: Radare2 commands to execute additional_args: Additional Radare2 arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **commands** (string, Optional): Radare2 commands to execute\n- **additional_args** (string, Optional): Additional Radare2 arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/radare2`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `radare2_analyze.yaml` - Tool configuration\n- `radare2_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: radare2_analyze\ncapabilities: ['binary', 'commands', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'radare2']\n---\n\n# Radare2 Analyze\n\nExecute Radare2 for binary analysis and reverse engineering with enhanced logging. binary: Path to the binary file commands: Radare2 commands to execute additional_args: Additional Radare2 arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **commands** (string, Optional): Radare2 commands to execute\n- **additional_args** (string, Optional): Additional Radare2 arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/radare2`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `radare2_analyze.yaml` - Tool configuration\n- `radare2_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "radare2_analyze.yaml",
          "content": "name: radare2_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, radare2]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/radare2\ndescription: 'Execute Radare2 for binary analysis and reverse engineering with enhanced\n  logging. binary: Path to the binary file commands: Radare2 commands to execute additional_args:\n  Additional Radare2 arguments'\nreturns: Binary analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: commands\n  type: string\n  required: false\n  description: Radare2 commands to execute\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Radare2 arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "radare2_analyze.py",
          "content": "import os\nfrom typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass Radare2Handler(AbstractHandler):\n    \"\"\"Handler for radare2 functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute radare2 with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            commands = data.get(\"commands\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ Radare2 called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            if commands:\n                temp_script = \"/tmp/r2_commands.txt\"\n                with open(temp_script, \"w\") as f:\n                    f.write(commands)\n                command = f\"r2 -i {temp_script} -q {binary}\"\n            else:\n                command = f\"r2 -q {binary}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting Radare2 analysis: {binary}\")\n            result = execute_command(command)\n            # todo rm files\n            if commands and os.path.exists(\"/tmp/r2_commands.txt\"):\n                try:\n                    os.remove(\"/tmp/r2_commands.txt\")\n                except:\n                    pass\n            logger.info(f\"ðŸ“Š Radare2 analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in radare2 endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182519
    },
    {
      "id": "binary_exploitation-one_gadget_search",
      "name": "One Gadget Search",
      "description": "Execute one_gadget to find one-shot RCE gadgets in libc. libc_path: Path to libc binary level: Constraint level (0, 1, 2) additional_args: Additional one_gadget arguments",
      "license": "MIT",
      "content": "---\nname: one_gadget_search\ncapabilities: ['libc-path', 'level', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'one_gadget']\n---\n\n# One Gadget Search\n\nExecute one_gadget to find one-shot RCE gadgets in libc. libc_path: Path to libc binary level: Constraint level (0, 1, 2) additional_args: Additional one_gadget arguments\n\n## Parameters\n- **libc_path** (string, Required): Path to libc binary\n- **level** (integer, Optional) (default: 1): Constraint level (0, 1, 2)\n- **additional_args** (string, Optional): Additional one_gadget arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/one-gadget`\n\n**Returns:** One-shot RCE gadget search results\n\n## Files Included\n\n- `one_gadget_search.yaml` - Tool configuration\n- `one_gadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: one_gadget_search\ncapabilities: ['libc-path', 'level', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'one_gadget']\n---\n\n# One Gadget Search\n\nExecute one_gadget to find one-shot RCE gadgets in libc. libc_path: Path to libc binary level: Constraint level (0, 1, 2) additional_args: Additional one_gadget arguments\n\n## Parameters\n- **libc_path** (string, Required): Path to libc binary\n- **level** (integer, Optional) (default: 1): Constraint level (0, 1, 2)\n- **additional_args** (string, Optional): Additional one_gadget arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/one-gadget`\n\n**Returns:** One-shot RCE gadget search results\n\n## Files Included\n\n- `one_gadget_search.yaml` - Tool configuration\n- `one_gadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "one_gadget_search.yaml",
          "content": "name: one_gadget_search\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, one_gadget]\ncategory: binary_exploitation\nendpoint: api/tools/one-gadget\ndescription: 'Execute one_gadget to find one-shot RCE gadgets in libc. libc_path:\n  Path to libc binary level: Constraint level (0, 1, 2) additional_args: Additional\n  one_gadget arguments'\nreturns: One-shot RCE gadget search results\nparameters:\n- name: libc_path\n  type: string\n  required: true\n  description: Path to libc binary\n- name: level\n  type: integer\n  required: false\n  description: Constraint level (0, 1, 2)\n  default: 1\n- name: additional_args\n  type: string\n  required: false\n  description: Additional one_gadget arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "one_gadget_search.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass OneGadgetHandler(AbstractHandler):\n    \"\"\"Handler for one_gadget functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute one_gadget with enhanced logging\"\"\"\n        try:\n            libc_path = data.get(\"libc_path\", \"\")\n            level = data.get(\"level\", 1)  # 0, 1, 2 for different constraint levels\n            additional_args = data.get(\"additional_args\", \"\")\n            if not libc_path:\n                logger.warning(\"ðŸ”§ one_gadget called without libc_path parameter\")\n                return {\"error\": \"libc_path parameter is required\"}\n            command = f\"one_gadget {libc_path} --level {level}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting one_gadget analysis: {libc_path}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š one_gadget analysis completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in one_gadget endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182520
    },
    {
      "id": "binary_vulnerability_analysis-binwalk_analyze",
      "name": "Binwalk Analyze",
      "description": "Execute Binwalk for firmware and file analysis with enhanced logging. file_path: Path to the file to analyze extract: Whether to extract discovered files additional_args: Additional Binwalk arguments",
      "license": "MIT",
      "content": "---\nname: binwalk_analyze\ncapabilities: ['file-path', 'extract', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'binwalk']\n---\n\n# Binwalk Analyze\n\nExecute Binwalk for firmware and file analysis with enhanced logging. file_path: Path to the file to analyze extract: Whether to extract discovered files additional_args: Additional Binwalk arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file to analyze\n- **extract** (boolean, Optional): Whether to extract discovered files\n- **additional_args** (string, Optional): Additional Binwalk arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/binwalk`\n\n**Returns:** Firmware analysis results\n\n## Files Included\n\n- `binwalk_analyze.yaml` - Tool configuration\n- `binwalk_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: binwalk_analyze\ncapabilities: ['file-path', 'extract', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'binwalk']\n---\n\n# Binwalk Analyze\n\nExecute Binwalk for firmware and file analysis with enhanced logging. file_path: Path to the file to analyze extract: Whether to extract discovered files additional_args: Additional Binwalk arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file to analyze\n- **extract** (boolean, Optional): Whether to extract discovered files\n- **additional_args** (string, Optional): Additional Binwalk arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/binwalk`\n\n**Returns:** Firmware analysis results\n\n## Files Included\n\n- `binwalk_analyze.yaml` - Tool configuration\n- `binwalk_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "binwalk_analyze.yaml",
          "content": "name: binwalk_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, binwalk]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/binwalk\ndescription: 'Execute Binwalk for firmware and file analysis with enhanced logging.\n  file_path: Path to the file to analyze extract: Whether to extract discovered files\n  additional_args: Additional Binwalk arguments'\nreturns: Firmware analysis results\nparameters:\n- name: file_path\n  type: string\n  required: true\n  description: Path to the file to analyze\n- name: extract\n  type: boolean\n  required: false\n  description: Whether to extract discovered files\n  default: false\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Binwalk arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "binwalk_analyze.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass BinwalkHandler(AbstractHandler):\n    \"\"\"Handler for binwalk functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute binwalk with enhanced logging\"\"\"\n        try:\n            file_path = data.get(\"file_path\", \"\")\n            extract = data.get(\"extract\", False)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not file_path:\n                logger.warning(\"ðŸ”§ Binwalk called without file_path parameter\")\n                return {\n    \n                    \"error\": \"File path parameter is required\"\n                \n                }\n            command = f\"binwalk\"\n            if extract:\n                command += \" -e\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {file_path}\"\n            logger.info(f\"ðŸ”§ Starting Binwalk analysis: {file_path}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Binwalk analysis completed for {file_path}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in binwalk endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182521
    },
    {
      "id": "binary_vulnerability_analysis-objdump_analyze",
      "name": "Objdump Analyze",
      "description": "Analyze a binary using objdump with enhanced logging. binary: Path to the binary file disassemble: Whether to disassemble the binary additional_args: Additional objdump arguments",
      "license": "MIT",
      "content": "---\nname: objdump_analyze\ncapabilities: ['binary', 'disassemble', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'objdump']\n---\n\n# Objdump Analyze\n\nAnalyze a binary using objdump with enhanced logging. binary: Path to the binary file disassemble: Whether to disassemble the binary additional_args: Additional objdump arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **disassemble** (boolean, Optional) (default: True): Whether to disassemble the binary\n- **additional_args** (string, Optional): Additional objdump arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/objdump`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `objdump_analyze.yaml` - Tool configuration\n- `objdump_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: objdump_analyze\ncapabilities: ['binary', 'disassemble', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'objdump']\n---\n\n# Objdump Analyze\n\nAnalyze a binary using objdump with enhanced logging. binary: Path to the binary file disassemble: Whether to disassemble the binary additional_args: Additional objdump arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **disassemble** (boolean, Optional) (default: True): Whether to disassemble the binary\n- **additional_args** (string, Optional): Additional objdump arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/objdump`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `objdump_analyze.yaml` - Tool configuration\n- `objdump_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "objdump_analyze.yaml",
          "content": "name: objdump_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, objdump]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/objdump\ndescription: 'Analyze a binary using objdump with enhanced logging. binary: Path to\n  the binary file disassemble: Whether to disassemble the binary additional_args:\n  Additional objdump arguments'\nreturns: Binary analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: disassemble\n  type: boolean\n  required: false\n  description: Whether to disassemble the binary\n  default: true\n- name: additional_args\n  type: string\n  required: false\n  description: Additional objdump arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "objdump_analyze.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass ObjdumpHandler(AbstractHandler):\n    \"\"\"Handler for objdump functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute objdump with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            disassemble = data.get(\"disassemble\", True)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ Objdump called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            command = f\"objdump\"\n            if disassemble:\n                command += \" -d\"\n            else:\n                command += \" -x\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {binary}\"\n            logger.info(f\"ðŸ”§ Starting Objdump analysis: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Objdump analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in objdump endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182522
    },
    {
      "id": "binary_vulnerability_analysis-checksec_analyze",
      "name": "Checksec Analyze",
      "description": "Check security features of a binary with enhanced logging. binary: Path to the binary file",
      "license": "MIT",
      "content": "---\nname: checksec_analyze\ncapabilities: ['binary']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'checksec']\n---\n\n# Checksec Analyze\n\nCheck security features of a binary with enhanced logging. binary: Path to the binary file\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/checksec`\n\n**Returns:** Security features analysis results\n\n## Files Included\n\n- `checksec_analyze.yaml` - Tool configuration\n- `checksec_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: checksec_analyze\ncapabilities: ['binary']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'checksec']\n---\n\n# Checksec Analyze\n\nCheck security features of a binary with enhanced logging. binary: Path to the binary file\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/checksec`\n\n**Returns:** Security features analysis results\n\n## Files Included\n\n- `checksec_analyze.yaml` - Tool configuration\n- `checksec_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "checksec_analyze.yaml",
          "content": "name: checksec_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, checksec]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/checksec\ndescription: 'Check security features of a binary with enhanced logging. binary: Path\n  to the binary file'\nreturns: Security features analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n",
          "language": "yaml"
        },
        {
          "name": "checksec_analyze.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass ChecksecHandler(AbstractHandler):\n    \"\"\"Handler for checksec functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute checksec with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ Checksec called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            command = f\"checksec --file={binary}\"\n            logger.info(f\"ðŸ”§ Starting Checksec analysis: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Checksec analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in checksec endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182523
    },
    {
      "id": "binary_vulnerability_analysis-gdb_analyze",
      "name": "Gdb Analyze",
      "description": "Execute GDB for binary analysis and debugging with enhanced logging. binary: Path to the binary file commands: GDB commands to execute script_file: Path to GDB script file additional_args: Additional GDB arguments",
      "license": "MIT",
      "content": "---\nname: gdb_analyze\ncapabilities: ['binary', 'commands', 'script-file', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'gdb']\n---\n\n# Gdb Analyze\n\nExecute GDB for binary analysis and debugging with enhanced logging. binary: Path to the binary file commands: GDB commands to execute script_file: Path to GDB script file additional_args: Additional GDB arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **commands** (string, Optional): GDB commands to execute\n- **script_file** (string, Optional): Path to GDB script file\n- **additional_args** (string, Optional): Additional GDB arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/gdb`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `gdb_analyze.yaml` - Tool configuration\n- `gdb_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: gdb_analyze\ncapabilities: ['binary', 'commands', 'script-file', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'gdb']\n---\n\n# Gdb Analyze\n\nExecute GDB for binary analysis and debugging with enhanced logging. binary: Path to the binary file commands: GDB commands to execute script_file: Path to GDB script file additional_args: Additional GDB arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **commands** (string, Optional): GDB commands to execute\n- **script_file** (string, Optional): Path to GDB script file\n- **additional_args** (string, Optional): Additional GDB arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/gdb`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `gdb_analyze.yaml` - Tool configuration\n- `gdb_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "gdb_analyze.yaml",
          "content": "name: gdb_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, gdb]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/gdb\ndescription: 'Execute GDB for binary analysis and debugging with enhanced logging.\n  binary: Path to the binary file commands: GDB commands to execute script_file: Path\n  to GDB script file additional_args: Additional GDB arguments'\nreturns: Binary analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: commands\n  type: string\n  required: false\n  description: GDB commands to execute\n  default: ''\n- name: script_file\n  type: string\n  required: false\n  description: Path to GDB script file\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional GDB arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "gdb_analyze.py",
          "content": "import os\nfrom typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass GdbHandler(AbstractHandler):\n    \"\"\"Handler for gdb functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute gdb with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            commands = data.get(\"commands\", \"\")\n            script_file = data.get(\"script_file\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ GDB called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            command = f\"gdb {binary}\"\n            if script_file:\n                command += f\" -x {script_file}\"\n            if commands:\n                temp_script = \"/tmp/gdb_commands.txt\"\n                with open(temp_script, \"w\") as f:\n                    f.write(commands)\n                command += f\" -x {temp_script}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += \" -batch\"\n            logger.info(f\"ðŸ”§ Starting GDB analysis: {binary}\")\n            result = execute_command(command)\n            if commands and os.path.exists(\"/tmp/gdb_commands.txt\"):\n                try:\n                    os.remove(\"/tmp/gdb_commands.txt\")\n                except:\n                    pass\n            logger.info(f\"ðŸ“Š GDB analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in gdb endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182524
    },
    {
      "id": "binary_vulnerability_analysis-angr_symbolic_execution",
      "name": "Angr Symbolic Execution",
      "description": "Execute angr for symbolic execution and binary analysis. binary: Binary to analyze script_content: Custom angr script content find_address: Address to find during symbolic execution avoid_addresses: Comma-separated addresses to avoid analysis_type: Type of analysis (symbolic, cfg, static) additional_args: Additional arguments",
      "license": "MIT",
      "content": "---\nname: angr_symbolic_execution\ncapabilities: ['binary', 'script-content', 'find-address', 'avoid-addresses', 'analysis-type', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'angr']\n---\n\n# Angr Symbolic Execution\n\nExecute angr for symbolic execution and binary analysis. binary: Binary to analyze script_content: Custom angr script content find_address: Address to find during symbolic execution avoid_addresses: Comma-separated addresses to avoid analysis_type: Type of analysis (symbolic, cfg, static) additional_args: Additional arguments\n\n## Parameters\n- **binary** (string, Required): Binary to analyze\n- **script_content** (string, Optional): Custom angr script content\n- **find_address** (string, Optional): Address to find during symbolic execution\n- **avoid_addresses** (string, Optional): Comma-separated addresses to avoid\n- **analysis_type** (string, Optional) (default: symbolic): Type of analysis (symbolic, cfg, static)\n- **additional_args** (string, Optional): Additional arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/angr`\n\n**Returns:** Symbolic execution and binary analysis results\n\n## Files Included\n\n- `angr_symbolic_execution.yaml` - Tool configuration\n- `angr_symbolic_execution.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: angr_symbolic_execution\ncapabilities: ['binary', 'script-content', 'find-address', 'avoid-addresses', 'analysis-type', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'angr']\n---\n\n# Angr Symbolic Execution\n\nExecute angr for symbolic execution and binary analysis. binary: Binary to analyze script_content: Custom angr script content find_address: Address to find during symbolic execution avoid_addresses: Comma-separated addresses to avoid analysis_type: Type of analysis (symbolic, cfg, static) additional_args: Additional arguments\n\n## Parameters\n- **binary** (string, Required): Binary to analyze\n- **script_content** (string, Optional): Custom angr script content\n- **find_address** (string, Optional): Address to find during symbolic execution\n- **avoid_addresses** (string, Optional): Comma-separated addresses to avoid\n- **analysis_type** (string, Optional) (default: symbolic): Type of analysis (symbolic, cfg, static)\n- **additional_args** (string, Optional): Additional arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/angr`\n\n**Returns:** Symbolic execution and binary analysis results\n\n## Files Included\n\n- `angr_symbolic_execution.yaml` - Tool configuration\n- `angr_symbolic_execution.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "angr_symbolic_execution.yaml",
          "content": "name: angr_symbolic_execution\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, angr]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/angr\ndescription: 'Execute angr for symbolic execution and binary analysis. binary: Binary\n  to analyze script_content: Custom angr script content find_address: Address to find\n  during symbolic execution avoid_addresses: Comma-separated addresses to avoid analysis_type:\n  Type of analysis (symbolic, cfg, static) additional_args: Additional arguments'\nreturns: Symbolic execution and binary analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Binary to analyze\n- name: script_content\n  type: string\n  required: false\n  description: Custom angr script content\n  default: ''\n- name: find_address\n  type: string\n  required: false\n  description: Address to find during symbolic execution\n  default: ''\n- name: avoid_addresses\n  type: string\n  required: false\n  description: Comma-separated addresses to avoid\n  default: ''\n- name: analysis_type\n  type: string\n  required: false\n  description: Type of analysis (symbolic, cfg, static)\n  default: symbolic\n- name: additional_args\n  type: string\n  required: false\n  description: Additional arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "angr_symbolic_execution.py",
          "content": "import os\nfrom typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass AngrHandler(AbstractHandler):\n    \"\"\"Handler for angr functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        try:\n            binary = data.get(\"binary\", \"\")\n            script_content = data.get(\"script_content\", \"\")\n            find_address = data.get(\"find_address\", \"\")\n            avoid_addresses = data.get(\"avoid_addresses\", \"\")\n            analysis_type = data.get(\"analysis_type\", \"symbolic\")  # symbolic, cfg, static\n            additional_args = data.get(\"additional_args\", \"\")\n    \n            if not binary:\n                logger.warning(\"ðŸ”§ angr called without binary parameter\")\n                return {\"error\": \"Binary parameter is required\"}\n    \n            # Create angr script\n            script_file = \"/tmp/angr_analysis.py\"\n    \n            if script_content:\n                with open(script_file, \"w\") as f:\n                    f.write(script_content)\n            else:\n                # Generate basic angr template\n                template = f\"\"\"#!/usr/bin/env python3\n    import angr\n    import sys\n    \n    # Load binary\n    project = angr.Project('{binary}', auto_load_libs=False)\n    print(f\"Loaded binary: {binary}\")\n    print(f\"Architecture: {{project.arch}}\")\n    print(f\"Entry point: {{hex(project.entry)}}\")\n    \n    \"\"\"\n                if analysis_type == \"symbolic\":\n                    template += f\"\"\"\n    # Symbolic execution\n    state = project.factory.entry_state()\n    simgr = project.factory.simulation_manager(state)\n    \n    # Find and avoid addresses\n    find_addr = {find_address if find_address else 'None'}\n    avoid_addrs = {avoid_addresses.split(',') if avoid_addresses else '[]'}\n    \n    if find_addr:\n        simgr.explore(find=find_addr, avoid=avoid_addrs)\n        if simgr.found:\n            print(\"Found solution!\")\n            solution_state = simgr.found[0]\n            print(f\"Input: {{solution_state.posix.dumps(0)}}\")\n        else:\n            print(\"No solution found\")\n    else:\n        print(\"No find address specified, running basic analysis\")\n    \"\"\"\n                elif analysis_type == \"cfg\":\n                    template += \"\"\"\n    # Control Flow Graph analysis\n    cfg = project.analyses.CFGFast()\n    print(f\"CFG nodes: {len(cfg.graph.nodes())}\")\n    print(f\"CFG edges: {len(cfg.graph.edges())}\")\n    \n    # Function analysis\n    for func_addr, func in cfg.functions.items():\n        print(f\"Function: {func.name} at {hex(func_addr)}\")\n    \"\"\"\n    \n                with open(script_file, \"w\") as f:\n                    f.write(template)\n    \n            command = f\"python3 {script_file}\"\n    \n            if additional_args:\n                command += f\" {additional_args}\"\n    \n            logger.info(f\"ðŸ”§ Starting angr analysis: {binary}\")\n            result = execute_command(command, timeout=600)  # Longer timeout for symbolic execution\n    \n            # Cleanup\n            try:\n                os.remove(script_file)\n            except:\n                pass\n    \n            logger.info(f\"ðŸ“Š angr analysis completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in angr endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182525
    },
    {
      "id": "binary_vulnerability_analysis-strings_extract",
      "name": "Strings Extract",
      "description": "Extract strings from a binary file with enhanced logging. file_path: Path to the file min_len: Minimum string length additional_args: Additional strings arguments",
      "license": "MIT",
      "content": "---\nname: strings_extract\ncapabilities: ['file-path', 'min-len', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing']\n---\n\n# Strings Extract\n\nExtract strings from a binary file with enhanced logging. file_path: Path to the file min_len: Minimum string length additional_args: Additional strings arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file\n- **min_len** (integer, Optional) (default: 4): Minimum string length\n- **additional_args** (string, Optional): Additional strings arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/strings`\n\n**Returns:** String extraction results\n\n## Files Included\n\n- `strings_extract.yaml` - Tool configuration\n- `strings_extract.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: strings_extract\ncapabilities: ['file-path', 'min-len', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing']\n---\n\n# Strings Extract\n\nExtract strings from a binary file with enhanced logging. file_path: Path to the file min_len: Minimum string length additional_args: Additional strings arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file\n- **min_len** (integer, Optional) (default: 4): Minimum string length\n- **additional_args** (string, Optional): Additional strings arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/strings`\n\n**Returns:** String extraction results\n\n## Files Included\n\n- `strings_extract.yaml` - Tool configuration\n- `strings_extract.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "strings_extract.yaml",
          "content": "name: strings_extract\ntags: [binary_analysis, vulnerability_assessment, penetration_testing]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/strings\ndescription: 'Extract strings from a binary file with enhanced logging. file_path:\n  Path to the file min_len: Minimum string length additional_args: Additional strings\n  arguments'\nreturns: String extraction results\nparameters:\n- name: file_path\n  type: string\n  required: true\n  description: Path to the file\n- name: min_len\n  type: integer\n  required: false\n  description: Minimum string length\n  default: 4\n- name: additional_args\n  type: string\n  required: false\n  description: Additional strings arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "strings_extract.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass StringsHandler(AbstractHandler):\n    \"\"\"Handler for strings functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute strings with enhanced logging\"\"\"\n        try:\n            file_path = data.get(\"file_path\", \"\")\n            min_len = data.get(\"min_len\", 4)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not file_path:\n                logger.warning(\"ðŸ”§ Strings called without file_path parameter\")\n                return {\n    \n                    \"error\": \"File path parameter is required\"\n                \n                }\n            command = f\"strings -n {min_len}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {file_path}\"\n            logger.info(f\"ðŸ”§ Starting Strings extraction: {file_path}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Strings extraction completed for {file_path}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in strings endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182526
    },
    {
      "id": "binary_exploitation-pwninit_setup",
      "name": "Pwninit Setup",
      "description": "Execute pwninit for CTF binary exploitation setup. binary: Binary file to set up libc: Libc file to use ld: Loader file to use template_type: Template type (python, c) additional_args: Additional pwninit arguments",
      "license": "MIT",
      "content": "---\nname: pwninit_setup\ncapabilities: ['binary', 'libc', 'ld', 'template-type', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'pwninit']\n---\n\n# Pwninit Setup\n\nExecute pwninit for CTF binary exploitation setup. binary: Binary file to set up libc: Libc file to use ld: Loader file to use template_type: Template type (python, c) additional_args: Additional pwninit arguments\n\n## Parameters\n- **binary** (string, Required): Binary file to set up\n- **libc** (string, Optional): Libc file to use\n- **ld** (string, Optional): Loader file to use\n- **template_type** (string, Optional) (default: python): Template type (python, c)\n- **additional_args** (string, Optional): Additional pwninit arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/pwninit`\n\n**Returns:** CTF binary exploitation setup results\n\n## Files Included\n\n- `pwninit_setup.yaml` - Tool configuration\n- `pwninit_setup.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: pwninit_setup\ncapabilities: ['binary', 'libc', 'ld', 'template-type', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'pwninit']\n---\n\n# Pwninit Setup\n\nExecute pwninit for CTF binary exploitation setup. binary: Binary file to set up libc: Libc file to use ld: Loader file to use template_type: Template type (python, c) additional_args: Additional pwninit arguments\n\n## Parameters\n- **binary** (string, Required): Binary file to set up\n- **libc** (string, Optional): Libc file to use\n- **ld** (string, Optional): Loader file to use\n- **template_type** (string, Optional) (default: python): Template type (python, c)\n- **additional_args** (string, Optional): Additional pwninit arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/pwninit`\n\n**Returns:** CTF binary exploitation setup results\n\n## Files Included\n\n- `pwninit_setup.yaml` - Tool configuration\n- `pwninit_setup.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "pwninit_setup.yaml",
          "content": "name: pwninit_setup\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, pwninit]\ncategory: binary_exploitation\nendpoint: api/tools/pwninit\ndescription: 'Execute pwninit for CTF binary exploitation setup. binary: Binary file\n  to set up libc: Libc file to use ld: Loader file to use template_type: Template\n  type (python, c) additional_args: Additional pwninit arguments'\nreturns: CTF binary exploitation setup results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Binary file to set up\n- name: libc\n  type: string\n  required: false\n  description: Libc file to use\n  default: ''\n- name: ld\n  type: string\n  required: false\n  description: Loader file to use\n  default: ''\n- name: template_type\n  type: string\n  required: false\n  description: Template type (python, c)\n  default: python\n- name: additional_args\n  type: string\n  required: false\n  description: Additional pwninit arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "pwninit_setup.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass PwninitHandler(AbstractHandler):\n    \"\"\"Handler for pwninit functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute pwninit with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            libc = data.get(\"libc\", \"\")\n            ld = data.get(\"ld\", \"\")\n            template_type = data.get(\"template_type\", \"python\")  # python, c\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ pwninit called without binary parameter\")\n                return {\"error\": \"Binary parameter is required\"}\n            command = f\"pwninit --bin {binary}\"\n            if libc:\n                command += f\" --libc {libc}\"\n            if ld:\n                command += f\" --ld {ld}\"\n            if template_type:\n                command += f\" --template {template_type}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting pwninit setup: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š pwninit setup completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in pwninit endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182528
    },
    {
      "id": "binary_vulnerability_analysis-ghidra_analysis",
      "name": "Ghidra Analysis",
      "description": "Execute Ghidra for advanced binary analysis and reverse engineering. binary: Path to the binary file project_name: Ghidra project name script_file: Custom Ghidra script to run analysis_timeout: Analysis timeout in seconds output_format: Output format (xml, json) additional_args: Additional Ghidra arguments",
      "license": "MIT",
      "content": "---\nname: ghidra_analysis\ncapabilities: ['binary', 'project-name', 'script-file', 'analysis-timeout', 'output-format', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ghidra']\n---\n\n# Ghidra Analysis\n\nExecute Ghidra for advanced binary analysis and reverse engineering. binary: Path to the binary file project_name: Ghidra project name script_file: Custom Ghidra script to run analysis_timeout: Analysis timeout in seconds output_format: Output format (xml, json) additional_args: Additional Ghidra arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **project_name** (string, Optional) (default: hexstrike_analysis): Ghidra project name\n- **script_file** (string, Optional): Custom Ghidra script to run\n- **analysis_timeout** (integer, Optional) (default: 300): Analysis timeout in seconds\n- **output_format** (string, Optional) (default: xml): Output format (xml, json)\n- **additional_args** (string, Optional): Additional Ghidra arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/ghidra`\n\n**Returns:** Advanced binary analysis results from Ghidra\n\n## Files Included\n\n- `ghidra_analysis.yaml` - Tool configuration\n- `ghidra_analysis.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: ghidra_analysis\ncapabilities: ['binary', 'project-name', 'script-file', 'analysis-timeout', 'output-format', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ghidra']\n---\n\n# Ghidra Analysis\n\nExecute Ghidra for advanced binary analysis and reverse engineering. binary: Path to the binary file project_name: Ghidra project name script_file: Custom Ghidra script to run analysis_timeout: Analysis timeout in seconds output_format: Output format (xml, json) additional_args: Additional Ghidra arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **project_name** (string, Optional) (default: hexstrike_analysis): Ghidra project name\n- **script_file** (string, Optional): Custom Ghidra script to run\n- **analysis_timeout** (integer, Optional) (default: 300): Analysis timeout in seconds\n- **output_format** (string, Optional) (default: xml): Output format (xml, json)\n- **additional_args** (string, Optional): Additional Ghidra arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/ghidra`\n\n**Returns:** Advanced binary analysis results from Ghidra\n\n## Files Included\n\n- `ghidra_analysis.yaml` - Tool configuration\n- `ghidra_analysis.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "ghidra_analysis.yaml",
          "content": "name: ghidra_analysis\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, ghidra]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/ghidra\ndescription: 'Execute Ghidra for advanced binary analysis and reverse engineering.\n  binary: Path to the binary file project_name: Ghidra project name script_file: Custom\n  Ghidra script to run analysis_timeout: Analysis timeout in seconds output_format:\n  Output format (xml, json) additional_args: Additional Ghidra arguments'\nreturns: Advanced binary analysis results from Ghidra\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: project_name\n  type: string\n  required: false\n  description: Ghidra project name\n  default: hexstrike_analysis\n- name: script_file\n  type: string\n  required: false\n  description: Custom Ghidra script to run\n  default: ''\n- name: analysis_timeout\n  type: integer\n  required: false\n  description: Analysis timeout in seconds\n  default: 300\n- name: output_format\n  type: string\n  required: false\n  description: Output format (xml, json)\n  default: xml\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Ghidra arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "ghidra_analysis.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass GhidraHandler(AbstractHandler):\n    \"\"\"Handler for ghidra functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute ghidra with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            project_name = data.get(\"project_name\", \"hexstrike_analysis\")\n            script_file = data.get(\"script_file\", \"\")\n            analysis_timeout = data.get(\"analysis_timeout\", 300)\n            output_format = data.get(\"output_format\", \"xml\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ Ghidra called without binary parameter\")\n                return {\"error\": \"Binary parameter is required\"}\n            project_dir = f\"/tmp/ghidra_projects/{project_name}\"\n            os.makedirs(project_dir, exist_ok=True)\n            command = f\"analyzeHeadless {project_dir} {project_name} -import {binary} -deleteProject\"\n            if script_file:\n                command += f\" -postScript {script_file}\"\n            if output_format == \"xml\":\n                command += f\" -postScript ExportXml.java {project_dir}/analysis.xml\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting Ghidra analysis: {binary}\")\n            result = execute_command(command, timeout=analysis_timeout)\n            logger.info(f\"ðŸ“Š Ghidra analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in ghidra endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182529
    },
    {
      "id": "network_scanning-smbmap_scan",
      "name": "Smbmap Scan",
      "description": "Execute SMBMap for SMB share enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication additional_args: Additional SMBMap arguments",
      "license": "MIT",
      "content": "---\nname: smbmap_scan\ncapabilities: ['target', 'username', 'password', 'domain', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'smbmap']\n---\n\n# Smbmap Scan\n\nExecute SMBMap for SMB share enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication additional_args: Additional SMBMap arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **additional_args** (string, Optional): Additional SMBMap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/smbmap`\n\n**Returns:** SMB share enumeration results\n\n## Files Included\n\n- `smbmap_scan.yaml` - Tool configuration\n- `smbmap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: smbmap_scan\ncapabilities: ['target', 'username', 'password', 'domain', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'smbmap']\n---\n\n# Smbmap Scan\n\nExecute SMBMap for SMB share enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication additional_args: Additional SMBMap arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **additional_args** (string, Optional): Additional SMBMap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/smbmap`\n\n**Returns:** SMB share enumeration results\n\n## Files Included\n\n- `smbmap_scan.yaml` - Tool configuration\n- `smbmap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "smbmap_scan.yaml",
          "content": "name: smbmap_scan\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, smbmap]\nendpoint: api/tools/smbmap\ndescription: 'Execute SMBMap for SMB share enumeration with enhanced logging. target:\n  The target IP address username: Username for authentication password: Password for\n  authentication domain: Domain for authentication additional_args: Additional SMBMap\n  arguments'\nreturns: SMB share enumeration results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address\n- name: username\n  type: string\n  required: false\n  description: Username for authentication\n  default: ''\n- name: password\n  type: string\n  required: false\n  description: Password for authentication\n  default: ''\n- name: domain\n  type: string\n  required: false\n  description: Domain for authentication\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional SMBMap arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "smbmap_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass SmbmapHandler(AbstractHandler):\n    \"\"\"Handler for smbmap functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute smbmap with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            username = data.get(\"username\", \"\")\n            password = data.get(\"password\", \"\")\n            domain = data.get(\"domain\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ SMBMap called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"smbmap -H {target}\"\n            if username:\n                command += f\" -u {username}\"\n            if password:\n                command += f\" -p {password}\"\n            if domain:\n                command += f\" -d {domain}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting SMBMap: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š SMBMap completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in smbmap endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182531
    },
    {
      "id": "network_scanning-masscan_high_speed",
      "name": "Masscan High Speed",
      "description": "Execute Masscan for high-speed Internet-scale port scanning with intelligent rate limiting. target: The target IP address or CIDR range ports: Port range to scan rate: Packets per second rate interface: Network interface to use router_mac: Router MAC address source_ip: Source IP address banners: Enable banner grabbing additional_args: Additional Masscan arguments",
      "license": "MIT",
      "content": "---\nname: masscan_high_speed\ncapabilities: ['target', 'ports', 'rate', 'interface', 'router-mac', 'source-ip', 'banners', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'masscan']\n---\n\n# Masscan High Speed\n\nExecute Masscan for high-speed Internet-scale port scanning with intelligent rate limiting. target: The target IP address or CIDR range ports: Port range to scan rate: Packets per second rate interface: Network interface to use router_mac: Router MAC address source_ip: Source IP address banners: Enable banner grabbing additional_args: Additional Masscan arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or CIDR range\n- **ports** (string, Optional) (default: 1-65535): Port range to scan\n- **rate** (integer, Optional) (default: 1000): Packets per second rate\n- **interface** (string, Optional): Network interface to use\n- **router_mac** (string, Optional): Router MAC address\n- **source_ip** (string, Optional): Source IP address\n- **banners** (boolean, Optional): Enable banner grabbing\n- **additional_args** (string, Optional): Additional Masscan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/masscan`\n\n**Returns:** High-speed port scanning results with intelligent rate limiting\n\n## Files Included\n\n- `masscan_high_speed.yaml` - Tool configuration\n- `masscan_high_speed.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: masscan_high_speed\ncapabilities: ['target', 'ports', 'rate', 'interface', 'router-mac', 'source-ip', 'banners', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'masscan']\n---\n\n# Masscan High Speed\n\nExecute Masscan for high-speed Internet-scale port scanning with intelligent rate limiting. target: The target IP address or CIDR range ports: Port range to scan rate: Packets per second rate interface: Network interface to use router_mac: Router MAC address source_ip: Source IP address banners: Enable banner grabbing additional_args: Additional Masscan arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or CIDR range\n- **ports** (string, Optional) (default: 1-65535): Port range to scan\n- **rate** (integer, Optional) (default: 1000): Packets per second rate\n- **interface** (string, Optional): Network interface to use\n- **router_mac** (string, Optional): Router MAC address\n- **source_ip** (string, Optional): Source IP address\n- **banners** (boolean, Optional): Enable banner grabbing\n- **additional_args** (string, Optional): Additional Masscan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/masscan`\n\n**Returns:** High-speed port scanning results with intelligent rate limiting\n\n## Files Included\n\n- `masscan_high_speed.yaml` - Tool configuration\n- `masscan_high_speed.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "masscan.yaml",
          "content": "name: masscan_high_speed\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, masscan]\nendpoint: api/tools/masscan\ndescription: 'Execute Masscan for high-speed Internet-scale port scanning with intelligent rate limiting. target: The\n  target IP address or CIDR range ports: Port range to scan rate: Packets per second rate interface: Network interface\n  to use router_mac: Router MAC address source_ip: Source IP address banners: Enable banner grabbing additional_args:\n  Additional Masscan arguments'\nreturns: High-speed port scanning results with intelligent rate limiting\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address or CIDR range\n- name: ports\n  type: string\n  required: false\n  description: Port range to scan\n  default: 1-65535\n- name: rate\n  type: integer\n  required: false\n  description: Packets per second rate\n  default: 1000\n- name: interface\n  type: string\n  required: false\n  description: Network interface to use\n  default: ''\n- name: router_mac\n  type: string\n  required: false\n  description: Router MAC address\n  default: ''\n- name: source_ip\n  type: string\n  required: false\n  description: Source IP address\n  default: ''\n- name: banners\n  type: boolean\n  required: false\n  description: Enable banner grabbing\n  default: false\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Masscan arguments\n  default: ''",
          "language": "yaml"
        },
        {
          "name": "masscan.py",
          "content": "import logging\nfrom typing import Dict, Any\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass NmapHandler(AbstractHandler):\n    \"\"\"\n    ä»»æ„shellå‘½ä»¤\n    \"\"\"\n\n    def __init__(self, config: Dict):\n        super().__init__(config)\n\n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n\n    def handle(self, data: Dict) -> Any:\n        try:\n            target = data.get(\"target\", \"\")\n            ports = data.get(\"ports\", \"1-65535\")\n            rate = data.get(\"rate\", 1000)\n            interface = data.get(\"interface\", \"\")\n            router_mac = data.get(\"router_mac\", \"\")\n            source_ip = data.get(\"source_ip\", \"\")\n            banners = data.get(\"banners\", False)\n            additional_args = data.get(\"additional_args\", \"\")\n    \n            if not target:\n                logger.warning(\"ðŸŽ¯ Masscan called without target parameter\")\n                return {\"error\": \"Target parameter is required\"}\n    \n            command = f\"masscan {target} -p{ports} --rate={rate}\"\n    \n            if interface:\n                command += f\" -e {interface}\"\n    \n            if router_mac:\n                command += f\" --router-mac {router_mac}\"\n    \n            if source_ip:\n                command += f\" --source-ip {source_ip}\"\n    \n            if banners:\n                command += \" --banners\"\n    \n            if additional_args:\n                command += f\" {additional_args}\"\n    \n            logger.info(f\"ðŸš€ Starting Masscan: {target} at rate {rate}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Masscan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in masscan endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182533
    },
    {
      "id": "network_scanning-nmap_scan",
      "name": "Nmap Scan",
      "description": "Execute an enhanced Nmap scan against a target with real-time logging. target: The IP address or hostname to scan scan_type: Scan type (e.g., -sV for version detection, -sC for scripts) ports: Comma-separated list of ports or port ranges additional_args: Additional Nmap arguments",
      "license": "MIT",
      "content": "---\nname: nmap_scan\ncapabilities: ['target', 'scan-type', 'ports', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nmap']\n---\n\n# Nmap Scan\n\nExecute an enhanced Nmap scan against a target with real-time logging. target: The IP address or hostname to scan scan_type: Scan type (e.g., -sV for version detection, -sC for scripts) ports: Comma-separated list of ports or port ranges additional_args: Additional Nmap arguments\n\n## Parameters\n- **target** (string, Required): The IP address or hostname to scan\n- **scan_type** (string, Optional) (default: -sV): Scan type (e.g., -sV for version detection, -sC for scripts)\n- **ports** (string, Optional): Comma-separated list of ports or port ranges\n- **additional_args** (string, Optional): Additional Nmap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nmap`\n\n**Returns:** Scan results with enhanced telemetry\n\n## Files Included\n\n- `nmap_scan.yaml` - Tool configuration\n- `nmap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: nmap_scan\ncapabilities: ['target', 'scan-type', 'ports', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nmap']\n---\n\n# Nmap Scan\n\nExecute an enhanced Nmap scan against a target with real-time logging. target: The IP address or hostname to scan scan_type: Scan type (e.g., -sV for version detection, -sC for scripts) ports: Comma-separated list of ports or port ranges additional_args: Additional Nmap arguments\n\n## Parameters\n- **target** (string, Required): The IP address or hostname to scan\n- **scan_type** (string, Optional) (default: -sV): Scan type (e.g., -sV for version detection, -sC for scripts)\n- **ports** (string, Optional): Comma-separated list of ports or port ranges\n- **additional_args** (string, Optional): Additional Nmap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nmap`\n\n**Returns:** Scan results with enhanced telemetry\n\n## Files Included\n\n- `nmap_scan.yaml` - Tool configuration\n- `nmap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "nmap_scan.yaml",
          "content": "name: nmap_scan\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, nmap]\nendpoint: api/tools/nmap\ndescription: 'Execute an enhanced Nmap scan against a target with real-time logging. target: The IP address or hostname\n  to scan scan_type: Scan type (e.g., -sV for version detection, -sC for scripts) ports: Comma-separated list of ports\n  or port ranges additional_args: Additional Nmap arguments'\nreturns: Scan results with enhanced telemetry\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The IP address or hostname to scan\n- name: scan_type\n  type: string\n  required: false\n  description: Scan type (e.g., -sV for version detection, -sC for scripts)\n  default: -sV\n- name: ports\n  type: string\n  required: false\n  description: Comma-separated list of ports or port ranges\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Nmap arguments\n  default: ''",
          "language": "yaml"
        },
        {
          "name": "nmap_scan.py",
          "content": "import logging\nfrom typing import Dict, Any\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass NmapHandler(AbstractHandler):\n    \"\"\"\n    ä»»æ„shellå‘½ä»¤\n    \"\"\"\n\n    def __init__(self, config: Dict):\n        super().__init__(config)\n\n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n\n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute nmap scan with enhanced logging, caching, and intelligent error handling\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            scan_type = data.get(\"scan_type\", \"-sCV\")\n            ports = data.get(\"ports\", \"\")\n            additional_args = data.get(\"additional_args\", \"-T4 -Pn\")\n\n            if not target:\n                logger.warning(\"ðŸŽ¯ Nmap called without target parameter\")\n                return {\n                    \"error\": \"Target parameter is required\"\n                }\n\n            command = f\"nmap {scan_type}\"\n\n            if ports:\n                command += f\" -p {ports}\"\n\n            if additional_args:\n                command += f\" {additional_args}\"\n\n            command += f\" {target}\"\n\n            logger.info(f\"ðŸ” Starting Nmap scan: {target}\")\n            result = execute_command(command)\n\n            logger.info(f\"ðŸ“Š Nmap scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in nmap endpoint: {str(e)}\")\n            return {\n                \"error\": f\"Server error: {str(e)}\"\n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182534
    },
    {
      "id": "web_application_scanning-dotdotpwn_scan",
      "name": "Dotdotpwn Scan",
      "description": "Execute DotDotPwn for directory traversal testing with enhanced logging. target: The target hostname or IP module: Module to use (http, ftp, tftp, etc.) additional_args: Additional DotDotPwn arguments",
      "license": "MIT",
      "content": "---\nname: dotdotpwn_scan\ncapabilities: ['target', 'module', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dotdotpwn']\n---\n\n# Dotdotpwn Scan\n\nExecute DotDotPwn for directory traversal testing with enhanced logging. target: The target hostname or IP module: Module to use (http, ftp, tftp, etc.) additional_args: Additional DotDotPwn arguments\n\n## Parameters\n- **target** (string, Required): The target hostname or IP\n- **module** (string, Optional) (default: http): Module to use (http, ftp, tftp, etc.)\n- **additional_args** (string, Optional): Additional DotDotPwn arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/dotdotpwn`\n\n**Returns:** Directory traversal test results\n\n## Files Included\n\n- `dotdotpwn_scan.yaml` - Tool configuration\n- `dotdotpwn_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: dotdotpwn_scan\ncapabilities: ['target', 'module', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dotdotpwn']\n---\n\n# Dotdotpwn Scan\n\nExecute DotDotPwn for directory traversal testing with enhanced logging. target: The target hostname or IP module: Module to use (http, ftp, tftp, etc.) additional_args: Additional DotDotPwn arguments\n\n## Parameters\n- **target** (string, Required): The target hostname or IP\n- **module** (string, Optional) (default: http): Module to use (http, ftp, tftp, etc.)\n- **additional_args** (string, Optional): Additional DotDotPwn arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/dotdotpwn`\n\n**Returns:** Directory traversal test results\n\n## Files Included\n\n- `dotdotpwn_scan.yaml` - Tool configuration\n- `dotdotpwn_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "dotdotpwn_scan.yaml",
          "content": "name: dotdotpwn_scan\ncategory: web_application_scanning\ntags: [network_scanning, vulnerability_assessment, penetration_testing, dotdotpwn]\nendpoint: api/tools/dotdotpwn\ndescription: 'Execute DotDotPwn for directory traversal testing with enhanced logging.\n  target: The target hostname or IP module: Module to use (http, ftp, tftp, etc.)\n  additional_args: Additional DotDotPwn arguments'\nreturns: Directory traversal test results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target hostname or IP\n- name: module\n  type: string\n  required: false\n  description: Module to use (http, ftp, tftp, etc.)\n  default: http\n- name: additional_args\n  type: string\n  required: false\n  description: Additional DotDotPwn arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "dotdotpwn_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass DotdotpwnHandler(AbstractHandler):\n    \"\"\"Handler for dotdotpwn functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute dotdotpwn with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            module = data.get(\"module\", \"http\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ DotDotPwn called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"dotdotpwn -m {module} -h {target}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += \" -b\"\n            logger.info(f\"ðŸ” Starting DotDotPwn scan: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š DotDotPwn scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in dotdotpwn endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182535
    },
    {
      "id": "web_application_scanning-wafw00f_scan",
      "name": "Wafw00F Scan",
      "description": "Execute wafw00f to identify and fingerprint WAF products with enhanced logging. target: Target URL or IP additional_args: Additional wafw00f arguments",
      "license": "MIT",
      "content": "---\nname: wafw00f_scan\ncapabilities: ['target', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'wafw00f', 'waf']\n---\n\n# Wafw00F Scan\n\nExecute wafw00f to identify and fingerprint WAF products with enhanced logging. target: Target URL or IP additional_args: Additional wafw00f arguments\n\n## Parameters\n- **target** (string, Required): Target URL or IP\n- **additional_args** (string, Optional): Additional wafw00f arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/wafw00f`\n\n**Returns:** WAF detection results\n\n## Files Included\n\n- `wafw00f_scan.yaml` - Tool configuration\n- `wafw00f_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: wafw00f_scan\ncapabilities: ['target', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'wafw00f', 'waf']\n---\n\n# Wafw00F Scan\n\nExecute wafw00f to identify and fingerprint WAF products with enhanced logging. target: Target URL or IP additional_args: Additional wafw00f arguments\n\n## Parameters\n- **target** (string, Required): Target URL or IP\n- **additional_args** (string, Optional): Additional wafw00f arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/wafw00f`\n\n**Returns:** WAF detection results\n\n## Files Included\n\n- `wafw00f_scan.yaml` - Tool configuration\n- `wafw00f_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "wafw00f_scan.yaml",
          "content": "name: wafw00f_scan\ncategory: web_application_scanning\ntags: [network_scanning, vulnerability_assessment, penetration_testing, wafw00f, waf]\nendpoint: api/tools/wafw00f\ndescription: 'Execute wafw00f to identify and fingerprint WAF products with enhanced\n  logging. target: Target URL or IP additional_args: Additional wafw00f arguments'\nreturns: WAF detection results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: Target URL or IP\n- name: additional_args\n  type: string\n  required: false\n  description: Additional wafw00f arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "wafw00f_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass Wafw00fHandler(AbstractHandler):\n    \"\"\"Handler for wafw00f functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute wafw00f with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸ›¡ï¸ Wafw00f called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"wafw00f {target}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ›¡ï¸ Starting Wafw00f WAF detection: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Wafw00f completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in wafw00f endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182536
    },
    {
      "id": "subdomain_enumeration-dnsenum_scan",
      "name": "Dnsenum Scan",
      "description": "Execute dnsenum for DNS enumeration with enhanced logging. domain: Target domain dns_server: DNS server to use wordlist: Wordlist for brute forcing additional_args: Additional dnsenum arguments",
      "license": "MIT",
      "content": "---\nname: dnsenum_scan\ncapabilities: ['domain', 'dns-server', 'wordlist', 'additional-args']\ncategory: subdomain_enumeration\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dnsenum']\n---\n\n# Dnsenum Scan\n\nExecute dnsenum for DNS enumeration with enhanced logging. domain: Target domain dns_server: DNS server to use wordlist: Wordlist for brute forcing additional_args: Additional dnsenum arguments\n\n## Parameters\n- **domain** (string, Required): Target domain\n- **dns_server** (string, Optional): DNS server to use\n- **wordlist** (string, Optional): Wordlist for brute forcing\n- **additional_args** (string, Optional): Additional dnsenum arguments\n\n\n## Usage\n\nThis tool is part of the subdomain_enumeration category.\n\n**Endpoint:** `api/tools/dnsenum`\n\n**Returns:** DNS enumeration results\n\n## Files Included\n\n- `dnsenum_scan.yaml` - Tool configuration\n- `dnsenum_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: dnsenum_scan\ncapabilities: ['domain', 'dns-server', 'wordlist', 'additional-args']\ncategory: subdomain_enumeration\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dnsenum']\n---\n\n# Dnsenum Scan\n\nExecute dnsenum for DNS enumeration with enhanced logging. domain: Target domain dns_server: DNS server to use wordlist: Wordlist for brute forcing additional_args: Additional dnsenum arguments\n\n## Parameters\n- **domain** (string, Required): Target domain\n- **dns_server** (string, Optional): DNS server to use\n- **wordlist** (string, Optional): Wordlist for brute forcing\n- **additional_args** (string, Optional): Additional dnsenum arguments\n\n\n## Usage\n\nThis tool is part of the subdomain_enumeration category.\n\n**Endpoint:** `api/tools/dnsenum`\n\n**Returns:** DNS enumeration results\n\n## Files Included\n\n- `dnsenum_scan.yaml` - Tool configuration\n- `dnsenum_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "dnsenum_scan.yaml",
          "content": "name: dnsenum_scan\ncategory: subdomain_enumeration\ntags: [network_scanning, vulnerability_assessment, penetration_testing, dnsenum]\nendpoint: api/tools/dnsenum\ndescription: 'Execute dnsenum for DNS enumeration with enhanced logging. domain: Target\n  domain dns_server: DNS server to use wordlist: Wordlist for brute forcing additional_args:\n  Additional dnsenum arguments'\nreturns: DNS enumeration results\nparameters:\n- name: domain\n  type: string\n  required: true\n  description: Target domain\n- name: dns_server\n  type: string\n  required: false\n  description: DNS server to use\n  default: ''\n- name: wordlist\n  type: string\n  required: false\n  description: Wordlist for brute forcing\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional dnsenum arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "dnsenum_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass DnsenumHandler(AbstractHandler):\n    \"\"\"Handler for dnsenum functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute dnsenum with enhanced logging\"\"\"\n        try:\n            domain = data.get(\"domain\", \"\")\n            dns_server = data.get(\"dns_server\", \"\")\n            wordlist = data.get(\"wordlist\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not domain:\n                logger.warning(\"ðŸŒ DNSenum called without domain parameter\")\n                return {\n    \n                    \"error\": \"Domain parameter is required\"\n                \n                }\n            command = f\"dnsenum {domain}\"\n            if dns_server:\n                command += f\" --dnsserver {dns_server}\"\n            if wordlist:\n                command += f\" --file {wordlist}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting DNSenum: {domain}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š DNSenum completed for {domain}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in dnsenum endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182537
    },
    {
      "id": "network_scanning-rustscan_fast_scan",
      "name": "Rustscan Fast Scan",
      "description": "Execute Rustscan for ultra-fast port scanning with enhanced logging. target: The target IP address or hostname ports: Specific ports to scan (e.g., \"22,80,443\") ulimit: File descriptor limit batch_size: Batch size for scanning timeout: Timeout in milliseconds scripts: Run Nmap scripts on discovered ports additional_args: Additional Rustscan arguments",
      "license": "MIT",
      "content": "---\nname: rustscan_fast_scan\ncapabilities: ['target', 'ports', 'ulimit', 'batch-size', 'timeout', 'scripts', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'rustscan']\n---\n\n# Rustscan Fast Scan\n\nExecute Rustscan for ultra-fast port scanning with enhanced logging. target: The target IP address or hostname ports: Specific ports to scan (e.g., \"22,80,443\") ulimit: File descriptor limit batch_size: Batch size for scanning timeout: Timeout in milliseconds scripts: Run Nmap scripts on discovered ports additional_args: Additional Rustscan arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or hostname\n- **ports** (string, Optional): Specific ports to scan (e.g., \"22,80,443\")\n- **ulimit** (integer, Optional) (default: 5000): File descriptor limit\n- **batch_size** (integer, Optional) (default: 4500): Batch size for scanning\n- **timeout** (integer, Optional) (default: 1500): Timeout in milliseconds\n- **scripts** (boolean, Optional): Run Nmap scripts on discovered ports\n- **additional_args** (string, Optional): Additional Rustscan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/rustscan`\n\n**Returns:** Ultra-fast port scanning results\n\n## Files Included\n\n- `rustscan_fast_scan.yaml` - Tool configuration\n- `rustscan_fast_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: rustscan_fast_scan\ncapabilities: ['target', 'ports', 'ulimit', 'batch-size', 'timeout', 'scripts', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'rustscan']\n---\n\n# Rustscan Fast Scan\n\nExecute Rustscan for ultra-fast port scanning with enhanced logging. target: The target IP address or hostname ports: Specific ports to scan (e.g., \"22,80,443\") ulimit: File descriptor limit batch_size: Batch size for scanning timeout: Timeout in milliseconds scripts: Run Nmap scripts on discovered ports additional_args: Additional Rustscan arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or hostname\n- **ports** (string, Optional): Specific ports to scan (e.g., \"22,80,443\")\n- **ulimit** (integer, Optional) (default: 5000): File descriptor limit\n- **batch_size** (integer, Optional) (default: 4500): Batch size for scanning\n- **timeout** (integer, Optional) (default: 1500): Timeout in milliseconds\n- **scripts** (boolean, Optional): Run Nmap scripts on discovered ports\n- **additional_args** (string, Optional): Additional Rustscan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/rustscan`\n\n**Returns:** Ultra-fast port scanning results\n\n## Files Included\n\n- `rustscan_fast_scan.yaml` - Tool configuration\n- `rustscan_fast_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "rustscan_fast_scan.yaml",
          "content": "name: rustscan_fast_scan\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, rustscan]\nendpoint: api/tools/rustscan\ndescription: 'Execute Rustscan for ultra-fast port scanning with enhanced logging.\n  target: The target IP address or hostname ports: Specific ports to scan (e.g., \"22,80,443\")\n  ulimit: File descriptor limit batch_size: Batch size for scanning timeout: Timeout\n  in milliseconds scripts: Run Nmap scripts on discovered ports additional_args: Additional\n  Rustscan arguments'\nreturns: Ultra-fast port scanning results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address or hostname\n- name: ports\n  type: string\n  required: false\n  description: Specific ports to scan (e.g., \"22,80,443\")\n  default: ''\n- name: ulimit\n  type: integer\n  required: false\n  description: File descriptor limit\n  default: 5000\n- name: batch_size\n  type: integer\n  required: false\n  description: Batch size for scanning\n  default: 4500\n- name: timeout\n  type: integer\n  required: false\n  description: Timeout in milliseconds\n  default: 1500\n- name: scripts\n  type: boolean\n  required: false\n  description: Run Nmap scripts on discovered ports\n  default: false\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Rustscan arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "rustscan_fast_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass RustscanHandler(AbstractHandler):\n    \"\"\"Handler for rustscan functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute rustscan with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            ports = data.get(\"ports\", \"\")\n            ulimit = data.get(\"ulimit\", 5000)\n            batch_size = data.get(\"batch_size\", 4500)\n            timeout = data.get(\"timeout\", 1500)\n            scripts = data.get(\"scripts\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ Rustscan called without target parameter\")\n                return {\"error\": \"Target parameter is required\"}\n            command = f\"rustscan -a {target} --ulimit {ulimit} -b {batch_size} -t {timeout}\"\n            if ports:\n                command += f\" -p {ports}\"\n            if scripts:\n                command += f\" -- -sC -sV\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"âš¡ Starting Rustscan: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Rustscan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in rustscan endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182538
    },
    {
      "id": "web_application_scanning-feroxbuster_scan",
      "name": "Feroxbuster Scan",
      "description": "Execute Feroxbuster for recursive content discovery with enhanced logging. url: The target URL wordlist: Wordlist file to use threads: Number of threads additional_args: Additional Feroxbuster arguments",
      "license": "MIT",
      "content": "---\nname: feroxbuster_scan\ncapabilities: ['url', 'wordlist', 'threads', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'feroxbuster']\n---\n\n# Feroxbuster Scan\n\nExecute Feroxbuster for recursive content discovery with enhanced logging. url: The target URL wordlist: Wordlist file to use threads: Number of threads additional_args: Additional Feroxbuster arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Wordlist file to use\n- **threads** (integer, Optional) (default: 10): Number of threads\n- **additional_args** (string, Optional): Additional Feroxbuster arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/feroxbuster`\n\n**Returns:** Content discovery results\n\n## Files Included\n\n- `feroxbuster_scan.yaml` - Tool configuration\n- `feroxbuster_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: feroxbuster_scan\ncapabilities: ['url', 'wordlist', 'threads', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'feroxbuster']\n---\n\n# Feroxbuster Scan\n\nExecute Feroxbuster for recursive content discovery with enhanced logging. url: The target URL wordlist: Wordlist file to use threads: Number of threads additional_args: Additional Feroxbuster arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Wordlist file to use\n- **threads** (integer, Optional) (default: 10): Number of threads\n- **additional_args** (string, Optional): Additional Feroxbuster arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/feroxbuster`\n\n**Returns:** Content discovery results\n\n## Files Included\n\n- `feroxbuster_scan.yaml` - Tool configuration\n- `feroxbuster_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "feroxbuster_scan.yaml",
          "content": "name: feroxbuster_scan\ncategory: web_application_scanning\ntags: [network_scanning, vulnerability_assessment, penetration_testing, feroxbuster]\nendpoint: api/tools/feroxbuster\ndescription: 'Execute Feroxbuster for recursive content discovery with enhanced logging.\n  url: The target URL wordlist: Wordlist file to use threads: Number of threads additional_args:\n  Additional Feroxbuster arguments'\nreturns: Content discovery results\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL\n- name: wordlist\n  type: string\n  required: false\n  description: Wordlist file to use\n  default: /usr/share/wordlists/dirb/common.txt\n- name: threads\n  type: integer\n  required: false\n  description: Number of threads\n  default: 10\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Feroxbuster arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "feroxbuster_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass FeroxbusterHandler(AbstractHandler):\n    \"\"\"Handler for feroxbuster functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute feroxbuster with enhanced logging\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            wordlist = data.get(\"wordlist\", \"/usr/share/wordlists/dirb/common.txt\")\n            threads = data.get(\"threads\", 10)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not url:\n                logger.warning(\"ðŸŒ Feroxbuster called without URL parameter\")\n                return {\n    \n                    \"error\": \"URL parameter is required\"\n                \n                }\n            command = f\"feroxbuster -u {url} -w {wordlist} -t {threads}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Feroxbuster scan: {url}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Feroxbuster scan completed for {url}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in feroxbuster endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182539
    },
    {
      "id": "network_scanning-nc_connect",
      "name": "Nc Connect",
      "description": "Connect to a remote host and port using netcat (nc). Supports sending data and receiving responses. Ideal for CTF pwn challenges, port interaction, and network debugging.",
      "license": "MIT",
      "content": "---\nname: nc_connect\ncapabilities: ['host', 'port', 'data', 'timeout', 'udp']\ncategory: network_scanning\ntags: ['ctf', 'pwn', 'network', 'netcat']\n---\n\n# Nc Connect\n\nConnect to a remote host and port using netcat (nc). Supports sending data and receiving responses. Ideal for CTF pwn challenges, port interaction, and network debugging.\n\n## Parameters\n- **host** (string, Required): Target hostname or IP address\n- **port** (integer, Required): Target port number\n- **data** (string, Optional): Data to send after connecting\n- **timeout** (integer, Optional) (default: 10): Connection timeout in seconds\n- **udp** (boolean, Optional): Use UDP instead of TCP\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nc_connect`\n\n**Returns:** Connection output including sent and received data\n\n## Files Included\n\n- `nc_connect.yaml` - Tool configuration\n- `nc_connect.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: nc_connect\ncapabilities: ['host', 'port', 'data', 'timeout', 'udp']\ncategory: network_scanning\ntags: ['ctf', 'pwn', 'network', 'netcat']\n---\n\n# Nc Connect\n\nConnect to a remote host and port using netcat (nc). Supports sending data and receiving responses. Ideal for CTF pwn challenges, port interaction, and network debugging.\n\n## Parameters\n- **host** (string, Required): Target hostname or IP address\n- **port** (integer, Required): Target port number\n- **data** (string, Optional): Data to send after connecting\n- **timeout** (integer, Optional) (default: 10): Connection timeout in seconds\n- **udp** (boolean, Optional): Use UDP instead of TCP\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nc_connect`\n\n**Returns:** Connection output including sent and received data\n\n## Files Included\n\n- `nc_connect.yaml` - Tool configuration\n- `nc_connect.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "nc_connect.yaml",
          "content": "name: nc_connect\ncategory: network_scanning\ntags: [ctf, pwn, network, netcat]\nendpoint: api/tools/nc_connect\ndescription: 'Connect to a remote host and port using netcat (nc). Supports sending data and receiving responses. Ideal for CTF pwn challenges, port interaction, and network debugging.'\nreturns: Connection output including sent and received data\nparameters:\n- name: host\n  type: string\n  required: true\n  description: Target hostname or IP address\n- name: port\n  type: integer\n  required: true\n  description: Target port number\n- name: data\n  type: string\n  required: false\n  description: Data to send after connecting\n  default: ''\n- name: timeout\n  type: integer\n  required: false\n  description: Connection timeout in seconds\n  default: 10\n- name: udp\n  type: boolean\n  required: false\n  description: Use UDP instead of TCP\n  default: false\n",
          "language": "yaml"
        },
        {
          "name": "nc_connect.py",
          "content": "import logging\nfrom typing import Dict, Any\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass NcConnectHandler(AbstractHandler):\n    \"\"\"\n    Netcat connection handler.\n    Connects to remote hosts and ports, supports sending/receiving data.\n    Ideal for CTF pwn challenges and network interaction.\n    \"\"\"\n\n    def __init__(self, config: Dict):\n        super().__init__(config)\n\n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n\n    def handle(self, data: Dict) -> Any:\n        \"\"\"Connect to remote host using netcat\"\"\"\n        try:\n            host = data.get(\"host\", \"\")\n            port = data.get(\"port\", 0)\n            send_data = data.get(\"data\", \"\")\n            timeout = data.get(\"timeout\", 10)\n            udp = data.get(\"udp\", False)\n\n            if not host:\n                logger.warning(\"ðŸ”Œ nc_connect called without host\")\n                return {\"error\": \"Host parameter is required\"}\n\n            if not port:\n                logger.warning(\"ðŸ”Œ nc_connect called without port\")\n                return {\"error\": \"Port parameter is required\"}\n\n            # Build nc command\n            command = \"nc\"\n            \n            # Add verbose flag\n            command += \" -v\"\n            \n            # Add timeout\n            command += f\" -w {timeout}\"\n            \n            # Add UDP flag if needed\n            if udp:\n                command += \" -u\"\n            \n            # Add host and port\n            command += f\" {host} {port}\"\n\n            # If we have data to send, pipe it\n            if send_data:\n                # Escape special characters\n                escaped_data = send_data.replace(\"\\\\\", \"\\\\\\\\\").replace('\"', '\\\\\"').replace(\"$\", \"\\\\$\")\n                command = f'echo -e \"{escaped_data}\" | {command}'\n\n            logger.info(f\"ðŸ”Œ Connecting to {host}:{port} {'(UDP)' if udp else '(TCP)'}\")\n            result = execute_command(command, timeout=timeout + 5)\n\n            logger.info(f\"ðŸ“Š nc connection completed for {host}:{port}\")\n            result[\"host\"] = host\n            result[\"port\"] = port\n            result[\"protocol\"] = \"UDP\" if udp else \"TCP\"\n            return result\n\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in nc_connect: {str(e)}\")\n            return {\"error\": f\"Connection error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182541
    },
    {
      "id": "subdomain_enumeration-fierce_scan",
      "name": "Fierce Scan",
      "description": "Execute fierce for DNS reconnaissance with enhanced logging. domain: Target domain dns_server: DNS server to use additional_args: Additional fierce arguments",
      "license": "MIT",
      "content": "---\nname: fierce_scan\ncapabilities: ['domain', 'dns-server', 'additional-args']\ncategory: subdomain_enumeration\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'fierce']\n---\n\n# Fierce Scan\n\nExecute fierce for DNS reconnaissance with enhanced logging. domain: Target domain dns_server: DNS server to use additional_args: Additional fierce arguments\n\n## Parameters\n- **domain** (string, Required): Target domain\n- **dns_server** (string, Optional): DNS server to use\n- **additional_args** (string, Optional): Additional fierce arguments\n\n\n## Usage\n\nThis tool is part of the subdomain_enumeration category.\n\n**Endpoint:** `api/tools/fierce`\n\n**Returns:** DNS reconnaissance results\n\n## Files Included\n\n- `fierce_scan.yaml` - Tool configuration\n- `fierce_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: fierce_scan\ncapabilities: ['domain', 'dns-server', 'additional-args']\ncategory: subdomain_enumeration\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'fierce']\n---\n\n# Fierce Scan\n\nExecute fierce for DNS reconnaissance with enhanced logging. domain: Target domain dns_server: DNS server to use additional_args: Additional fierce arguments\n\n## Parameters\n- **domain** (string, Required): Target domain\n- **dns_server** (string, Optional): DNS server to use\n- **additional_args** (string, Optional): Additional fierce arguments\n\n\n## Usage\n\nThis tool is part of the subdomain_enumeration category.\n\n**Endpoint:** `api/tools/fierce`\n\n**Returns:** DNS reconnaissance results\n\n## Files Included\n\n- `fierce_scan.yaml` - Tool configuration\n- `fierce_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "fierce_scan.yaml",
          "content": "name: fierce_scan\ncategory: subdomain_enumeration\ntags: [network_scanning, vulnerability_assessment, penetration_testing, fierce]\nendpoint: api/tools/fierce\ndescription: 'Execute fierce for DNS reconnaissance with enhanced logging. domain:\n  Target domain dns_server: DNS server to use additional_args: Additional fierce arguments'\nreturns: DNS reconnaissance results\nparameters:\n- name: domain\n  type: string\n  required: true\n  description: Target domain\n- name: dns_server\n  type: string\n  required: false\n  description: DNS server to use\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional fierce arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "fierce_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass FierceHandler(AbstractHandler):\n    \"\"\"Handler for fierce functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute fierce with enhanced logging\"\"\"\n        try:\n            domain = data.get(\"domain\", \"\")\n            dns_server = data.get(\"dns_server\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not domain:\n                logger.warning(\"ðŸŒ Fierce called without domain parameter\")\n                return {\n    \n                    \"error\": \"Domain parameter is required\"\n                \n                }\n            command = f\"fierce --domain {domain}\"\n            if dns_server:\n                command += f\" --dns-servers {dns_server}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Fierce DNS recon: {domain}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Fierce completed for {domain}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in fierce endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182542
    },
    {
      "id": "network_scanning-enum4linux_ng_advanced",
      "name": "Enum4Linux Ng Advanced",
      "description": "Execute Enum4linux-ng for advanced SMB enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication shares: Enumerate shares users: Enumerate users groups: Enumerate groups policy: Enumerate policies additional_args: Additional Enum4linux-ng arguments",
      "license": "MIT",
      "content": "---\nname: enum4linux_ng_advanced\ncapabilities: ['target', 'username', 'password', 'domain', 'shares', 'users', 'groups', 'policy', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'enum4linux-ng', 'enum4linux']\n---\n\n# Enum4Linux Ng Advanced\n\nExecute Enum4linux-ng for advanced SMB enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication shares: Enumerate shares users: Enumerate users groups: Enumerate groups policy: Enumerate policies additional_args: Additional Enum4linux-ng arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **shares** (boolean, Optional) (default: True): Enumerate shares\n- **users** (boolean, Optional) (default: True): Enumerate users\n- **groups** (boolean, Optional) (default: True): Enumerate groups\n- **policy** (boolean, Optional) (default: True): Enumerate policies\n- **additional_args** (string, Optional): Additional Enum4linux-ng arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/enum4linux-ng`\n\n**Returns:** Advanced SMB enumeration results\n\n## Files Included\n\n- `enum4linux_ng_advanced.yaml` - Tool configuration\n- `enum4linux_ng_advanced.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: enum4linux_ng_advanced\ncapabilities: ['target', 'username', 'password', 'domain', 'shares', 'users', 'groups', 'policy', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'enum4linux-ng', 'enum4linux']\n---\n\n# Enum4Linux Ng Advanced\n\nExecute Enum4linux-ng for advanced SMB enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication shares: Enumerate shares users: Enumerate users groups: Enumerate groups policy: Enumerate policies additional_args: Additional Enum4linux-ng arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **shares** (boolean, Optional) (default: True): Enumerate shares\n- **users** (boolean, Optional) (default: True): Enumerate users\n- **groups** (boolean, Optional) (default: True): Enumerate groups\n- **policy** (boolean, Optional) (default: True): Enumerate policies\n- **additional_args** (string, Optional): Additional Enum4linux-ng arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/enum4linux-ng`\n\n**Returns:** Advanced SMB enumeration results\n\n## Files Included\n\n- `enum4linux_ng_advanced.yaml` - Tool configuration\n- `enum4linux_ng_advanced.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "enum4linux_ng_advanced.yaml",
          "content": "name: enum4linux_ng_advanced\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, enum4linux-ng, enum4linux]\nendpoint: api/tools/enum4linux-ng\ndescription: 'Execute Enum4linux-ng for advanced SMB enumeration with enhanced logging.\n  target: The target IP address username: Username for authentication password: Password\n  for authentication domain: Domain for authentication shares: Enumerate shares users:\n  Enumerate users groups: Enumerate groups policy: Enumerate policies additional_args:\n  Additional Enum4linux-ng arguments'\nreturns: Advanced SMB enumeration results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address\n- name: username\n  type: string\n  required: false\n  description: Username for authentication\n  default: ''\n- name: password\n  type: string\n  required: false\n  description: Password for authentication\n  default: ''\n- name: domain\n  type: string\n  required: false\n  description: Domain for authentication\n  default: ''\n- name: shares\n  type: boolean\n  required: false\n  description: Enumerate shares\n  default: true\n- name: users\n  type: boolean\n  required: false\n  description: Enumerate users\n  default: true\n- name: groups\n  type: boolean\n  required: false\n  description: Enumerate groups\n  default: true\n- name: policy\n  type: boolean\n  required: false\n  description: Enumerate policies\n  default: true\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Enum4linux-ng arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "enum4linux_ng_advanced.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass Enum4linuxNgHandler(AbstractHandler):\n    \"\"\"Handler for enum4linux_ng functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute enum4linux_ng with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            username = data.get(\"username\", \"\")\n            password = data.get(\"password\", \"\")\n            domain = data.get(\"domain\", \"\")\n            shares = data.get(\"shares\", True)\n            users = data.get(\"users\", True)\n            groups = data.get(\"groups\", True)\n            policy = data.get(\"policy\", True)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ Enum4linux-ng called without target parameter\")\n                return {\"error\": \"Target parameter is required\"}\n            command = f\"enum4linux-ng {target}\"\n            if username:\n                command += f\" -u {username}\"\n            if password:\n                command += f\" -p {password}\"\n            if domain:\n                command += f\" -d {domain}\"\n            enum_options = []\n            if shares:\n                enum_options.append(\"S\")\n            if users:\n                enum_options.append(\"U\")\n            if groups:\n                enum_options.append(\"G\")\n            if policy:\n                enum_options.append(\"P\")\n            if enum_options:\n                command += f\" -A {','.join(enum_options)}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Enum4linux-ng: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Enum4linux-ng completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in enum4linux-ng endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182543
    },
    {
      "id": "network_scanning-arp_scan_discovery",
      "name": "Arp Scan Discovery",
      "description": "Execute arp-scan for network discovery with enhanced logging. target: The target IP range (if not using local_network) interface: Network interface to use local_network: Scan local network timeout: Timeout in milliseconds retry: Number of retries additional_args: Additional arp-scan arguments",
      "license": "MIT",
      "content": "---\nname: arp_scan_discovery\ncapabilities: ['target', 'interface', 'local-network', 'timeout', 'retry', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'arp-scan']\n---\n\n# Arp Scan Discovery\n\nExecute arp-scan for network discovery with enhanced logging. target: The target IP range (if not using local_network) interface: Network interface to use local_network: Scan local network timeout: Timeout in milliseconds retry: Number of retries additional_args: Additional arp-scan arguments\n\n## Parameters\n- **target** (string, Optional): The target IP range (if not using local_network)\n- **interface** (string, Optional): Network interface to use\n- **local_network** (boolean, Optional): Scan local network\n- **timeout** (integer, Optional) (default: 500): Timeout in milliseconds\n- **retry** (integer, Optional) (default: 3): Number of retries\n- **additional_args** (string, Optional): Additional arp-scan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/arp-scan`\n\n**Returns:** Network discovery results via ARP scanning\n\n## Files Included\n\n- `arp_scan_discovery.yaml` - Tool configuration\n- `arp_scan_discovery.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: arp_scan_discovery\ncapabilities: ['target', 'interface', 'local-network', 'timeout', 'retry', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'arp-scan']\n---\n\n# Arp Scan Discovery\n\nExecute arp-scan for network discovery with enhanced logging. target: The target IP range (if not using local_network) interface: Network interface to use local_network: Scan local network timeout: Timeout in milliseconds retry: Number of retries additional_args: Additional arp-scan arguments\n\n## Parameters\n- **target** (string, Optional): The target IP range (if not using local_network)\n- **interface** (string, Optional): Network interface to use\n- **local_network** (boolean, Optional): Scan local network\n- **timeout** (integer, Optional) (default: 500): Timeout in milliseconds\n- **retry** (integer, Optional) (default: 3): Number of retries\n- **additional_args** (string, Optional): Additional arp-scan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/arp-scan`\n\n**Returns:** Network discovery results via ARP scanning\n\n## Files Included\n\n- `arp_scan_discovery.yaml` - Tool configuration\n- `arp_scan_discovery.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "arp_scan_discovery.yaml",
          "content": "name: arp_scan_discovery\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, arp-scan]\nendpoint: api/tools/arp-scan\ndescription: 'Execute arp-scan for network discovery with enhanced logging. target:\n  The target IP range (if not using local_network) interface: Network interface to\n  use local_network: Scan local network timeout: Timeout in milliseconds retry: Number\n  of retries additional_args: Additional arp-scan arguments'\nreturns: Network discovery results via ARP scanning\nparameters:\n- name: target\n  type: string\n  required: false\n  description: The target IP range (if not using local_network)\n  default: ''\n- name: interface\n  type: string\n  required: false\n  description: Network interface to use\n  default: ''\n- name: local_network\n  type: boolean\n  required: false\n  description: Scan local network\n  default: false\n- name: timeout\n  type: integer\n  required: false\n  description: Timeout in milliseconds\n  default: 500\n- name: retry\n  type: integer\n  required: false\n  description: Number of retries\n  default: 3\n- name: additional_args\n  type: string\n  required: false\n  description: Additional arp-scan arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "arp_scan_discovery.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import HandlerType, AbstractHandler\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass ArpScanHandler(AbstractHandler):\n    \"\"\"Handler for arp_scan functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute arp_scan with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            interface = data.get(\"interface\", \"\")\n            local_network = data.get(\"local_network\", False)\n            timeout = data.get(\"timeout\", 500)\n            retry = data.get(\"retry\", 3)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target and not local_network:\n                logger.warning(\"ðŸŽ¯ arp-scan called without target parameter\")\n                return {\"error\": \"Target parameter or local_network flag is required\"}\n            command = f\"arp-scan -t {timeout} -r {retry}\"\n            if interface:\n                command += f\" -I {interface}\"\n            if local_network:\n                command += \" -l\"\n            else:\n                command += f\" {target}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting arp-scan: {target if target else 'local network'}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š arp-scan completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in arp-scan endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182545
    },
    {
      "id": "network_scanning-enum4linux_scan",
      "name": "Enum4Linux Scan",
      "description": "Execute Enum4linux for SMB enumeration with enhanced logging. target: The target IP address additional_args: Additional Enum4linux arguments",
      "license": "MIT",
      "content": "---\nname: enum4linux_scan\ncapabilities: ['target', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'enum4linux']\n---\n\n# Enum4Linux Scan\n\nExecute Enum4linux for SMB enumeration with enhanced logging. target: The target IP address additional_args: Additional Enum4linux arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **additional_args** (string, Optional) (default: -a): Additional Enum4linux arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/enum4linux`\n\n**Returns:** SMB enumeration results\n\n## Files Included\n\n- `enum4linux_scan.yaml` - Tool configuration\n- `enum4linux_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: enum4linux_scan\ncapabilities: ['target', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'enum4linux']\n---\n\n# Enum4Linux Scan\n\nExecute Enum4linux for SMB enumeration with enhanced logging. target: The target IP address additional_args: Additional Enum4linux arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **additional_args** (string, Optional) (default: -a): Additional Enum4linux arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/enum4linux`\n\n**Returns:** SMB enumeration results\n\n## Files Included\n\n- `enum4linux_scan.yaml` - Tool configuration\n- `enum4linux_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "enum4linux_scan.yaml",
          "content": "name: enum4linux_scan\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, enum4linux]\nendpoint: api/tools/enum4linux\ndescription: 'Execute Enum4linux for SMB enumeration with enhanced logging. target:\n  The target IP address additional_args: Additional Enum4linux arguments'\nreturns: SMB enumeration results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Enum4linux arguments\n  default: -a\n",
          "language": "yaml"
        },
        {
          "name": "enum4linux_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass Enum4linuxHandler(AbstractHandler):\n    \"\"\"Handler for enum4linux functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute enum4linux with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            additional_args = data.get(\"additional_args\", \"-a\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ Enum4linux called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"enum4linux {additional_args} {target}\"\n            logger.info(f\"ðŸ” Starting Enum4linux: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Enum4linux completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in enum4linux endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182546
    },
    {
      "id": "network_scanning-nmap_advanced_scan",
      "name": "Nmap Advanced Scan",
      "description": "Execute advanced Nmap scans with custom NSE scripts and optimized timing. target: The target IP address or hostname scan_type: Nmap scan type (e.g., -sS, -sT, -sU) ports: Specific ports to scan timing: Timing template (T0-T5) nse_scripts: Custom NSE scripts to run os_detection: Enable OS detection version_detection: Enable version detection aggressive: Enable aggressive scanning stealth: Enable stealth mode additional_args: Additional Nmap arguments",
      "license": "MIT",
      "content": "---\nname: nmap_advanced_scan\ncapabilities: ['target', 'scan-type', 'ports', 'timing', 'nse-scripts', 'os-detection', 'version-detection', 'aggressive', 'stealth', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nmap']\n---\n\n# Nmap Advanced Scan\n\nExecute advanced Nmap scans with custom NSE scripts and optimized timing. target: The target IP address or hostname scan_type: Nmap scan type (e.g., -sS, -sT, -sU) ports: Specific ports to scan timing: Timing template (T0-T5) nse_scripts: Custom NSE scripts to run os_detection: Enable OS detection version_detection: Enable version detection aggressive: Enable aggressive scanning stealth: Enable stealth mode additional_args: Additional Nmap arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or hostname\n- **scan_type** (string, Optional) (default: -sS): Nmap scan type (e.g., -sS, -sT, -sU)\n- **ports** (string, Optional): Specific ports to scan\n- **timing** (string, Optional) (default: T4): Timing template (T0-T5)\n- **nse_scripts** (string, Optional): Custom NSE scripts to run\n- **os_detection** (boolean, Optional): Enable OS detection\n- **version_detection** (boolean, Optional): Enable version detection\n- **aggressive** (boolean, Optional): Enable aggressive scanning\n- **stealth** (boolean, Optional): Enable stealth mode\n- **additional_args** (string, Optional): Additional Nmap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nmap-advanced`\n\n**Returns:** Advanced Nmap scanning results with custom NSE scripts\n\n## Files Included\n\n- `nmap_advanced_scan.yaml` - Tool configuration\n- `nmap_advanced_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: nmap_advanced_scan\ncapabilities: ['target', 'scan-type', 'ports', 'timing', 'nse-scripts', 'os-detection', 'version-detection', 'aggressive', 'stealth', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nmap']\n---\n\n# Nmap Advanced Scan\n\nExecute advanced Nmap scans with custom NSE scripts and optimized timing. target: The target IP address or hostname scan_type: Nmap scan type (e.g., -sS, -sT, -sU) ports: Specific ports to scan timing: Timing template (T0-T5) nse_scripts: Custom NSE scripts to run os_detection: Enable OS detection version_detection: Enable version detection aggressive: Enable aggressive scanning stealth: Enable stealth mode additional_args: Additional Nmap arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or hostname\n- **scan_type** (string, Optional) (default: -sS): Nmap scan type (e.g., -sS, -sT, -sU)\n- **ports** (string, Optional): Specific ports to scan\n- **timing** (string, Optional) (default: T4): Timing template (T0-T5)\n- **nse_scripts** (string, Optional): Custom NSE scripts to run\n- **os_detection** (boolean, Optional): Enable OS detection\n- **version_detection** (boolean, Optional): Enable version detection\n- **aggressive** (boolean, Optional): Enable aggressive scanning\n- **stealth** (boolean, Optional): Enable stealth mode\n- **additional_args** (string, Optional): Additional Nmap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nmap-advanced`\n\n**Returns:** Advanced Nmap scanning results with custom NSE scripts\n\n## Files Included\n\n- `nmap_advanced_scan.yaml` - Tool configuration\n- `nmap_advanced_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "nmap_advanced_scan.yaml",
          "content": "name: nmap_advanced_scan\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, nmap]\nendpoint: api/tools/nmap-advanced\ndescription: 'Execute advanced Nmap scans with custom NSE scripts and optimized timing.\n  target: The target IP address or hostname scan_type: Nmap scan type (e.g., -sS,\n  -sT, -sU) ports: Specific ports to scan timing: Timing template (T0-T5) nse_scripts:\n  Custom NSE scripts to run os_detection: Enable OS detection version_detection: Enable\n  version detection aggressive: Enable aggressive scanning stealth: Enable stealth\n  mode additional_args: Additional Nmap arguments'\nreturns: Advanced Nmap scanning results with custom NSE scripts\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address or hostname\n- name: scan_type\n  type: string\n  required: false\n  description: Nmap scan type (e.g., -sS, -sT, -sU)\n  default: -sS\n- name: ports\n  type: string\n  required: false\n  description: Specific ports to scan\n  default: ''\n- name: timing\n  type: string\n  required: false\n  description: Timing template (T0-T5)\n  default: T4\n- name: nse_scripts\n  type: string\n  required: false\n  description: Custom NSE scripts to run\n  default: ''\n- name: os_detection\n  type: boolean\n  required: false\n  description: Enable OS detection\n  default: false\n- name: version_detection\n  type: boolean\n  required: false\n  description: Enable version detection\n  default: false\n- name: aggressive\n  type: boolean\n  required: false\n  description: Enable aggressive scanning\n  default: false\n- name: stealth\n  type: boolean\n  required: false\n  description: Enable stealth mode\n  default: false\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Nmap arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "nmap_advanced_scan.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass NmapAdvancedHandler(AbstractHandler):\n    \"\"\"Handler for nmap_advanced functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute nmap_advanced with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            scan_type = data.get(\"scan_type\", \"-sS\")\n            ports = data.get(\"ports\", \"\")\n            timing = data.get(\"timing\", \"T4\")\n            nse_scripts = data.get(\"nse_scripts\", \"\")\n            os_detection = data.get(\"os_detection\", False)\n            version_detection = data.get(\"version_detection\", False)\n            aggressive = data.get(\"aggressive\", False)\n            stealth = data.get(\"stealth\", False)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ Advanced Nmap called without target parameter\")\n                return {\"error\": \"Target parameter is required\"}\n            command = f\"nmap {scan_type} {target}\"\n            if ports:\n                command += f\" -p {ports}\"\n            if stealth:\n                command += \" -T2 -f --mtu 24\"\n            else:\n                command += f\" -{timing}\"\n            if os_detection:\n                command += \" -O\"\n            if version_detection:\n                command += \" -sV\"\n            if aggressive:\n                command += \" -A\"\n            if nse_scripts:\n                command += f\" --script={nse_scripts}\"\n            elif not aggressive:\n                command += \" --script=default,discovery,safe\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Advanced Nmap: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Advanced Nmap completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in advanced nmap endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182548
    },
    {
      "id": "web_application_scanning-dirsearch_scan",
      "name": "Dirsearch Scan",
      "description": "Execute Dirsearch for advanced directory and file discovery with enhanced logging. url: The target URL extensions: File extensions to search for wordlist: Wordlist file to use threads: Number of threads to use recursive: Enable recursive scanning additional_args: Additional Dirsearch arguments",
      "license": "MIT",
      "content": "---\nname: dirsearch_scan\ncapabilities: ['url', 'extensions', 'wordlist', 'threads', 'recursive', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dirsearch']\n---\n\n# Dirsearch Scan\n\nExecute Dirsearch for advanced directory and file discovery with enhanced logging. url: The target URL extensions: File extensions to search for wordlist: Wordlist file to use threads: Number of threads to use recursive: Enable recursive scanning additional_args: Additional Dirsearch arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **extensions** (string, Optional) (default: php,html,js,txt,xml,json): File extensions to search for\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirsearch/common.txt): Wordlist file to use\n- **threads** (integer, Optional) (default: 30): Number of threads to use\n- **recursive** (boolean, Optional): Enable recursive scanning\n- **additional_args** (string, Optional): Additional Dirsearch arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/dirsearch`\n\n**Returns:** Advanced directory discovery results\n\n## Files Included\n\n- `dirsearch_scan.yaml` - Tool configuration\n- `dirsearch_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: dirsearch_scan\ncapabilities: ['url', 'extensions', 'wordlist', 'threads', 'recursive', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dirsearch']\n---\n\n# Dirsearch Scan\n\nExecute Dirsearch for advanced directory and file discovery with enhanced logging. url: The target URL extensions: File extensions to search for wordlist: Wordlist file to use threads: Number of threads to use recursive: Enable recursive scanning additional_args: Additional Dirsearch arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **extensions** (string, Optional) (default: php,html,js,txt,xml,json): File extensions to search for\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirsearch/common.txt): Wordlist file to use\n- **threads** (integer, Optional) (default: 30): Number of threads to use\n- **recursive** (boolean, Optional): Enable recursive scanning\n- **additional_args** (string, Optional): Additional Dirsearch arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/dirsearch`\n\n**Returns:** Advanced directory discovery results\n\n## Files Included\n\n- `dirsearch_scan.yaml` - Tool configuration\n- `dirsearch_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "dirsearch_scan.yaml",
          "content": "name: dirsearch_scan\ncategory: web_application_scanning\ntags: [network_scanning, vulnerability_assessment, penetration_testing, dirsearch]\nendpoint: api/tools/dirsearch\ndescription: 'Execute Dirsearch for advanced directory and file discovery with enhanced\n  logging. url: The target URL extensions: File extensions to search for wordlist:\n  Wordlist file to use threads: Number of threads to use recursive: Enable recursive\n  scanning additional_args: Additional Dirsearch arguments'\nreturns: Advanced directory discovery results\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL\n- name: extensions\n  type: string\n  required: false\n  description: File extensions to search for\n  default: php,html,js,txt,xml,json\n- name: wordlist\n  type: string\n  required: false\n  description: Wordlist file to use\n  default: /usr/share/wordlists/dirsearch/common.txt\n- name: threads\n  type: integer\n  required: false\n  description: Number of threads to use\n  default: 30\n- name: recursive\n  type: boolean\n  required: false\n  description: Enable recursive scanning\n  default: false\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Dirsearch arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "dirsearch_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass DirsearchHandler(AbstractHandler):\n    \"\"\"Handler for dirsearch functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute dirsearch with enhanced logging\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            extensions = data.get(\"extensions\", \"php,html,js,txt,xml,json\")\n            wordlist = data.get(\"wordlist\", \"/usr/share/wordlists/dirsearch/common.txt\")\n            threads = data.get(\"threads\", 30)\n            recursive = data.get(\"recursive\", False)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not url:\n                logger.warning(\"ðŸŒ Dirsearch called without URL parameter\")\n                return {\"error\": \"URL parameter is required\"}\n            command = f\"dirsearch -u {url} -e {extensions} -w {wordlist} -t {threads}\"\n            if recursive:\n                command += \" -r\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ“ Starting Dirsearch scan: {url}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Dirsearch scan completed for {url}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in dirsearch endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182549
    },
    {
      "id": "password_cracking-hashcat_crack",
      "name": "Hashcat Crack",
      "description": "Execute Hashcat for advanced password cracking with enhanced logging. hash_file: File containing password hashes hash_type: Hash type number for Hashcat attack_mode: Attack mode (0=dict, 1=combo, 3=mask, etc.) wordlist: Wordlist file for dictionary attacks mask: Mask for mask attacks additional_args: Additional Hashcat arguments",
      "license": "MIT",
      "content": "---\nname: hashcat_crack\ncapabilities: ['hash-file', 'hash-type', 'attack-mode', 'wordlist', 'mask', 'additional-args']\ncategory: password_cracking\ntags: ['credential_testing', 'vulnerability_assessment', 'penetration_testing', 'hashcat']\n---\n\n# Hashcat Crack\n\nExecute Hashcat for advanced password cracking with enhanced logging. hash_file: File containing password hashes hash_type: Hash type number for Hashcat attack_mode: Attack mode (0=dict, 1=combo, 3=mask, etc.) wordlist: Wordlist file for dictionary attacks mask: Mask for mask attacks additional_args: Additional Hashcat arguments\n\n## Parameters\n- **hash_file** (string, Required): File containing password hashes\n- **hash_type** (string, Required): Hash type number for Hashcat\n- **attack_mode** (string, Optional) (default: 0): Attack mode (0=dict, 1=combo, 3=mask, etc.)\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/rockyou.txt): Wordlist file for dictionary attacks\n- **mask** (string, Optional): Mask for mask attacks\n- **additional_args** (string, Optional): Additional Hashcat arguments\n\n\n## Usage\n\nThis tool is part of the password_cracking category.\n\n**Endpoint:** `api/tools/hashcat`\n\n**Returns:** Password cracking results\n\n## Files Included\n\n- `hashcat_crack.yaml` - Tool configuration\n- `hashcat_crack.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: hashcat_crack\ncapabilities: ['hash-file', 'hash-type', 'attack-mode', 'wordlist', 'mask', 'additional-args']\ncategory: password_cracking\ntags: ['credential_testing', 'vulnerability_assessment', 'penetration_testing', 'hashcat']\n---\n\n# Hashcat Crack\n\nExecute Hashcat for advanced password cracking with enhanced logging. hash_file: File containing password hashes hash_type: Hash type number for Hashcat attack_mode: Attack mode (0=dict, 1=combo, 3=mask, etc.) wordlist: Wordlist file for dictionary attacks mask: Mask for mask attacks additional_args: Additional Hashcat arguments\n\n## Parameters\n- **hash_file** (string, Required): File containing password hashes\n- **hash_type** (string, Required): Hash type number for Hashcat\n- **attack_mode** (string, Optional) (default: 0): Attack mode (0=dict, 1=combo, 3=mask, etc.)\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/rockyou.txt): Wordlist file for dictionary attacks\n- **mask** (string, Optional): Mask for mask attacks\n- **additional_args** (string, Optional): Additional Hashcat arguments\n\n\n## Usage\n\nThis tool is part of the password_cracking category.\n\n**Endpoint:** `api/tools/hashcat`\n\n**Returns:** Password cracking results\n\n## Files Included\n\n- `hashcat_crack.yaml` - Tool configuration\n- `hashcat_crack.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "hashcat_crack.yaml",
          "content": "name: hashcat_crack\ntags: [credential_testing, vulnerability_assessment, penetration_testing, hashcat]\ncategory: password_cracking\nendpoint: api/tools/hashcat\ndescription: 'Execute Hashcat for advanced password cracking with enhanced logging.\n  hash_file: File containing password hashes hash_type: Hash type number for Hashcat\n  attack_mode: Attack mode (0=dict, 1=combo, 3=mask, etc.) wordlist: Wordlist file\n  for dictionary attacks mask: Mask for mask attacks additional_args: Additional Hashcat\n  arguments'\nreturns: Password cracking results\nparameters:\n- name: hash_file\n  type: string\n  required: true\n  description: File containing password hashes\n- name: hash_type\n  type: string\n  required: true\n  description: Hash type number for Hashcat\n- name: attack_mode\n  type: string\n  required: false\n  description: Attack mode (0=dict, 1=combo, 3=mask, etc.)\n  default: '0'\n- name: wordlist\n  type: string\n  required: false\n  description: Wordlist file for dictionary attacks\n  default: /usr/share/wordlists/rockyou.txt\n- name: mask\n  type: string\n  required: false\n  description: Mask for mask attacks\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Hashcat arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "hashcat_crack.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass HashcatHandler(AbstractHandler):\n    \"\"\"Handler for hashcat functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute hashcat with enhanced logging\"\"\"\n        try:\n            hash_file = data.get(\"hash_file\", \"\")\n            hash_type = data.get(\"hash_type\", \"\")\n            attack_mode = data.get(\"attack_mode\", \"0\")\n            wordlist = data.get(\"wordlist\", \"/usr/share/wordlists/rockyou.txt\")\n            mask = data.get(\"mask\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not hash_file:\n                logger.warning(\"ðŸ” Hashcat called without hash_file parameter\")\n                return {\n                    \"error\": \"Hash file parameter is required\"\n                }\n            if not hash_type:\n                logger.warning(\"ðŸ” Hashcat called without hash_type parameter\")\n                return {\n    \n                    \"error\": \"Hash type parameter is required\"\n                \n                }\n            command = f\"hashcat -m {hash_type} -a {attack_mode} {hash_file}\"\n            if attack_mode == \"0\" and wordlist:\n                command += f\" {wordlist}\"\n            elif attack_mode == \"3\" and mask:\n                command += f\" {mask}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Hashcat attack: mode {attack_mode}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Hashcat attack completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in hashcat endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182551
    },
    {
      "id": "credential_testing-hydra_attack",
      "name": "Hydra Attack",
      "description": "Execute Hydra for password brute forcing with enhanced logging. target: The target IP or hostname service: The service to attack (ssh, ftp, http, etc.) username: Single username to test username_file: File containing usernames password: Single password to test password_file: File containing passwords additional_args: Additional Hydra arguments",
      "license": "MIT",
      "content": "---\nname: hydra_attack\ncapabilities: ['target', 'service', 'username', 'username-file', 'password', 'password-file', 'additional-args']\ncategory: credential_testing\ntags: ['vulnerability_assessment', 'penetration_testing', 'hydra']\n---\n\n# Hydra Attack\n\nExecute Hydra for password brute forcing with enhanced logging. target: The target IP or hostname service: The service to attack (ssh, ftp, http, etc.) username: Single username to test username_file: File containing usernames password: Single password to test password_file: File containing passwords additional_args: Additional Hydra arguments\n\n## Parameters\n- **target** (string, Required): The target IP or hostname\n- **service** (string, Required): The service to attack (ssh, ftp, http, etc.)\n- **username** (string, Optional): Single username to test\n- **username_file** (string, Optional): File containing usernames\n- **password** (string, Optional): Single password to test\n- **password_file** (string, Optional): File containing passwords\n- **additional_args** (string, Optional): Additional Hydra arguments\n\n\n## Usage\n\nThis tool is part of the credential_testing category.\n\n**Endpoint:** `api/tools/hydra`\n\n**Returns:** Brute force attack results\n\n## Files Included\n\n- `hydra_attack.yaml` - Tool configuration\n- `hydra_attack.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: hydra_attack\ncapabilities: ['target', 'service', 'username', 'username-file', 'password', 'password-file', 'additional-args']\ncategory: credential_testing\ntags: ['vulnerability_assessment', 'penetration_testing', 'hydra']\n---\n\n# Hydra Attack\n\nExecute Hydra for password brute forcing with enhanced logging. target: The target IP or hostname service: The service to attack (ssh, ftp, http, etc.) username: Single username to test username_file: File containing usernames password: Single password to test password_file: File containing passwords additional_args: Additional Hydra arguments\n\n## Parameters\n- **target** (string, Required): The target IP or hostname\n- **service** (string, Required): The service to attack (ssh, ftp, http, etc.)\n- **username** (string, Optional): Single username to test\n- **username_file** (string, Optional): File containing usernames\n- **password** (string, Optional): Single password to test\n- **password_file** (string, Optional): File containing passwords\n- **additional_args** (string, Optional): Additional Hydra arguments\n\n\n## Usage\n\nThis tool is part of the credential_testing category.\n\n**Endpoint:** `api/tools/hydra`\n\n**Returns:** Brute force attack results\n\n## Files Included\n\n- `hydra_attack.yaml` - Tool configuration\n- `hydra_attack.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "hydra_attack.yaml",
          "content": "name: hydra_attack\ntags: [vulnerability_assessment, penetration_testing, hydra]\ncategory: credential_testing\nendpoint: api/tools/hydra\ndescription: 'Execute Hydra for password brute forcing with enhanced logging. target:\n  The target IP or hostname service: The service to attack (ssh, ftp, http, etc.)\n  username: Single username to test username_file: File containing usernames password:\n  Single password to test password_file: File containing passwords additional_args:\n  Additional Hydra arguments'\nreturns: Brute force attack results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP or hostname\n- name: service\n  type: string\n  required: true\n  description: The service to attack (ssh, ftp, http, etc.)\n- name: username\n  type: string\n  required: false\n  description: Single username to test\n  default: ''\n- name: username_file\n  type: string\n  required: false\n  description: File containing usernames\n  default: ''\n- name: password\n  type: string\n  required: false\n  description: Single password to test\n  default: ''\n- name: password_file\n  type: string\n  required: false\n  description: File containing passwords\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Hydra arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "hydra_attack.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass HydraHandler(AbstractHandler):\n    \"\"\"Handler for hydra functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute hydra with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            service = data.get(\"service\", \"\")\n            username = data.get(\"username\", \"\")\n            username_file = data.get(\"username_file\", \"\")\n            password = data.get(\"password\", \"\")\n            password_file = data.get(\"password_file\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target or not service:\n                logger.warning(\"ðŸŽ¯ Hydra called without target or service parameter\")\n                return {\n    \n                    \"error\": \"Target and service parameters are required\"\n                \n                }\n            if not (username or username_file) or not (password or password_file):\n                logger.warning(\"ðŸ”‘ Hydra called without username/password parameters\")\n                return {\n    \n                    \"error\": \"Username/username_file and password/password_file are required\"\n                \n                }\n            command = f\"hydra -t 4\"\n            if username:\n                command += f\" -l {username}\"\n            elif username_file:\n                command += f\" -L {username_file}\"\n            if password:\n                command += f\" -p {password}\"\n            elif password_file:\n                command += f\" -P {password_file}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {target} {service}\"\n            logger.info(f\"ðŸ”‘ Starting Hydra attack: {target}:{service}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Hydra attack completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in hydra endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182553
    },
    {
      "id": "authentication_bypass-jwt_analyzer",
      "name": "Jwt Analyzer",
      "description": "Advanced JWT token analysis and vulnerability testing. jwt_token: JWT token to analyze target_url: Optional target URL for testing token manipulation",
      "license": "MIT",
      "content": "---\nname: jwt_analyzer\ncapabilities: ['jwt-token', 'target-url']\ncategory: authentication_bypass\ntags: ['credential_testing', 'vulnerability_assessment', 'penetration_testing']\n---\n\n# Jwt Analyzer\n\nAdvanced JWT token analysis and vulnerability testing. jwt_token: JWT token to analyze target_url: Optional target URL for testing token manipulation\n\n## Parameters\n- **jwt_token** (string, Required): JWT token to analyze\n- **target_url** (string, Optional): Optional target URL for testing token manipulation\n\n\n## Usage\n\nThis tool is part of the authentication_bypass category.\n\n**Endpoint:** `api/tools/jwt_analyzer`\n\n**Returns:** JWT analysis results with vulnerability assessment and attack vectors\n\n## Files Included\n\n- `jwt_analyzer.yaml` - Tool configuration\n- `jwt_analyzer.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: jwt_analyzer\ncapabilities: ['jwt-token', 'target-url']\ncategory: authentication_bypass\ntags: ['credential_testing', 'vulnerability_assessment', 'penetration_testing']\n---\n\n# Jwt Analyzer\n\nAdvanced JWT token analysis and vulnerability testing. jwt_token: JWT token to analyze target_url: Optional target URL for testing token manipulation\n\n## Parameters\n- **jwt_token** (string, Required): JWT token to analyze\n- **target_url** (string, Optional): Optional target URL for testing token manipulation\n\n\n## Usage\n\nThis tool is part of the authentication_bypass category.\n\n**Endpoint:** `api/tools/jwt_analyzer`\n\n**Returns:** JWT analysis results with vulnerability assessment and attack vectors\n\n## Files Included\n\n- `jwt_analyzer.yaml` - Tool configuration\n- `jwt_analyzer.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "jwt_analyzer.yaml",
          "content": "name: jwt_analyzer\ntags: [credential_testing, vulnerability_assessment, penetration_testing]\ncategory: authentication_bypass\nendpoint: api/tools/jwt_analyzer\ndescription: 'Advanced JWT token analysis and vulnerability testing. jwt_token: JWT\n  token to analyze target_url: Optional target URL for testing token manipulation'\nreturns: JWT analysis results with vulnerability assessment and attack vectors\nparameters:\n- name: jwt_token\n  type: string\n  required: true\n  description: JWT token to analyze\n- name: target_url\n  type: string\n  required: false\n  description: Optional target URL for testing token manipulation\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "jwt_analyzer.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass JwtAnalyzerHandler(AbstractHandler):\n    \"\"\"Handler for jwt_analyzer functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute jwt_analyzer with enhanced logging\"\"\"\n        try:\n            jwt_token = data.get(\"jwt_token\", \"\")\n            target_url = data.get(\"target_url\", \"\")\n            if not jwt_token:\n                logger.warning(\"ðŸ” JWT Analyzer called without jwt_token parameter\")\n                return {\n    \n                    \"error\": \"JWT token parameter is required\"\n                \n                }\n            logger.info(f\"ðŸ” Starting JWT security analysis\")\n            results = {\n                \"token\": jwt_token[:50] + \"...\" if len(jwt_token) > 50 else jwt_token,\n                \"vulnerabilities\": [],\n                \"token_info\": {},\n                \"attack_vectors\": []\n            }\n            try:\n                parts = jwt_token.split('.')\n                if len(parts) >= 2:\n                    import base64\n                    import json\n                    header_b64 = parts[0] + '=' * (4 - len(parts[0]) % 4)\n                    payload_b64 = parts[1] + '=' * (4 - len(parts[1]) % 4)\n                    try:\n                        header = json.loads(base64.b64decode(header_b64))\n                        payload = json.loads(base64.b64decode(payload_b64))\n                        results[\"token_info\"] = {\n                            \"header\": header,\n                            \"payload\": payload,\n                            \"algorithm\": header.get(\"alg\", \"unknown\")\n                        }\n                        algorithm = header.get(\"alg\", \"\").lower()\n                        if algorithm == \"none\":\n                            results[\"vulnerabilities\"].append({\n                                \"type\": \"none_algorithm\",\n                                \"severity\": \"CRITICAL\",\n                                \"description\": \"JWT uses 'none' algorithm - no signature verification\"\n                            })\n                        if algorithm in [\"hs256\", \"hs384\", \"hs512\"]:\n                            results[\"attack_vectors\"].append(\"hmac_key_confusion\")\n                            results[\"vulnerabilities\"].append({\n                                \"type\": \"hmac_algorithm\",\n                                \"severity\": \"MEDIUM\",\n                                \"description\": \"HMAC algorithm detected - vulnerable to key confusion attacks\"\n                            })\n                        exp = payload.get(\"exp\")\n                        if not exp:\n                            results[\"vulnerabilities\"].append({\n                                \"type\": \"no_expiration\",\n                                \"severity\": \"HIGH\",\n                                \"description\": \"JWT token has no expiration time\"\n                            })\n                    except Exception as decode_error:\n                        results[\"vulnerabilities\"].append({\n                            \"type\": \"malformed_token\",\n                            \"severity\": \"HIGH\",\n                            \"description\": f\"Token decoding failed: {str(decode_error)}\"\n                        })\n            except Exception as e:\n                results[\"vulnerabilities\"].append({\n                    \"type\": \"invalid_format\",\n                    \"severity\": \"HIGH\",\n                    \"description\": \"Invalid JWT token format\"\n                })\n            if target_url:\n                none_token_parts = jwt_token.split('.')\n                if len(none_token_parts) >= 2:\n                    none_header = base64.b64encode('{\"alg\":\"none\",\"typ\":\"JWT\"}'.encode()).decode().rstrip('=')\n                    none_token = f\"{none_header}.{none_token_parts[1]}.\"\n                    command = f\"curl -s -H 'Authorization: Bearer {none_token}' '{target_url}'\"\n                    none_result = execute_command(command, use_cache=False)\n                    if \"200\" in none_result.get(\"stdout\", \"\") or \"success\" in none_result.get(\"stdout\", \"\").lower():\n                        results[\"vulnerabilities\"].append({\n                            \"type\": \"none_algorithm_accepted\",\n                            \"severity\": \"CRITICAL\",\n                            \"description\": \"Server accepts tokens with 'none' algorithm\"\n                        })\n            logger.info(f\"ðŸ“Š JWT analysis completed | Vulnerabilities found: {len(results['vulnerabilities'])}\")\n            return {\n    \n                \"success\": True,\n                \"jwt_analysis_results\": results\n            \n            }\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in JWT analyzer: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182554
    },
    {
      "id": "password_cracking-john_crack",
      "name": "John Crack",
      "description": "Execute John the Ripper for password cracking with enhanced logging. hash_file: File containing password hashes wordlist: Wordlist file to use format_type: Hash format type additional_args: Additional John arguments",
      "license": "MIT",
      "content": "---\nname: john_crack\ncapabilities: ['hash-file', 'wordlist', 'format-type', 'additional-args']\ncategory: password_cracking\ntags: ['credential_testing', 'vulnerability_assessment', 'penetration_testing', 'john']\n---\n\n# John Crack\n\nExecute John the Ripper for password cracking with enhanced logging. hash_file: File containing password hashes wordlist: Wordlist file to use format_type: Hash format type additional_args: Additional John arguments\n\n## Parameters\n- **hash_file** (string, Required): File containing password hashes\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/rockyou.txt): Wordlist file to use\n- **format_type** (string, Optional): Hash format type\n- **additional_args** (string, Optional): Additional John arguments\n\n\n## Usage\n\nThis tool is part of the password_cracking category.\n\n**Endpoint:** `api/tools/john`\n\n**Returns:** Password cracking results\n\n## Files Included\n\n- `john_crack.yaml` - Tool configuration\n- `john_crack.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: john_crack\ncapabilities: ['hash-file', 'wordlist', 'format-type', 'additional-args']\ncategory: password_cracking\ntags: ['credential_testing', 'vulnerability_assessment', 'penetration_testing', 'john']\n---\n\n# John Crack\n\nExecute John the Ripper for password cracking with enhanced logging. hash_file: File containing password hashes wordlist: Wordlist file to use format_type: Hash format type additional_args: Additional John arguments\n\n## Parameters\n- **hash_file** (string, Required): File containing password hashes\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/rockyou.txt): Wordlist file to use\n- **format_type** (string, Optional): Hash format type\n- **additional_args** (string, Optional): Additional John arguments\n\n\n## Usage\n\nThis tool is part of the password_cracking category.\n\n**Endpoint:** `api/tools/john`\n\n**Returns:** Password cracking results\n\n## Files Included\n\n- `john_crack.yaml` - Tool configuration\n- `john_crack.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "john_crack.yaml",
          "content": "name: john_crack\ntags: [credential_testing, vulnerability_assessment, penetration_testing, john]\ncategory: password_cracking\nendpoint: api/tools/john\ndescription: 'Execute John the Ripper for password cracking with enhanced logging.\n  hash_file: File containing password hashes wordlist: Wordlist file to use format_type:\n  Hash format type additional_args: Additional John arguments'\nreturns: Password cracking results\nparameters:\n- name: hash_file\n  type: string\n  required: true\n  description: File containing password hashes\n- name: wordlist\n  type: string\n  required: false\n  description: Wordlist file to use\n  default: /usr/share/wordlists/rockyou.txt\n- name: format_type\n  type: string\n  required: false\n  description: Hash format type\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional John arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "john_crack.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass JohnHandler(AbstractHandler):\n    \"\"\"Handler for john functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute john with enhanced logging\"\"\"\n        try:\n            hash_file = data.get(\"hash_file\", \"\")\n            wordlist = data.get(\"wordlist\", \"/usr/share/wordlists/rockyou.txt\")\n            format_type = data.get(\"format\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not hash_file:\n                logger.warning(\"ðŸ” John called without hash_file parameter\")\n                return {\n    \n                    \"error\": \"Hash file parameter is required\"\n                \n                }\n            command = f\"john\"\n            if format_type:\n                command += f\" --format={format_type}\"\n            if wordlist:\n                command += f\" --wordlist={wordlist}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {hash_file}\"\n            logger.info(f\"ðŸ” Starting John the Ripper: {hash_file}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š John the Ripper completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in john endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182555
    },
    {
      "id": "web_security-curl_request",
      "name": "Curl Request",
      "description": "Execute HTTP requests using curl. Supports GET, POST, PUT, DELETE methods with custom headers and data. Ideal for CTF web challenges, API testing, and HTTP debugging.",
      "license": "MIT",
      "content": "---\nname: curl_request\ncapabilities: ['url', 'method', 'headers', 'data', 'timeout', 'follow-redirects', 'verbose']\ncategory: web_security\ntags: ['ctf', 'http', 'web', 'request']\n---\n\n# Curl Request\n\nExecute HTTP requests using curl. Supports GET, POST, PUT, DELETE methods with custom headers and data. Ideal for CTF web challenges, API testing, and HTTP debugging.\n\n## Parameters\n- **url** (string, Required): The target URL to send the request to\n- **method** (string, Optional) (default: GET): HTTP method (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)\n- **headers** (string, Optional): Custom headers in format \"Header1:Value1,Header2:Value2\"\n- **data** (string, Optional): Request body data (for POST, PUT, PATCH)\n- **timeout** (integer, Optional) (default: 30): Request timeout in seconds\n- **follow_redirects** (boolean, Optional) (default: True): Whether to follow HTTP redirects\n- **verbose** (boolean, Optional): Enable verbose output showing request/response headers\n\n\n## Usage\n\nThis tool is part of the web_security category.\n\n**Endpoint:** `api/tools/curl_request`\n\n**Returns:** HTTP response including status code, headers, and body\n\n## Files Included\n\n- `curl_request.yaml` - Tool configuration\n- `curl_request.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: curl_request\ncapabilities: ['url', 'method', 'headers', 'data', 'timeout', 'follow-redirects', 'verbose']\ncategory: web_security\ntags: ['ctf', 'http', 'web', 'request']\n---\n\n# Curl Request\n\nExecute HTTP requests using curl. Supports GET, POST, PUT, DELETE methods with custom headers and data. Ideal for CTF web challenges, API testing, and HTTP debugging.\n\n## Parameters\n- **url** (string, Required): The target URL to send the request to\n- **method** (string, Optional) (default: GET): HTTP method (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)\n- **headers** (string, Optional): Custom headers in format \"Header1:Value1,Header2:Value2\"\n- **data** (string, Optional): Request body data (for POST, PUT, PATCH)\n- **timeout** (integer, Optional) (default: 30): Request timeout in seconds\n- **follow_redirects** (boolean, Optional) (default: True): Whether to follow HTTP redirects\n- **verbose** (boolean, Optional): Enable verbose output showing request/response headers\n\n\n## Usage\n\nThis tool is part of the web_security category.\n\n**Endpoint:** `api/tools/curl_request`\n\n**Returns:** HTTP response including status code, headers, and body\n\n## Files Included\n\n- `curl_request.yaml` - Tool configuration\n- `curl_request.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "curl_request.yaml",
          "content": "name: curl_request\ncategory: web_security\ntags: [ctf, http, web, request]\nendpoint: api/tools/curl_request\ndescription: 'Execute HTTP requests using curl. Supports GET, POST, PUT, DELETE methods with custom headers and data. Ideal for CTF web challenges, API testing, and HTTP debugging.'\nreturns: HTTP response including status code, headers, and body\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL to send the request to\n- name: method\n  type: string\n  required: false\n  description: HTTP method (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)\n  default: GET\n- name: headers\n  type: string\n  required: false\n  description: Custom headers in format \"Header1:Value1,Header2:Value2\"\n  default: ''\n- name: data\n  type: string\n  required: false\n  description: Request body data (for POST, PUT, PATCH)\n  default: ''\n- name: timeout\n  type: integer\n  required: false\n  description: Request timeout in seconds\n  default: 30\n- name: follow_redirects\n  type: boolean\n  required: false\n  description: Whether to follow HTTP redirects\n  default: true\n- name: verbose\n  type: boolean\n  required: false\n  description: Enable verbose output showing request/response headers\n  default: false\n",
          "language": "yaml"
        },
        {
          "name": "curl_request.py",
          "content": "import logging\nfrom typing import Dict, Any\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass CurlRequestHandler(AbstractHandler):\n    \"\"\"\n    HTTP request handler using curl.\n    Supports various HTTP methods, custom headers, and request body.\n    Ideal for CTF web challenges and API testing.\n    \"\"\"\n\n    def __init__(self, config: Dict):\n        super().__init__(config)\n\n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n\n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute HTTP request using curl\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            method = data.get(\"method\", \"GET\").upper()\n            headers = data.get(\"headers\", \"\")\n            request_data = data.get(\"data\", \"\")\n            timeout = data.get(\"timeout\", 30)\n            follow_redirects = data.get(\"follow_redirects\", True)\n            verbose = data.get(\"verbose\", False)\n\n            if not url:\n                logger.warning(\"ðŸŒ curl_request called without URL\")\n                return {\"error\": \"URL parameter is required\"}\n\n            # Build curl command\n            command = \"curl\"\n            \n            # Add method\n            if method != \"GET\":\n                command += f\" -X {method}\"\n            \n            # Add verbose flag\n            if verbose:\n                command += \" -v\"\n            \n            # Add follow redirects\n            if follow_redirects:\n                command += \" -L\"\n            \n            # Add timeout\n            command += f\" --max-time {timeout}\"\n            \n            # Add custom headers\n            if headers:\n                for header in headers.split(\",\"):\n                    header = header.strip()\n                    if header:\n                        command += f' -H \"{header}\"'\n            \n            # Add request body\n            if request_data:\n                # Escape quotes in data\n                escaped_data = request_data.replace('\"', '\\\\\"')\n                command += f' -d \"{escaped_data}\"'\n            \n            # Add URL (must be last)\n            command += f' \"{url}\"'\n\n            logger.info(f\"ðŸŒ Executing curl request: {method} {url}\")\n            result = execute_command(command, timeout=timeout + 5)\n\n            logger.info(f\"ðŸ“Š curl request completed for {url}\")\n            result[\"method\"] = method\n            result[\"url\"] = url\n            return result\n\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in curl_request: {str(e)}\")\n            return {\"error\": f\"Request error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182558
    },
    {
      "id": "web_application_scanning-uro_url_filtering",
      "name": "Uro Url Filtering",
      "description": "Execute uro for filtering out similar URLs. urls: URLs to filter whitelist: Whitelist patterns blacklist: Blacklist patterns additional_args: Additional uro arguments",
      "license": "MIT",
      "content": "---\nname: uro_url_filtering\ncapabilities: ['urls', 'whitelist', 'blacklist', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'uro']\n---\n\n# Uro Url Filtering\n\nExecute uro for filtering out similar URLs. urls: URLs to filter whitelist: Whitelist patterns blacklist: Blacklist patterns additional_args: Additional uro arguments\n\n## Parameters\n- **urls** (string, Required): URLs to filter\n- **whitelist** (string, Optional): Whitelist patterns\n- **blacklist** (string, Optional): Blacklist patterns\n- **additional_args** (string, Optional): Additional uro arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/uro`\n\n**Returns:** Filtered URL results with duplicates removed\n\n## Files Included\n\n- `uro_url_filtering.yaml` - Tool configuration\n- `uro_url_filtering.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: uro_url_filtering\ncapabilities: ['urls', 'whitelist', 'blacklist', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'uro']\n---\n\n# Uro Url Filtering\n\nExecute uro for filtering out similar URLs. urls: URLs to filter whitelist: Whitelist patterns blacklist: Blacklist patterns additional_args: Additional uro arguments\n\n## Parameters\n- **urls** (string, Required): URLs to filter\n- **whitelist** (string, Optional): Whitelist patterns\n- **blacklist** (string, Optional): Blacklist patterns\n- **additional_args** (string, Optional): Additional uro arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/uro`\n\n**Returns:** Filtered URL results with duplicates removed\n\n## Files Included\n\n- `uro_url_filtering.yaml` - Tool configuration\n- `uro_url_filtering.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "uro_url_filtering.yaml",
          "content": "name: uro_url_filtering\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, uro]\nendpoint: api/tools/uro\ndescription: 'Execute uro for filtering out similar URLs. urls: URLs to filter whitelist:\n  Whitelist patterns blacklist: Blacklist patterns additional_args: Additional uro\n  arguments'\nreturns: Filtered URL results with duplicates removed\nparameters:\n- name: urls\n  type: string\n  required: true\n  description: URLs to filter\n- name: whitelist\n  type: string\n  required: false\n  description: Whitelist patterns\n  default: ''\n- name: blacklist\n  type: string\n  required: false\n  description: Blacklist patterns\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional uro arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "uro_url_filtering.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\n\nclass UroHandler(AbstractHandler):\n    \"\"\"Handler for uro functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute uro with enhanced logging\"\"\"\n        try:\n            urls = data.get(\"urls\", \"\")\n            whitelist = data.get(\"whitelist\", \"\")\n            blacklist = data.get(\"blacklist\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not urls:\n                logger.warning(\"ðŸŒ uro called without URLs\")\n                return {\"error\": \"URLs parameter is required\"}\n            command = f\"echo '{urls}' | uro\"\n            if whitelist:\n                command += f\" --whitelist {whitelist}\"\n            if blacklist:\n                command += f\" --blacklist {blacklist}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(\"ðŸ” Starting uro URL filtering\")\n            result = execute_command(command)\n            logger.info(\"ðŸ“Š uro URL filtering completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in uro endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182559
    },
    {
      "id": "web_application_scanning-nikto_scan",
      "name": "Nikto Scan",
      "description": "Execute Nikto web vulnerability scanner with enhanced logging. target: The target URL or IP additional_args: Additional Nikto arguments",
      "license": "MIT",
      "content": "---\nname: nikto_scan\ncapabilities: ['target', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nikto']\n---\n\n# Nikto Scan\n\nExecute Nikto web vulnerability scanner with enhanced logging. target: The target URL or IP additional_args: Additional Nikto arguments\n\n## Parameters\n- **target** (string, Required): The target URL or IP\n- **additional_args** (string, Optional): Additional Nikto arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/nikto`\n\n**Returns:** Scan results with discovered vulnerabilities\n\n## Files Included\n\n- `nikto_scan.yaml` - Tool configuration\n- `nikto_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: nikto_scan\ncapabilities: ['target', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nikto']\n---\n\n# Nikto Scan\n\nExecute Nikto web vulnerability scanner with enhanced logging. target: The target URL or IP additional_args: Additional Nikto arguments\n\n## Parameters\n- **target** (string, Required): The target URL or IP\n- **additional_args** (string, Optional): Additional Nikto arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/nikto`\n\n**Returns:** Scan results with discovered vulnerabilities\n\n## Files Included\n\n- `nikto_scan.yaml` - Tool configuration\n- `nikto_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "nikto_scan.yaml",
          "content": "name: nikto_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, nikto]\nendpoint: api/tools/nikto\ndescription: 'Execute Nikto web vulnerability scanner with enhanced logging. target:\n  The target URL or IP additional_args: Additional Nikto arguments'\nreturns: Scan results with discovered vulnerabilities\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target URL or IP\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Nikto arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "nikto_scan.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass NiktoHandler(AbstractHandler):\n    \"\"\"Handler for nikto functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute nikto with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ Nikto called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"nikto -h {target}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”¬ Starting Nikto scan: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Nikto scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in nikto endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182561
    },
    {
      "id": "web_application_scanning-http_repeater",
      "name": "Http Repeater",
      "description": "Send a crafted request (Burp Repeater equivalent). request_spec keys: url, method, headers, cookies, data.",
      "license": "MIT",
      "content": "---\nname: http_repeater\ncapabilities: ['request-spec']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'burp']\n---\n\n# Http Repeater\n\nSend a crafted request (Burp Repeater equivalent). request_spec keys: url, method, headers, cookies, data.\n\n## Parameters\n- **request_spec** (string, Required): request_spec parameter\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** Tool execution results\n\n## Files Included\n\n- `http_repeater.yaml` - Tool configuration\n- `http_repeater.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: http_repeater\ncapabilities: ['request-spec']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'burp']\n---\n\n# Http Repeater\n\nSend a crafted request (Burp Repeater equivalent). request_spec keys: url, method, headers, cookies, data.\n\n## Parameters\n- **request_spec** (string, Required): request_spec parameter\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** Tool execution results\n\n## Files Included\n\n- `http_repeater.yaml` - Tool configuration\n- `http_repeater.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "http_repeater.yaml",
          "content": "name: http_repeater\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, burp]\nendpoint: api/tools/http-framework\ndescription: 'Send a crafted request (Burp Repeater equivalent). request_spec keys:\n  url, method, headers, cookies, data.'\nreturns: Tool execution results\nparameters:\n- name: request_spec\n  type: string\n  required: true\n  description: request_spec parameter\n",
          "language": "yaml"
        },
        {
          "name": "http_repeater.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.services.http_test_framework import http_framework\n\nlogger = logging.getLogger(__name__)\n\n\nclass HttpFrameworkEndpointHandler(AbstractHandler):\n    \"\"\"Handler for http_framework_endpoint functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute http_framework_endpoint with enhanced logging\"\"\"\n        try:\n            action = data.get(\"action\", \"request\")  # request, spider, proxy_history, set_rules, set_scope, repeater, intruder\n            url = data.get(\"url\", \"\")\n            method = data.get(\"method\", \"GET\")\n            request_data = data.get(\"data\", {})\n            headers = data.get(\"headers\", {})\n            cookies = data.get(\"cookies\", {})\n            if action == \"request\":\n                if not url:\n                    return {\"error\": \"URL parameter is required for request action\"}\n                request_command = f\"{method} {url}\"\n                result = http_framework.intercept_request(url, method, request_data, headers, cookies)\n                return result\n            elif action == \"spider\":\n                if not url:\n                    return {\"error\": \"URL parameter is required for spider action\"}\n                max_depth = data.get(\"max_depth\", 3)\n                max_pages = data.get(\"max_pages\", 100)\n                spider_command = f\"Spider {url}\"\n                result = http_framework.spider_website(url, max_depth, max_pages)\n                return result\n            elif action == \"proxy_history\":\n                return {\n    \n                    \"success\": True,\n                    \"history\": http_framework.proxy_history[-100:],  # Last 100 requests\n                    \"total_requests\": len(http_framework.proxy_history),\n                    \"vulnerabilities\": http_framework.vulnerabilities,\n                \n                }\n            elif action == \"set_rules\":\n                rules = data.get(\"rules\", [])\n                http_framework.set_match_replace_rules(rules)\n                return {\"success\": True, \"rules_set\": len(rules)}\n            elif action == \"set_scope\":\n                scope_host = data.get(\"host\")\n                include_sub = data.get(\"include_subdomains\", True)\n                if not scope_host:\n                    return {\"error\": \"host parameter required\"}\n                http_framework.set_scope(scope_host, include_sub)\n                return {\"success\": True, \"scope\": http_framework.scope}\n            elif action == \"repeater\":\n                request_spec = data.get(\"request\") or {}\n                result = http_framework.send_custom_request(request_spec)\n                return result\n            elif action == \"intruder\":\n                if not url:\n                    return {\"error\": \"URL parameter required\"}\n                method = data.get(\"method\", \"GET\")\n                location = data.get(\"location\", \"query\")\n                fuzz_params = data.get(\"params\", [])\n                payloads = data.get(\"payloads\", [])\n                base_data = data.get(\"base_data\", {})\n                max_requests = data.get(\"max_requests\", 100)\n                result = http_framework.intruder_sniper(\n                    url, method, location, fuzz_params, payloads, base_data, max_requests\n                )\n                return result\n            else:\n                return {\"error\": f\"Unknown action: {action}\"}\n        except Exception as e:\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182562
    },
    {
      "id": "web_application_scanning-gobuster_scan",
      "name": "Gobuster Scan",
      "description": "Execute Gobuster to find directories, DNS subdomains, or virtual hosts with enhanced logging. url: The target URL mode: Scan mode (dir, dns, fuzz, vhost) wordlist: Path to wordlist file additional_args: Additional Gobuster arguments",
      "license": "MIT",
      "content": "---\nname: gobuster_scan\ncapabilities: ['url', 'mode', 'wordlist', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'gobuster']\n---\n\n# Gobuster Scan\n\nExecute Gobuster to find directories, DNS subdomains, or virtual hosts with enhanced logging. url: The target URL mode: Scan mode (dir, dns, fuzz, vhost) wordlist: Path to wordlist file additional_args: Additional Gobuster arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **mode** (string, Optional) (default: dir): Scan mode (dir, dns, fuzz, vhost)\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Path to wordlist file\n- **additional_args** (string, Optional): Additional Gobuster arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/gobuster`\n\n**Returns:** Scan results with enhanced telemetry\n\n## Files Included\n\n- `gobuster_scan.yaml` - Tool configuration\n- `gobuster_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: gobuster_scan\ncapabilities: ['url', 'mode', 'wordlist', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'gobuster']\n---\n\n# Gobuster Scan\n\nExecute Gobuster to find directories, DNS subdomains, or virtual hosts with enhanced logging. url: The target URL mode: Scan mode (dir, dns, fuzz, vhost) wordlist: Path to wordlist file additional_args: Additional Gobuster arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **mode** (string, Optional) (default: dir): Scan mode (dir, dns, fuzz, vhost)\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Path to wordlist file\n- **additional_args** (string, Optional): Additional Gobuster arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/gobuster`\n\n**Returns:** Scan results with enhanced telemetry\n\n## Files Included\n\n- `gobuster_scan.yaml` - Tool configuration\n- `gobuster_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "gobuster_scan.yaml",
          "content": "name: gobuster_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, gobuster]\nendpoint: api/tools/gobuster\ndescription: 'Execute Gobuster to find directories, DNS subdomains, or virtual hosts\n  with enhanced logging. url: The target URL mode: Scan mode (dir, dns, fuzz, vhost)\n  wordlist: Path to wordlist file additional_args: Additional Gobuster arguments'\nreturns: Scan results with enhanced telemetry\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL\n- name: mode\n  type: string\n  required: false\n  description: Scan mode (dir, dns, fuzz, vhost)\n  default: dir\n- name: wordlist\n  type: string\n  required: false\n  description: Path to wordlist file\n  default: /usr/share/wordlists/dirb/common.txt\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Gobuster arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "gobuster_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass GobusterHandler(AbstractHandler):\n    \"\"\"Handler for gobuster functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute gobuster with enhanced logging\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            mode = data.get(\"mode\", \"dir\")\n            wordlist = data.get(\"wordlist\", \"/usr/share/wordlists/dirb/common.txt\")\n            additional_args = data.get(\"additional_args\", \"\")\n            use_recovery = data.get(\"use_recovery\", True)\n            if not url:\n                logger.warning(\"ðŸŒ Gobuster called without URL parameter\")\n                return {\n    \n                    \"error\": \"URL parameter is required\"\n                \n                }\n            if mode not in [\"dir\", \"dns\", \"fuzz\", \"vhost\"]:\n                logger.warning(f\"âŒ Invalid gobuster mode: {mode}\")\n                return {\n    \n                    \"error\": f\"Invalid mode: {mode}. Must be one of: dir, dns, fuzz, vhost\"\n                \n                }\n            command = f\"gobuster {mode} -u {url} -w {wordlist}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ“ Starting Gobuster {mode} scan: {url}\")\n            # if use_recovery:\n            #     tool_params = {\n            #         \"target\": url,\n            #         \"mode\": mode,\n            #         \"wordlist\": wordlist,\n            #         \"additional_args\": additional_args\n            #     }\n            #     result = execute_command(\"gobuster\", command, tool_params)\n            # else:\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Gobuster scan completed for {url}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in gobuster endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182563
    },
    {
      "id": "web_application_scanning-wfuzz_scan",
      "name": "Wfuzz Scan",
      "description": "Execute Wfuzz for web application fuzzing with enhanced logging. url: The target URL (use FUZZ where you want to inject payloads) wordlist: Wordlist file to use additional_args: Additional Wfuzz arguments",
      "license": "MIT",
      "content": "---\nname: wfuzz_scan\ncapabilities: ['url', 'wordlist', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'wfuzz']\n---\n\n# Wfuzz Scan\n\nExecute Wfuzz for web application fuzzing with enhanced logging. url: The target URL (use FUZZ where you want to inject payloads) wordlist: Wordlist file to use additional_args: Additional Wfuzz arguments\n\n## Parameters\n- **url** (string, Required): The target URL (use FUZZ where you want to inject payloads)\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Wordlist file to use\n- **additional_args** (string, Optional): Additional Wfuzz arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/wfuzz`\n\n**Returns:** Web application fuzzing results\n\n## Files Included\n\n- `wfuzz_scan.yaml` - Tool configuration\n- `wfuzz_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: wfuzz_scan\ncapabilities: ['url', 'wordlist', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'wfuzz']\n---\n\n# Wfuzz Scan\n\nExecute Wfuzz for web application fuzzing with enhanced logging. url: The target URL (use FUZZ where you want to inject payloads) wordlist: Wordlist file to use additional_args: Additional Wfuzz arguments\n\n## Parameters\n- **url** (string, Required): The target URL (use FUZZ where you want to inject payloads)\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Wordlist file to use\n- **additional_args** (string, Optional): Additional Wfuzz arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/wfuzz`\n\n**Returns:** Web application fuzzing results\n\n## Files Included\n\n- `wfuzz_scan.yaml` - Tool configuration\n- `wfuzz_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "wfuzz_scan.yaml",
          "content": "name: wfuzz_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, wfuzz]\nendpoint: api/tools/wfuzz\ndescription: 'Execute Wfuzz for web application fuzzing with enhanced logging. url:\n  The target URL (use FUZZ where you want to inject payloads) wordlist: Wordlist file\n  to use additional_args: Additional Wfuzz arguments'\nreturns: Web application fuzzing results\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL (use FUZZ where you want to inject payloads)\n- name: wordlist\n  type: string\n  required: false\n  description: Wordlist file to use\n  default: /usr/share/wordlists/dirb/common.txt\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Wfuzz arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "wfuzz_scan.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass WfuzzHandler(AbstractHandler):\n    \"\"\"Handler for wfuzz functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute wfuzz with enhanced logging\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            wordlist = data.get(\"wordlist\", \"/usr/share/wordlists/dirb/common.txt\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not url:\n                logger.warning(\"ðŸŒ Wfuzz called without URL parameter\")\n                return {\n    \n                    \"error\": \"URL parameter is required\"\n                \n                }\n            command = f\"wfuzz -w {wordlist} '{url}'\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Wfuzz scan: {url}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Wfuzz scan completed for {url}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in wfuzz endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182564
    },
    {
      "id": "web_application_scanning-http_intruder",
      "name": "Http Intruder",
      "description": "Simple Intruder (sniper) fuzzing. Iterates payloads over each param individually. location: query|body|headers|cookie.",
      "license": "MIT",
      "content": "---\nname: http_intruder\ncapabilities: ['url', 'method', 'location', 'params', 'payloads', 'base-data', 'max-requests']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'sniper']\n---\n\n# Http Intruder\n\nSimple Intruder (sniper) fuzzing. Iterates payloads over each param individually. location: query|body|headers|cookie.\n\n## Parameters\n- **url** (string, Required): url parameter\n- **method** (string, Optional) (default: GET): method parameter\n- **location** (string, Optional) (default: query): query|body|headers|cookie.\n- **params** (string, Optional): params parameter\n- **payloads** (string, Optional): payloads parameter\n- **base_data** (string, Optional): base_data parameter\n- **max_requests** (integer, Optional) (default: 100): max_requests parameter\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** Tool execution results\n\n## Files Included\n\n- `http_intruder.yaml` - Tool configuration\n- `http_intruder.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: http_intruder\ncapabilities: ['url', 'method', 'location', 'params', 'payloads', 'base-data', 'max-requests']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'sniper']\n---\n\n# Http Intruder\n\nSimple Intruder (sniper) fuzzing. Iterates payloads over each param individually. location: query|body|headers|cookie.\n\n## Parameters\n- **url** (string, Required): url parameter\n- **method** (string, Optional) (default: GET): method parameter\n- **location** (string, Optional) (default: query): query|body|headers|cookie.\n- **params** (string, Optional): params parameter\n- **payloads** (string, Optional): payloads parameter\n- **base_data** (string, Optional): base_data parameter\n- **max_requests** (integer, Optional) (default: 100): max_requests parameter\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** Tool execution results\n\n## Files Included\n\n- `http_intruder.yaml` - Tool configuration\n- `http_intruder.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "http_intruder.yaml",
          "content": "name: http_intruder\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, sniper]\nendpoint: api/tools/http-framework\ndescription: 'Simple Intruder (sniper) fuzzing. Iterates payloads over each param\n  individually. location: query|body|headers|cookie.'\nreturns: Tool execution results\nparameters:\n- name: url\n  type: string\n  required: true\n  description: url parameter\n- name: method\n  type: string\n  required: false\n  description: method parameter\n  default: GET\n- name: location\n  type: string\n  required: false\n  description: query|body|headers|cookie.\n  default: query\n- name: params\n  type: string\n  required: false\n  description: params parameter\n- name: payloads\n  type: string\n  required: false\n  description: payloads parameter\n- name: base_data\n  type: string\n  required: false\n  description: base_data parameter\n- name: max_requests\n  type: integer\n  required: false\n  description: max_requests parameter\n  default: 100\n",
          "language": "yaml"
        },
        {
          "name": "http_intruder.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.services.http_test_framework import http_framework\n\nlogger = logging.getLogger(__name__)\n\n\nclass HttpFrameworkEndpointHandler(AbstractHandler):\n    \"\"\"Handler for http_framework_endpoint functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute http_framework_endpoint with enhanced logging\"\"\"\n        try:\n            action = data.get(\"action\", \"request\")  # request, spider, ... è§åŽŸ handler\n            url = data.get(\"url\", \"\")\n            method = data.get(\"method\", \"GET\")\n            request_data = data.get(\"data\", {})\n            headers = data.get(\"headers\", {})\n            cookies = data.get(\"cookies\", {})\n            if action == \"request\":\n                if not url:\n                    return {\"error\": \"URL parameter is required for request action\"}\n                request_command = f\"{method} {url}\"\n                result = http_framework.intercept_request(url, method, request_data, headers, cookies)\n                return result\n        except Exception as e:\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182565
    },
    {
      "id": "osint_gathering-waybackurls_discovery",
      "name": "Waybackurls Discovery",
      "description": "Execute Waybackurls for historical URL discovery with enhanced logging. domain: The target domain get_versions: Get all versions of URLs no_subs: Don't include subdomains additional_args: Additional Waybackurls arguments",
      "license": "MIT",
      "content": "---\nname: waybackurls_discovery\ncapabilities: ['domain', 'get-versions', 'no-subs', 'additional-args']\ncategory: osint_gathering\ntags: ['web_application_scanning', 'vulnerability_hunting', 'penetration_testing', 'waybackurls']\n---\n\n# Waybackurls Discovery\n\nExecute Waybackurls for historical URL discovery with enhanced logging. domain: The target domain get_versions: Get all versions of URLs no_subs: Don't include subdomains additional_args: Additional Waybackurls arguments\n\n## Parameters\n- **domain** (string, Required): The target domain\n- **get_versions** (boolean, Optional): Get all versions of URLs\n- **no_subs** (boolean, Optional): Don't include subdomains\n- **additional_args** (string, Optional): Additional Waybackurls arguments\n\n\n## Usage\n\nThis tool is part of the osint_gathering category.\n\n**Endpoint:** `api/tools/waybackurls`\n\n**Returns:** Historical URL discovery results from Wayback Machine\n\n## Files Included\n\n- `waybackurls_discovery.yaml` - Tool configuration\n- `waybackurls_discovery.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: waybackurls_discovery\ncapabilities: ['domain', 'get-versions', 'no-subs', 'additional-args']\ncategory: osint_gathering\ntags: ['web_application_scanning', 'vulnerability_hunting', 'penetration_testing', 'waybackurls']\n---\n\n# Waybackurls Discovery\n\nExecute Waybackurls for historical URL discovery with enhanced logging. domain: The target domain get_versions: Get all versions of URLs no_subs: Don't include subdomains additional_args: Additional Waybackurls arguments\n\n## Parameters\n- **domain** (string, Required): The target domain\n- **get_versions** (boolean, Optional): Get all versions of URLs\n- **no_subs** (boolean, Optional): Don't include subdomains\n- **additional_args** (string, Optional): Additional Waybackurls arguments\n\n\n## Usage\n\nThis tool is part of the osint_gathering category.\n\n**Endpoint:** `api/tools/waybackurls`\n\n**Returns:** Historical URL discovery results from Wayback Machine\n\n## Files Included\n\n- `waybackurls_discovery.yaml` - Tool configuration\n- `waybackurls_discovery.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "waybackurls_discovery.yaml",
          "content": "name: waybackurls_discovery\ncategory: osint_gathering\ntags: [web_application_scanning, vulnerability_hunting, penetration_testing, waybackurls]\nendpoint: api/tools/waybackurls\ndescription: 'Execute Waybackurls for historical URL discovery with enhanced logging.\n  domain: The target domain get_versions: Get all versions of URLs no_subs: Don''t\n  include subdomains additional_args: Additional Waybackurls arguments'\nreturns: Historical URL discovery results from Wayback Machine\nparameters:\n- name: domain\n  type: string\n  required: true\n  description: The target domain\n- name: get_versions\n  type: boolean\n  required: false\n  description: Get all versions of URLs\n  default: false\n- name: no_subs\n  type: boolean\n  required: false\n  description: Don't include subdomains\n  default: false\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Waybackurls arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "waybackurls_discovery.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass WaybackurlsHandler(AbstractHandler):\n    \"\"\"Handler for waybackurls functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute waybackurls with enhanced logging\"\"\"\n        try:\n            domain = data.get(\"domain\", \"\")\n            get_versions = data.get(\"get_versions\", False)\n            no_subs = data.get(\"no_subs\", False)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not domain:\n                logger.warning(\"ðŸŒ Waybackurls called without domain parameter\")\n                return {\"error\": \"Domain parameter is required\"}\n            command = f\"waybackurls {domain}\"\n            if get_versions:\n                command += \" --get-versions\"\n            if no_subs:\n                command += \" --no-subs\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ•°ï¸  Starting Waybackurls discovery: {domain}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Waybackurls discovery completed for {domain}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in waybackurls endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182567
    },
    {
      "id": "web_application_scanning-http_set_rules",
      "name": "Http Set Rules",
      "description": "Set match/replace rules used to rewrite parts of URL/query/headers/body before sending. Rule format: {'where':'url|query|headers|body','pattern':'regex','replacement':'string'}",
      "license": "MIT",
      "content": "---\nname: http_set_rules\ncapabilities: ['rules']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing']\n---\n\n# Http Set Rules\n\nSet match/replace rules used to rewrite parts of URL/query/headers/body before sending. Rule format: {'where':'url|query|headers|body','pattern':'regex','replacement':'string'}\n\n## Parameters\n- **rules** (string, Required): rules parameter\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** Tool execution results\n\n## Files Included\n\n- `http_set_rules.yaml` - Tool configuration\n- `http_set_rules.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: http_set_rules\ncapabilities: ['rules']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing']\n---\n\n# Http Set Rules\n\nSet match/replace rules used to rewrite parts of URL/query/headers/body before sending. Rule format: {'where':'url|query|headers|body','pattern':'regex','replacement':'string'}\n\n## Parameters\n- **rules** (string, Required): rules parameter\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** Tool execution results\n\n## Files Included\n\n- `http_set_rules.yaml` - Tool configuration\n- `http_set_rules.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "http_set_rules.yaml",
          "content": "name: http_set_rules\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing]\nendpoint: api/tools/http-framework\ndescription: 'Set match/replace rules used to rewrite parts of URL/query/headers/body\n  before sending. Rule format: {''where'':''url|query|headers|body'',''pattern'':''regex'',''replacement'':''string''}'\nreturns: Tool execution results\nparameters:\n- name: rules\n  type: string\n  required: true\n  description: rules parameter\n",
          "language": "yaml"
        },
        {
          "name": "http_set_rules.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.services.http_test_framework import http_framework\n\nlogger = logging.getLogger(__name__)\n\n\nclass HttpFrameworkEndpointHandler(AbstractHandler):\n    \"\"\"Handler for http_framework_endpoint functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute http_framework_endpoint with enhanced logging\"\"\"\n        try:\n            action = data.get(\"action\", \"request\")  # request, spider, proxy_history, set_rules, set_scope, repeater, intruder\n            url = data.get(\"url\", \"\")\n            method = data.get(\"method\", \"GET\")\n            request_data = data.get(\"data\", {})\n            headers = data.get(\"headers\", {})\n            cookies = data.get(\"cookies\", {})\n            if action == \"request\":\n                if not url:\n                    return {\"error\": \"URL parameter is required for request action\"}\n                request_command = f\"{method} {url}\"\n                result = http_framework.intercept_request(url, method, request_data, headers, cookies)\n                return result\n            elif action == \"spider\":\n                if not url:\n                    return {\"error\": \"URL parameter is required for spider action\"}\n                max_depth = data.get(\"max_depth\", 3)\n                max_pages = data.get(\"max_pages\", 100)\n                spider_command = f\"Spider {url}\"\n                result = http_framework.spider_website(url, max_depth, max_pages)\n                return result\n            elif action == \"proxy_history\":\n                return {\n    \n                    \"success\": True,\n                    \"history\": http_framework.proxy_history[-100:],  # Last 100 requests\n                    \"total_requests\": len(http_framework.proxy_history),\n                    \"vulnerabilities\": http_framework.vulnerabilities,\n                \n                }\n            elif action == \"set_rules\":\n                rules = data.get(\"rules\", [])\n                http_framework.set_match_replace_rules(rules)\n                return {\"success\": True, \"rules_set\": len(rules)}\n            elif action == \"set_scope\":\n                scope_host = data.get(\"host\")\n                include_sub = data.get(\"include_subdomains\", True)\n                if not scope_host:\n                    return {\"error\": \"host parameter required\"}\n                http_framework.set_scope(scope_host, include_sub)\n                return {\"success\": True, \"scope\": http_framework.scope}\n            elif action == \"repeater\":\n                request_spec = data.get(\"request\") or {}\n                result = http_framework.send_custom_request(request_spec)\n                return result\n            elif action == \"intruder\":\n                if not url:\n                    return {\"error\": \"URL parameter required\"}\n                method = data.get(\"method\", \"GET\")\n                location = data.get(\"location\", \"query\")\n                fuzz_params = data.get(\"params\", [])\n                payloads = data.get(\"payloads\", [])\n                base_data = data.get(\"base_data\", {})\n                max_requests = data.get(\"max_requests\", 100)\n                result = http_framework.intruder_sniper(\n                    url, method, location, fuzz_params, payloads, base_data, max_requests\n                )\n                return result\n            else:\n                return {\"error\": f\"Unknown action: {action}\"}\n        except Exception as e:\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182567
    },
    {
      "id": "web_application_scanning-httpx_probe",
      "name": "Httpx Probe",
      "description": "Execute HTTPx for HTTP probing with enhanced logging. targets: Target URLs or IPs target_file: File containing targets ports: Ports to probe methods: HTTP methods to use status_code: Filter by status code content_length: Show content length output_file: Output file path additional_args: Additional HTTPx arguments",
      "license": "MIT",
      "content": "---\nname: httpx_probe\ncapabilities: ['target', 'ports', 'methods', 'status-code', 'content-length', 'output-file', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'httpx']\n---\n\n# Httpx Probe\n\nExecute HTTPx for HTTP probing with enhanced logging. targets: Target URLs or IPs target_file: File containing targets ports: Ports to probe methods: HTTP methods to use status_code: Filter by status code content_length: Show content length output_file: Output file path additional_args: Additional HTTPx arguments\n\n## Parameters\n- **target** (string, Required): Target URLs or IPs\n- **ports** (string, Optional): Ports to probe\n- **methods** (string, Optional) (default: GET): HTTP methods to use\n- **status_code** (string, Optional): Filter by status code\n- **content_length** (boolean, Optional): Show content length\n- **output_file** (string, Optional): Output file path\n- **additional_args** (string, Optional): Additional HTTPx arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/httpx`\n\n**Returns:** HTTP probing results\n\n## Files Included\n\n- `httpx_probe.yaml` - Tool configuration\n- `httpx_probe.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: httpx_probe\ncapabilities: ['target', 'ports', 'methods', 'status-code', 'content-length', 'output-file', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'httpx']\n---\n\n# Httpx Probe\n\nExecute HTTPx for HTTP probing with enhanced logging. targets: Target URLs or IPs target_file: File containing targets ports: Ports to probe methods: HTTP methods to use status_code: Filter by status code content_length: Show content length output_file: Output file path additional_args: Additional HTTPx arguments\n\n## Parameters\n- **target** (string, Required): Target URLs or IPs\n- **ports** (string, Optional): Ports to probe\n- **methods** (string, Optional) (default: GET): HTTP methods to use\n- **status_code** (string, Optional): Filter by status code\n- **content_length** (boolean, Optional): Show content length\n- **output_file** (string, Optional): Output file path\n- **additional_args** (string, Optional): Additional HTTPx arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/httpx`\n\n**Returns:** HTTP probing results\n\n## Files Included\n\n- `httpx_probe.yaml` - Tool configuration\n- `httpx_probe.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "httpx_probe.yaml",
          "content": "name: httpx_probe\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, httpx]\nendpoint: api/tools/httpx\ndescription: 'Execute HTTPx for HTTP probing with enhanced logging. targets: Target\n  URLs or IPs target_file: File containing targets ports: Ports to probe methods:\n  HTTP methods to use status_code: Filter by status code content_length: Show content\n  length output_file: Output file path additional_args: Additional HTTPx arguments'\nreturns: HTTP probing results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: Target URLs or IPs\n  default: ''\n- name: ports\n  type: string\n  required: false\n  description: Ports to probe\n  default: ''\n- name: methods\n  type: string\n  required: false\n  description: HTTP methods to use\n  default: GET\n- name: status_code\n  type: string\n  required: false\n  description: Filter by status code\n  default: ''\n- name: content_length\n  type: boolean\n  required: false\n  description: Show content length\n  default: false\n- name: output_file\n  type: string\n  required: false\n  description: Output file path\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional HTTPx arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "httpx_probe.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass HttpxHandler(AbstractHandler):\n    \"\"\"Handler for httpx functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute httpx with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            probe = data.get(\"probe\", True)\n            tech_detect = data.get(\"tech_detect\", False)\n            status_code = data.get(\"status_code\", False)\n            content_length = data.get(\"content_length\", False)\n            title = data.get(\"title\", False)\n            web_server = data.get(\"web_server\", False)\n            threads = data.get(\"threads\", 50)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŒ httpx called without target parameter\")\n                return {\"error\": \"Target parameter is required\"}\n            command = f\"httpx -l {target} -t {threads}\"\n            if probe:\n                command += \" -probe\"\n            if tech_detect:\n                command += \" -tech-detect\"\n            if status_code:\n                command += \" -sc\"\n            if content_length:\n                command += \" -cl\"\n            if title:\n                command += \" -title\"\n            if web_server:\n                command += \" -server\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸŒ Starting httpx probe: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š httpx probe completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in httpx endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182569
    },
    {
      "id": "web_application_scanning-http_set_scope",
      "name": "Http Set Scope",
      "description": "Define in-scope host (and optionally subdomains) so out-of-scope requests are skipped.",
      "license": "MIT",
      "content": "---\nname: http_set_scope\ncapabilities: ['host', 'include-subdomains']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing']\n---\n\n# Http Set Scope\n\nDefine in-scope host (and optionally subdomains) so out-of-scope requests are skipped.\n\n## Parameters\n- **host** (string, Required): host parameter\n- **include_subdomains** (boolean, Optional) (default: True): include_subdomains parameter\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** Tool execution results\n\n## Files Included\n\n- `http_set_scope.yaml` - Tool configuration\n- `http_set_scope.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: http_set_scope\ncapabilities: ['host', 'include-subdomains']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing']\n---\n\n# Http Set Scope\n\nDefine in-scope host (and optionally subdomains) so out-of-scope requests are skipped.\n\n## Parameters\n- **host** (string, Required): host parameter\n- **include_subdomains** (boolean, Optional) (default: True): include_subdomains parameter\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** Tool execution results\n\n## Files Included\n\n- `http_set_scope.yaml` - Tool configuration\n- `http_set_scope.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "http_set_scope.yaml",
          "content": "name: http_set_scope\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing]\nendpoint: api/tools/http-framework\ndescription: Define in-scope host (and optionally subdomains) so out-of-scope requests\n  are skipped.\nreturns: Tool execution results\nparameters:\n- name: host\n  type: string\n  required: true\n  description: host parameter\n- name: include_subdomains\n  type: boolean\n  required: false\n  description: include_subdomains parameter\n  default: true\n",
          "language": "yaml"
        },
        {
          "name": "http_set_scope.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.services.http_test_framework import http_framework\n\nlogger = logging.getLogger(__name__)\n\n\nclass HttpFrameworkEndpointHandler(AbstractHandler):\n    \"\"\"Handler for http_framework_endpoint functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute http_framework_endpoint with enhanced logging\"\"\"\n        try:\n            action = data.get(\"action\", \"request\")  # request, spider, proxy_history, set_rules, set_scope, repeater, intruder\n            url = data.get(\"url\", \"\")\n            method = data.get(\"method\", \"GET\")\n            request_data = data.get(\"data\", {})\n            headers = data.get(\"headers\", {})\n            cookies = data.get(\"cookies\", {})\n            if action == \"request\":\n                if not url:\n                    return {\"error\": \"URL parameter is required for request action\"}\n                request_command = f\"{method} {url}\"\n                result = http_framework.intercept_request(url, method, request_data, headers, cookies)\n                return result\n            elif action == \"spider\":\n                if not url:\n                    return {\"error\": \"URL parameter is required for spider action\"}\n                max_depth = data.get(\"max_depth\", 3)\n                max_pages = data.get(\"max_pages\", 100)\n                spider_command = f\"Spider {url}\"\n                result = http_framework.spider_website(url, max_depth, max_pages)\n                return result\n            elif action == \"proxy_history\":\n                return {\n    \n                    \"success\": True,\n                    \"history\": http_framework.proxy_history[-100:],  # Last 100 requests\n                    \"total_requests\": len(http_framework.proxy_history),\n                    \"vulnerabilities\": http_framework.vulnerabilities,\n                \n                }\n            elif action == \"set_rules\":\n                rules = data.get(\"rules\", [])\n                http_framework.set_match_replace_rules(rules)\n                return {\"success\": True, \"rules_set\": len(rules)}\n            elif action == \"set_scope\":\n                scope_host = data.get(\"host\")\n                include_sub = data.get(\"include_subdomains\", True)\n                if not scope_host:\n                    return {\"error\": \"host parameter required\"}\n                http_framework.set_scope(scope_host, include_sub)\n                return {\"success\": True, \"scope\": http_framework.scope}\n            elif action == \"repeater\":\n                request_spec = data.get(\"request\") or {}\n                result = http_framework.send_custom_request(request_spec)\n                return result\n            elif action == \"intruder\":\n                if not url:\n                    return {\"error\": \"URL parameter required\"}\n                method = data.get(\"method\", \"GET\")\n                location = data.get(\"location\", \"query\")\n                fuzz_params = data.get(\"params\", [])\n                payloads = data.get(\"payloads\", [])\n                base_data = data.get(\"base_data\", {})\n                max_requests = data.get(\"max_requests\", 100)\n                result = http_framework.intruder_sniper(\n                    url, method, location, fuzz_params, payloads, base_data, max_requests\n                )\n                return result\n            else:\n                return {\"error\": f\"Unknown action: {action}\"}\n        except Exception as e:\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182570
    },
    {
      "id": "web_application_scanning-http_framework_test",
      "name": "Http Framework Test",
      "description": "Enhanced HTTP testing framework (Burp Suite alternative) for comprehensive web security testing. url: Target URL to test method: HTTP method (GET, POST, PUT, DELETE, etc.) data: Request data/parameters headers: Custom headers cookies: Custom cookies action: Action to perform (request, spider, proxy_history, set_rules, set_scope, repeater, intruder)",
      "license": "MIT",
      "content": "---\nname: http_framework_test\ncapabilities: ['url', 'method', 'data', 'headers', 'cookies', 'action']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'burp']\n---\n\n# Http Framework Test\n\nEnhanced HTTP testing framework (Burp Suite alternative) for comprehensive web security testing. url: Target URL to test method: HTTP method (GET, POST, PUT, DELETE, etc.) data: Request data/parameters headers: Custom headers cookies: Custom cookies action: Action to perform (request, spider, proxy_history, set_rules, set_scope, repeater, intruder)\n\n## Parameters\n- **url** (string, Required): Target URL to test\n- **method** (string, Optional) (default: GET): HTTP method (GET, POST, PUT, DELETE, etc.)\n- **data** (string, Optional): Request data/parameters\n- **headers** (string, Optional): Custom headers\n- **cookies** (string, Optional): Custom cookies\n- **action** (string, Optional) (default: request): Action to perform (request, spider, proxy_history, set_rules, set_scope, repeater, intruder)\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** HTTP testing results with vulnerability analysis\n\n## Files Included\n\n- `http_framework_test.yaml` - Tool configuration\n- `http_framework_test.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: http_framework_test\ncapabilities: ['url', 'method', 'data', 'headers', 'cookies', 'action']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'burp']\n---\n\n# Http Framework Test\n\nEnhanced HTTP testing framework (Burp Suite alternative) for comprehensive web security testing. url: Target URL to test method: HTTP method (GET, POST, PUT, DELETE, etc.) data: Request data/parameters headers: Custom headers cookies: Custom cookies action: Action to perform (request, spider, proxy_history, set_rules, set_scope, repeater, intruder)\n\n## Parameters\n- **url** (string, Required): Target URL to test\n- **method** (string, Optional) (default: GET): HTTP method (GET, POST, PUT, DELETE, etc.)\n- **data** (string, Optional): Request data/parameters\n- **headers** (string, Optional): Custom headers\n- **cookies** (string, Optional): Custom cookies\n- **action** (string, Optional) (default: request): Action to perform (request, spider, proxy_history, set_rules, set_scope, repeater, intruder)\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/http-framework`\n\n**Returns:** HTTP testing results with vulnerability analysis\n\n## Files Included\n\n- `http_framework_test.yaml` - Tool configuration\n- `http_framework_test.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "http_framework_test.yaml",
          "content": "name: http_framework_test\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, burp]\nendpoint: api/tools/http-framework\ndescription: 'Enhanced HTTP testing framework (Burp Suite alternative) for comprehensive\n  web security testing. url: Target URL to test method: HTTP method (GET, POST, PUT,\n  DELETE, etc.) data: Request data/parameters headers: Custom headers cookies: Custom\n  cookies action: Action to perform (request, spider, proxy_history, set_rules, set_scope,\n  repeater, intruder)'\nreturns: HTTP testing results with vulnerability analysis\nparameters:\n- name: url\n  type: string\n  required: true\n  description: Target URL to test\n- name: method\n  type: string\n  required: false\n  description: HTTP method (GET, POST, PUT, DELETE, etc.)\n  default: GET\n- name: data\n  type: string\n  required: false\n  description: Request data/parameters\n  default: ''\n- name: headers\n  type: string\n  required: false\n  description: Custom headers\n  default: ''\n- name: cookies\n  type: string\n  required: false\n  description: Custom cookies\n  default: ''\n- name: action\n  type: string\n  required: false\n  description: Action to perform (request, spider, proxy_history, set_rules, set_scope,\n    repeater, intruder)\n  default: request\n",
          "language": "yaml"
        },
        {
          "name": "http_framework_test.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.services.http_test_framework import http_framework\n\nlogger = logging.getLogger(__name__)\n\n\nclass HttpFrameworkEndpointHandler(AbstractHandler):\n    \"\"\"Handler for http_framework_endpoint functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute http_framework_endpoint with enhanced logging\"\"\"\n        try:\n            action = data.get(\"action\", \"request\")  # request, spider, proxy_history, set_rules, set_scope, repeater, intruder\n            url = data.get(\"url\", \"\")\n            method = data.get(\"method\", \"GET\")\n            request_data = data.get(\"data\", {})\n            headers = data.get(\"headers\", {})\n            cookies = data.get(\"cookies\", {})\n            if action == \"request\":\n                if not url:\n                    return {\"error\": \"URL parameter is required for request action\"}\n                request_command = f\"{method} {url}\"\n                result = http_framework.intercept_request(url, method, request_data, headers, cookies)\n                # if result.get(\"success\"):\n                #     logger.info(f\"{ModernVisualEngine.format_tool_status('HTTP-Framework', 'SUCCESS', url)}\")\n                # else:\n                #     logger.error(f\"{ModernVisualEngine.format_tool_status('HTTP-Framework', 'FAILED', url)}\")\n                return result\n            elif action == \"spider\":\n                if not url:\n                    return {\"error\": \"URL parameter is required for spider action\"}\n                max_depth = data.get(\"max_depth\", 3)\n                max_pages = data.get(\"max_pages\", 100)\n                spider_command = f\"Spider {url}\"\n                # logger.info(f\"{ModernVisualEngine.format_command_execution(spider_command, 'STARTING')}\")\n                result = http_framework.spider_website(url, max_depth, max_pages)\n                # if result.get(\"success\"):\n                #     total_pages = result.get(\"total_pages\", 0)\n                #     pages_info = f\"{total_pages} pages\"\n                #     # logger.info(f\"{ModernVisualEngine.format_tool_status('HTTP-Spider', 'SUCCESS', pages_info)}\")\n                # else:\n                #     logger.error(f\"{ModernVisualEngine.format_tool_status('HTTP-Spider', 'FAILED', url)}\")\n                return result\n            elif action == \"proxy_history\":\n                return {\n    \n                    \"success\": True,\n                    \"history\": http_framework.proxy_history[-100:],  # Last 100 requests\n                    \"total_requests\": len(http_framework.proxy_history),\n                    \"vulnerabilities\": http_framework.vulnerabilities,\n                \n                }\n            elif action == \"set_rules\":\n                rules = data.get(\"rules\", [])\n                http_framework.set_match_replace_rules(rules)\n                return {\"success\": True, \"rules_set\": len(rules)}\n            elif action == \"set_scope\":\n                scope_host = data.get(\"host\")\n                include_sub = data.get(\"include_subdomains\", True)\n                if not scope_host:\n                    return {\"error\": \"host parameter required\"}\n                http_framework.set_scope(scope_host, include_sub)\n                return {\"success\": True, \"scope\": http_framework.scope}\n            elif action == \"repeater\":\n                request_spec = data.get(\"request\") or {}\n                result = http_framework.send_custom_request(request_spec)\n                return result\n            elif action == \"intruder\":\n                if not url:\n                    return {\"error\": \"URL parameter required\"}\n                method = data.get(\"method\", \"GET\")\n                location = data.get(\"location\", \"query\")\n                fuzz_params = data.get(\"params\", [])\n                payloads = data.get(\"payloads\", [])\n                base_data = data.get(\"base_data\", {})\n                max_requests = data.get(\"max_requests\", 100)\n                result = http_framework.intruder_sniper(\n                    url, method, location, fuzz_params, payloads, base_data, max_requests\n                )\n                return result\n            else:\n                return {\"error\": f\"Unknown action: {action}\"}\n        except Exception as e:\n            # logger.error(f\"{ModernVisualEngine.format_error_card('ERROR', 'HTTP-Framework', str(e))}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182571
    },
    {
      "id": "web_application_scanning-dirb_scan",
      "name": "Dirb Scan",
      "description": "Execute Dirb for directory brute forcing with enhanced logging. url: The target URL wordlist: Path to wordlist file additional_args: Additional Dirb arguments",
      "license": "MIT",
      "content": "---\nname: dirb_scan\ncapabilities: ['url', 'wordlist', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'dirb']\n---\n\n# Dirb Scan\n\nExecute Dirb for directory brute forcing with enhanced logging. url: The target URL wordlist: Path to wordlist file additional_args: Additional Dirb arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Path to wordlist file\n- **additional_args** (string, Optional): Additional Dirb arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/dirb`\n\n**Returns:** Scan results with enhanced telemetry\n\n## Files Included\n\n- `dirb_scan.yaml` - Tool configuration\n- `dirb_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: dirb_scan\ncapabilities: ['url', 'wordlist', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'dirb']\n---\n\n# Dirb Scan\n\nExecute Dirb for directory brute forcing with enhanced logging. url: The target URL wordlist: Path to wordlist file additional_args: Additional Dirb arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Path to wordlist file\n- **additional_args** (string, Optional): Additional Dirb arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/dirb`\n\n**Returns:** Scan results with enhanced telemetry\n\n## Files Included\n\n- `dirb_scan.yaml` - Tool configuration\n- `dirb_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "dirb_scan.yaml",
          "content": "name: dirb_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, dirb]\nendpoint: api/tools/dirb\ndescription: 'Execute Dirb for directory brute forcing with enhanced logging. url:\n  The target URL wordlist: Path to wordlist file additional_args: Additional Dirb\n  arguments'\nreturns: Scan results with enhanced telemetry\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL\n- name: wordlist\n  type: string\n  required: false\n  description: Path to wordlist file\n  default: /usr/share/wordlists/dirb/common.txt\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Dirb arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "dirb_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass DirbHandler(AbstractHandler):\n    \"\"\"Handler for dirb functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute dirb with enhanced logging\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            wordlist = data.get(\"wordlist\", \"/usr/share/wordlists/dirb/common.txt\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not url:\n                logger.warning(\"ðŸŒ Dirb called without URL parameter\")\n                return {\n    \n                    \"error\": \"URL parameter is required\"\n                \n                }\n            command = f\"dirb {url} {wordlist}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ“ Starting Dirb scan: {url}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Dirb scan completed for {url}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in dirb endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182572
    },
    {
      "id": "web_application_scanning-ffuf_scan",
      "name": "Ffuf Scan",
      "description": "Execute FFuf for web fuzzing with enhanced logging. url: The target URL wordlist: Wordlist file to use mode: Fuzzing mode (directory, vhost, parameter) match_codes: HTTP status codes to match additional_args: Additional FFuf arguments",
      "license": "MIT",
      "content": "---\nname: ffuf_scan\ncapabilities: ['url', 'wordlist', 'mode', 'match-codes', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'ffuf']\n---\n\n# Ffuf Scan\n\nExecute FFuf for web fuzzing with enhanced logging. url: The target URL wordlist: Wordlist file to use mode: Fuzzing mode (directory, vhost, parameter) match_codes: HTTP status codes to match additional_args: Additional FFuf arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Wordlist file to use\n- **mode** (string, Optional) (default: directory): Fuzzing mode (directory, vhost, parameter)\n- **match_codes** (string, Optional) (default: 200,204,301,302,307,401,403): HTTP status codes to match\n- **additional_args** (string, Optional): Additional FFuf arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/ffuf`\n\n**Returns:** Web fuzzing results\n\n## Files Included\n\n- `ffuf_scan.yaml` - Tool configuration\n- `ffuf_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: ffuf_scan\ncapabilities: ['url', 'wordlist', 'mode', 'match-codes', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'ffuf']\n---\n\n# Ffuf Scan\n\nExecute FFuf for web fuzzing with enhanced logging. url: The target URL wordlist: Wordlist file to use mode: Fuzzing mode (directory, vhost, parameter) match_codes: HTTP status codes to match additional_args: Additional FFuf arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Wordlist file to use\n- **mode** (string, Optional) (default: directory): Fuzzing mode (directory, vhost, parameter)\n- **match_codes** (string, Optional) (default: 200,204,301,302,307,401,403): HTTP status codes to match\n- **additional_args** (string, Optional): Additional FFuf arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/ffuf`\n\n**Returns:** Web fuzzing results\n\n## Files Included\n\n- `ffuf_scan.yaml` - Tool configuration\n- `ffuf_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "ffuf_scan.yaml",
          "content": "name: ffuf_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, ffuf]\nendpoint: api/tools/ffuf\ndescription: 'Execute FFuf for web fuzzing with enhanced logging. url: The target\n  URL wordlist: Wordlist file to use mode: Fuzzing mode (directory, vhost, parameter)\n  match_codes: HTTP status codes to match additional_args: Additional FFuf arguments'\nreturns: Web fuzzing results\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL\n- name: wordlist\n  type: string\n  required: false\n  description: Wordlist file to use\n  default: /usr/share/wordlists/dirb/common.txt\n- name: mode\n  type: string\n  required: false\n  description: Fuzzing mode (directory, vhost, parameter)\n  default: directory\n- name: match_codes\n  type: string\n  required: false\n  description: HTTP status codes to match\n  default: 200,204,301,302,307,401,403\n- name: additional_args\n  type: string\n  required: false\n  description: Additional FFuf arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "ffuf_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass FfufHandler(AbstractHandler):\n    \"\"\"Handler for ffuf functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute ffuf with enhanced logging\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            wordlist = data.get(\"wordlist\", \"/usr/share/wordlists/dirb/common.txt\")\n            mode = data.get(\"mode\", \"directory\")\n            match_codes = data.get(\"match_codes\", \"200,204,301,302,307,401,403\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not url:\n                logger.warning(\"ðŸŒ FFuf called without URL parameter\")\n                return {\n    \n                    \"error\": \"URL parameter is required\"\n                \n                }\n            command = f\"ffuf\"\n            if mode == \"directory\":\n                command += f\" -u {url}/FUZZ -w {wordlist}\"\n            elif mode == \"vhost\":\n                command += f\" -u {url} -H 'Host: FUZZ' -w {wordlist}\"\n            elif mode == \"parameter\":\n                command += f\" -u {url}?FUZZ=value -w {wordlist}\"\n            else:\n                command += f\" -u {url} -w {wordlist}\"\n            command += f\" -mc {match_codes}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting FFuf {mode} fuzzing: {url}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š FFuf fuzzing completed for {url}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in ffuf endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182573
    },
    {
      "id": "container_scanning-falco_runtime_monitoring",
      "name": "Falco Runtime Monitoring",
      "description": "Execute Falco for runtime security monitoring. config_file: Falco configuration file rules_file: Custom rules file output_format: Output format (json, text) duration: Monitoring duration in seconds additional_args: Additional Falco arguments",
      "license": "MIT",
      "content": "---\nname: falco_runtime_monitoring\ncapabilities: ['config-file', 'rules-file', 'output-format', 'duration', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'falco']\n---\n\n# Falco Runtime Monitoring\n\nExecute Falco for runtime security monitoring. config_file: Falco configuration file rules_file: Custom rules file output_format: Output format (json, text) duration: Monitoring duration in seconds additional_args: Additional Falco arguments\n\n## Parameters\n- **config_file** (string, Optional) (default: /etc/falco/falco.yaml): Falco configuration file\n- **rules_file** (string, Optional): Custom rules file\n- **output_format** (string, Optional) (default: json): Output format (json, text)\n- **duration** (integer, Optional) (default: 60): Monitoring duration in seconds\n- **additional_args** (string, Optional): Additional Falco arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/falco`\n\n**Returns:** Runtime security monitoring results\n\n## Files Included\n\n- `falco_runtime_monitoring.yaml` - Tool configuration\n- `falco_runtime_monitoring.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: falco_runtime_monitoring\ncapabilities: ['config-file', 'rules-file', 'output-format', 'duration', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'falco']\n---\n\n# Falco Runtime Monitoring\n\nExecute Falco for runtime security monitoring. config_file: Falco configuration file rules_file: Custom rules file output_format: Output format (json, text) duration: Monitoring duration in seconds additional_args: Additional Falco arguments\n\n## Parameters\n- **config_file** (string, Optional) (default: /etc/falco/falco.yaml): Falco configuration file\n- **rules_file** (string, Optional): Custom rules file\n- **output_format** (string, Optional) (default: json): Output format (json, text)\n- **duration** (integer, Optional) (default: 60): Monitoring duration in seconds\n- **additional_args** (string, Optional): Additional Falco arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/falco`\n\n**Returns:** Runtime security monitoring results\n\n## Files Included\n\n- `falco_runtime_monitoring.yaml` - Tool configuration\n- `falco_runtime_monitoring.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "falco_runtime_monitoring.yaml",
          "content": "name: falco_runtime_monitoring\ncategory: container_scanning\ntags: [vulnerability_assessment, penetration_testing, falco]\nendpoint: api/tools/falco\ndescription: 'Execute Falco for runtime security monitoring. config_file: Falco configuration\n  file rules_file: Custom rules file output_format: Output format (json, text) duration:\n  Monitoring duration in seconds additional_args: Additional Falco arguments'\nreturns: Runtime security monitoring results\nparameters:\n- name: config_file\n  type: string\n  required: false\n  description: Falco configuration file\n  default: /etc/falco/falco.yaml\n- name: rules_file\n  type: string\n  required: false\n  description: Custom rules file\n  default: ''\n- name: output_format\n  type: string\n  required: false\n  description: Output format (json, text)\n  default: json\n- name: duration\n  type: integer\n  required: false\n  description: Monitoring duration in seconds\n  default: 60\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Falco arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "falco_runtime_monitoring.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass FalcoHandler(AbstractHandler):\n    \"\"\"Handler for falco functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute falco with enhanced logging\"\"\"\n        try:\n            config_file = data.get(\"config_file\", \"/etc/falco/falco.yaml\")\n            rules_file = data.get(\"rules_file\", \"\")\n            output_format = data.get(\"output_format\", \"json\")\n            duration = data.get(\"duration\", 60)  # seconds\n            additional_args = data.get(\"additional_args\", \"\")\n            command = f\"timeout {duration} falco\"\n            if config_file:\n                command += f\" --config {config_file}\"\n            if rules_file:\n                command += f\" --rules {rules_file}\"\n            if output_format == \"json\":\n                command += \" --json\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ›¡ï¸  Starting Falco runtime monitoring for {duration}s\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Falco monitoring completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in falco endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182575
    },
    {
      "id": "container_scanning-trivy_scan",
      "name": "Trivy Scan",
      "description": "Execute Trivy for container and filesystem vulnerability scanning. scan_type: Type of scan (image, fs, repo, config) target: Target to scan (image name, directory, repository) output_format: Output format (json, table, sarif) severity: Severity filter (UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL) output_file: File to save results additional_args: Additional Trivy arguments",
      "license": "MIT",
      "content": "---\nname: trivy_scan\ncapabilities: ['scan-type', 'target', 'output-format', 'severity', 'output-file', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'trivy']\n---\n\n# Trivy Scan\n\nExecute Trivy for container and filesystem vulnerability scanning. scan_type: Type of scan (image, fs, repo, config) target: Target to scan (image name, directory, repository) output_format: Output format (json, table, sarif) severity: Severity filter (UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL) output_file: File to save results additional_args: Additional Trivy arguments\n\n## Parameters\n- **scan_type** (string, Optional) (default: image): Type of scan (image, fs, repo, config)\n- **target** (string, Optional): Target to scan (image name, directory, repository)\n- **output_format** (string, Optional) (default: json): Output format (json, table, sarif)\n- **severity** (string, Optional): Severity filter (UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL)\n- **output_file** (string, Optional): File to save results\n- **additional_args** (string, Optional): Additional Trivy arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/trivy`\n\n**Returns:** Vulnerability scan results\n\n## Files Included\n\n- `trivy_scan.yaml` - Tool configuration\n- `trivy_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: trivy_scan\ncapabilities: ['scan-type', 'target', 'output-format', 'severity', 'output-file', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'trivy']\n---\n\n# Trivy Scan\n\nExecute Trivy for container and filesystem vulnerability scanning. scan_type: Type of scan (image, fs, repo, config) target: Target to scan (image name, directory, repository) output_format: Output format (json, table, sarif) severity: Severity filter (UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL) output_file: File to save results additional_args: Additional Trivy arguments\n\n## Parameters\n- **scan_type** (string, Optional) (default: image): Type of scan (image, fs, repo, config)\n- **target** (string, Optional): Target to scan (image name, directory, repository)\n- **output_format** (string, Optional) (default: json): Output format (json, table, sarif)\n- **severity** (string, Optional): Severity filter (UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL)\n- **output_file** (string, Optional): File to save results\n- **additional_args** (string, Optional): Additional Trivy arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/trivy`\n\n**Returns:** Vulnerability scan results\n\n## Files Included\n\n- `trivy_scan.yaml` - Tool configuration\n- `trivy_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "trivy_scan.yaml",
          "content": "name: trivy_scan\ncategory: container_scanning\ntags: [vulnerability_assessment, penetration_testing, trivy]\nendpoint: api/tools/trivy\ndescription: 'Execute Trivy for container and filesystem vulnerability scanning. scan_type:\n  Type of scan (image, fs, repo, config) target: Target to scan (image name, directory,\n  repository) output_format: Output format (json, table, sarif) severity: Severity\n  filter (UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL) output_file: File to save results additional_args:\n  Additional Trivy arguments'\nreturns: Vulnerability scan results\nparameters:\n- name: scan_type\n  type: string\n  required: false\n  description: Type of scan (image, fs, repo, config)\n  default: image\n- name: target\n  type: string\n  required: false\n  description: Target to scan (image name, directory, repository)\n  default: ''\n- name: output_format\n  type: string\n  required: false\n  description: Output format (json, table, sarif)\n  default: json\n- name: severity\n  type: string\n  required: false\n  description: Severity filter (UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL)\n  default: ''\n- name: output_file\n  type: string\n  required: false\n  description: File to save results\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Trivy arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "trivy_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass TrivyHandler(AbstractHandler):\n    \"\"\"Handler for trivy functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute trivy with enhanced logging\"\"\"\n        try:\n            scan_type = data.get(\"scan_type\", \"image\")  # image, fs, repo\n            target = data.get(\"target\", \"\")\n            output_format = data.get(\"output_format\", \"json\")\n            severity = data.get(\"severity\", \"\")\n            output_file = data.get(\"output_file\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ Trivy called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"trivy {scan_type} {target}\"\n            if output_format:\n                command += f\" --format {output_format}\"\n            if severity:\n                command += f\" --severity {severity}\"\n            if output_file:\n                command += f\" --output {output_file}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Trivy {scan_type} scan: {target}\")\n            result = execute_command(command)\n            if output_file:\n                result[\"output_file\"] = output_file\n            logger.info(f\"ðŸ“Š Trivy scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in trivy endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182577
    },
    {
      "id": "container_scanning-docker_bench_security_scan",
      "name": "Docker Bench Security Scan",
      "description": "Execute Docker Bench for Security for Docker security assessment. checks: Specific checks to run exclude: Checks to exclude output_file: Output file path additional_args: Additional Docker Bench arguments",
      "license": "MIT",
      "content": "---\nname: docker_bench_security_scan\ncapabilities: ['checks', 'exclude', 'output-file', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'docker']\n---\n\n# Docker Bench Security Scan\n\nExecute Docker Bench for Security for Docker security assessment. checks: Specific checks to run exclude: Checks to exclude output_file: Output file path additional_args: Additional Docker Bench arguments\n\n## Parameters\n- **checks** (string, Optional): Specific checks to run\n- **exclude** (string, Optional): Checks to exclude\n- **output_file** (string, Optional) (default: /tmp/docker-bench-results.json): Output file path\n- **additional_args** (string, Optional): Additional Docker Bench arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/docker-bench-security`\n\n**Returns:** Docker security assessment results\n\n## Files Included\n\n- `docker_bench_security_scan.yaml` - Tool configuration\n- `docker_bench_security_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: docker_bench_security_scan\ncapabilities: ['checks', 'exclude', 'output-file', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'docker']\n---\n\n# Docker Bench Security Scan\n\nExecute Docker Bench for Security for Docker security assessment. checks: Specific checks to run exclude: Checks to exclude output_file: Output file path additional_args: Additional Docker Bench arguments\n\n## Parameters\n- **checks** (string, Optional): Specific checks to run\n- **exclude** (string, Optional): Checks to exclude\n- **output_file** (string, Optional) (default: /tmp/docker-bench-results.json): Output file path\n- **additional_args** (string, Optional): Additional Docker Bench arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/docker-bench-security`\n\n**Returns:** Docker security assessment results\n\n## Files Included\n\n- `docker_bench_security_scan.yaml` - Tool configuration\n- `docker_bench_security_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "docker_bench_security_scan.yaml",
          "content": "name: docker_bench_security_scan\ncategory: container_scanning\ntags: [vulnerability_assessment, penetration_testing, docker]\nendpoint: api/tools/docker-bench-security\ndescription: 'Execute Docker Bench for Security for Docker security assessment. checks:\n  Specific checks to run exclude: Checks to exclude output_file: Output file path\n  additional_args: Additional Docker Bench arguments'\nreturns: Docker security assessment results\nparameters:\n- name: checks\n  type: string\n  required: false\n  description: Specific checks to run\n  default: ''\n- name: exclude\n  type: string\n  required: false\n  description: Checks to exclude\n  default: ''\n- name: output_file\n  type: string\n  required: false\n  description: Output file path\n  default: /tmp/docker-bench-results.json\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Docker Bench arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "docker_bench_security_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass DockerBenchSecurityHandler(AbstractHandler):\n    \"\"\"Handler for docker_bench_security functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute docker_bench_security with enhanced logging\"\"\"\n        try:\n            checks = data.get(\"checks\", \"\")  # Specific checks to run\n            exclude = data.get(\"exclude\", \"\")  # Checks to exclude\n            output_file = data.get(\"output_file\", \"/tmp/docker-bench-results.json\")\n            additional_args = data.get(\"additional_args\", \"\")\n            command = \"docker-bench-security\"\n            if checks:\n                command += f\" -c {checks}\"\n            if exclude:\n                command += f\" -e {exclude}\"\n            if output_file:\n                command += f\" -l {output_file}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ³ Starting Docker Bench Security assessment\")\n            result = execute_command(command)\n            result[\"output_file\"] = output_file\n            logger.info(f\"ðŸ“Š Docker Bench Security completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in docker-bench-security endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182578
    },
    {
      "id": "container_scanning-checkov_iac_scan",
      "name": "Checkov Iac Scan",
      "description": "Execute Checkov for infrastructure as code security scanning. directory: Directory to scan framework: Framework to scan (terraform, cloudformation, kubernetes, etc.) check: Specific check to run skip_check: Check to skip output_format: Output format (json, yaml, cli) additional_args: Additional Checkov arguments",
      "license": "MIT",
      "content": "---\nname: checkov_iac_scan\ncapabilities: ['directory', 'framework', 'check', 'skip-check', 'output-format', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'checkov']\n---\n\n# Checkov Iac Scan\n\nExecute Checkov for infrastructure as code security scanning. directory: Directory to scan framework: Framework to scan (terraform, cloudformation, kubernetes, etc.) check: Specific check to run skip_check: Check to skip output_format: Output format (json, yaml, cli) additional_args: Additional Checkov arguments\n\n## Parameters\n- **directory** (string, Optional) (default: .): Directory to scan\n- **framework** (string, Optional): Framework to scan (terraform, cloudformation, kubernetes, etc.)\n- **check** (string, Optional): Specific check to run\n- **skip_check** (string, Optional): Check to skip\n- **output_format** (string, Optional) (default: json): Output format (json, yaml, cli)\n- **additional_args** (string, Optional): Additional Checkov arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/checkov`\n\n**Returns:** Infrastructure as code security scanning results\n\n## Files Included\n\n- `checkov_iac_scan.yaml` - Tool configuration\n- `checkov_iac_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: checkov_iac_scan\ncapabilities: ['directory', 'framework', 'check', 'skip-check', 'output-format', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'checkov']\n---\n\n# Checkov Iac Scan\n\nExecute Checkov for infrastructure as code security scanning. directory: Directory to scan framework: Framework to scan (terraform, cloudformation, kubernetes, etc.) check: Specific check to run skip_check: Check to skip output_format: Output format (json, yaml, cli) additional_args: Additional Checkov arguments\n\n## Parameters\n- **directory** (string, Optional) (default: .): Directory to scan\n- **framework** (string, Optional): Framework to scan (terraform, cloudformation, kubernetes, etc.)\n- **check** (string, Optional): Specific check to run\n- **skip_check** (string, Optional): Check to skip\n- **output_format** (string, Optional) (default: json): Output format (json, yaml, cli)\n- **additional_args** (string, Optional): Additional Checkov arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/checkov`\n\n**Returns:** Infrastructure as code security scanning results\n\n## Files Included\n\n- `checkov_iac_scan.yaml` - Tool configuration\n- `checkov_iac_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "checkov_iac_scan.yaml",
          "content": "name: checkov_iac_scan\ncategory: container_scanning\ntags: [vulnerability_assessment, penetration_testing, checkov]\nendpoint: api/tools/checkov\ndescription: 'Execute Checkov for infrastructure as code security scanning. directory:\n  Directory to scan framework: Framework to scan (terraform, cloudformation, kubernetes,\n  etc.) check: Specific check to run skip_check: Check to skip output_format: Output\n  format (json, yaml, cli) additional_args: Additional Checkov arguments'\nreturns: Infrastructure as code security scanning results\nparameters:\n- name: directory\n  type: string\n  required: false\n  description: Directory to scan\n  default: .\n- name: framework\n  type: string\n  required: false\n  description: Framework to scan (terraform, cloudformation, kubernetes, etc.)\n  default: ''\n- name: check\n  type: string\n  required: false\n  description: Specific check to run\n  default: ''\n- name: skip_check\n  type: string\n  required: false\n  description: Check to skip\n  default: ''\n- name: output_format\n  type: string\n  required: false\n  description: Output format (json, yaml, cli)\n  default: json\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Checkov arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "checkov_iac_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass CheckovHandler(AbstractHandler):\n    \"\"\"Handler for checkov functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute checkov with enhanced logging\"\"\"\n        try:\n            directory = data.get(\"directory\", \".\")\n            framework = data.get(\"framework\", \"\")  # terraform, cloudformation, kubernetes, etc.\n            check = data.get(\"check\", \"\")\n            skip_check = data.get(\"skip_check\", \"\")\n            output_format = data.get(\"output_format\", \"json\")\n            additional_args = data.get(\"additional_args\", \"\")\n            command = f\"checkov -d {directory}\"\n            if framework:\n                command += f\" --framework {framework}\"\n            if check:\n                command += f\" --check {check}\"\n            if skip_check:\n                command += f\" --skip-check {skip_check}\"\n            if output_format:\n                command += f\" --output {output_format}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Checkov IaC scan: {directory}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Checkov scan completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in checkov endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182580
    },
    {
      "id": "container_scanning-kube_bench_cis",
      "name": "Kube Bench Cis",
      "description": "Execute kube-bench for CIS Kubernetes benchmark checks. targets: Targets to check (master, node, etcd, policies) version: Kubernetes version config_dir: Configuration directory output_format: Output format (json, yaml) additional_args: Additional kube-bench arguments",
      "license": "MIT",
      "content": "---\nname: kube_bench_cis\ncapabilities: ['targets', 'version', 'config-dir', 'output-format', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'cis', 'kubernetes', 'kube_bench']\n---\n\n# Kube Bench Cis\n\nExecute kube-bench for CIS Kubernetes benchmark checks. targets: Targets to check (master, node, etcd, policies) version: Kubernetes version config_dir: Configuration directory output_format: Output format (json, yaml) additional_args: Additional kube-bench arguments\n\n## Parameters\n- **targets** (string, Optional): Targets to check (master, node, etcd, policies)\n- **version** (string, Optional): Kubernetes version\n- **config_dir** (string, Optional): Configuration directory\n- **output_format** (string, Optional) (default: json): Output format (json, yaml)\n- **additional_args** (string, Optional): Additional kube-bench arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/kube-bench`\n\n**Returns:** CIS Kubernetes benchmark results\n\n## Files Included\n\n- `kube_bench_cis.yaml` - Tool configuration\n- `kube_bench_cis.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: kube_bench_cis\ncapabilities: ['targets', 'version', 'config-dir', 'output-format', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'cis', 'kubernetes', 'kube_bench']\n---\n\n# Kube Bench Cis\n\nExecute kube-bench for CIS Kubernetes benchmark checks. targets: Targets to check (master, node, etcd, policies) version: Kubernetes version config_dir: Configuration directory output_format: Output format (json, yaml) additional_args: Additional kube-bench arguments\n\n## Parameters\n- **targets** (string, Optional): Targets to check (master, node, etcd, policies)\n- **version** (string, Optional): Kubernetes version\n- **config_dir** (string, Optional): Configuration directory\n- **output_format** (string, Optional) (default: json): Output format (json, yaml)\n- **additional_args** (string, Optional): Additional kube-bench arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/kube-bench`\n\n**Returns:** CIS Kubernetes benchmark results\n\n## Files Included\n\n- `kube_bench_cis.yaml` - Tool configuration\n- `kube_bench_cis.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "kube_bench_cis.yaml",
          "content": "name: kube_bench_cis\ncategory: container_scanning\ntags: [vulnerability_assessment, penetration_testing, cis, kubernetes, kube_bench]\nendpoint: api/tools/kube-bench\ndescription: 'Execute kube-bench for CIS Kubernetes benchmark checks. targets: Targets\n  to check (master, node, etcd, policies) version: Kubernetes version config_dir:\n  Configuration directory output_format: Output format (json, yaml) additional_args:\n  Additional kube-bench arguments'\nreturns: CIS Kubernetes benchmark results\nparameters:\n- name: targets\n  type: string\n  required: false\n  description: Targets to check (master, node, etcd, policies)\n  default: ''\n- name: version\n  type: string\n  required: false\n  description: Kubernetes version\n  default: ''\n- name: config_dir\n  type: string\n  required: false\n  description: Configuration directory\n  default: ''\n- name: output_format\n  type: string\n  required: false\n  description: Output format (json, yaml)\n  default: json\n- name: additional_args\n  type: string\n  required: false\n  description: Additional kube-bench arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "kube_bench_cis.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass KubeBenchHandler(AbstractHandler):\n    \"\"\"Handler for kube_bench functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute kube_bench with enhanced logging\"\"\"\n        try:\n            targets = data.get(\"targets\", \"\")  # master, node, etcd, policies\n            version = data.get(\"version\", \"\")\n            config_dir = data.get(\"config_dir\", \"\")\n            output_format = data.get(\"output_format\", \"json\")\n            additional_args = data.get(\"additional_args\", \"\")\n            command = \"kube-bench\"\n            if targets:\n                command += f\" --targets {targets}\"\n            if version:\n                command += f\" --version {version}\"\n            if config_dir:\n                command += f\" --config-dir {config_dir}\"\n            if output_format:\n                command += f\" --outputfile /tmp/kube-bench-results.{output_format} --json\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"â˜ï¸  Starting kube-bench CIS benchmark\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š kube-bench benchmark completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in kube-bench endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182581
    },
    {
      "id": "container_scanning-kube_hunter_scan",
      "name": "Kube Hunter Scan",
      "description": "Execute kube-hunter for Kubernetes penetration testing. target: Specific target to scan remote: Remote target to scan cidr: CIDR range to scan interface: Network interface to scan active: Enable active hunting (potentially harmful) report: Report format (json, yaml) additional_args: Additional kube-hunter arguments",
      "license": "MIT",
      "content": "---\nname: kube_hunter_scan\ncapabilities: ['target', 'remote', 'cidr', 'interface', 'active', 'report', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'kubernetes', 'kube_hunter']\n---\n\n# Kube Hunter Scan\n\nExecute kube-hunter for Kubernetes penetration testing. target: Specific target to scan remote: Remote target to scan cidr: CIDR range to scan interface: Network interface to scan active: Enable active hunting (potentially harmful) report: Report format (json, yaml) additional_args: Additional kube-hunter arguments\n\n## Parameters\n- **target** (string, Optional): Specific target to scan\n- **remote** (string, Optional): Remote target to scan\n- **cidr** (string, Optional): CIDR range to scan\n- **interface** (string, Optional): Network interface to scan\n- **active** (boolean, Optional): Enable active hunting (potentially harmful)\n- **report** (string, Optional) (default: json): Report format (json, yaml)\n- **additional_args** (string, Optional): Additional kube-hunter arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/kube-hunter`\n\n**Returns:** Kubernetes penetration testing results\n\n## Files Included\n\n- `kube_hunter_scan.yaml` - Tool configuration\n- `kube_hunter_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: kube_hunter_scan\ncapabilities: ['target', 'remote', 'cidr', 'interface', 'active', 'report', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'kubernetes', 'kube_hunter']\n---\n\n# Kube Hunter Scan\n\nExecute kube-hunter for Kubernetes penetration testing. target: Specific target to scan remote: Remote target to scan cidr: CIDR range to scan interface: Network interface to scan active: Enable active hunting (potentially harmful) report: Report format (json, yaml) additional_args: Additional kube-hunter arguments\n\n## Parameters\n- **target** (string, Optional): Specific target to scan\n- **remote** (string, Optional): Remote target to scan\n- **cidr** (string, Optional): CIDR range to scan\n- **interface** (string, Optional): Network interface to scan\n- **active** (boolean, Optional): Enable active hunting (potentially harmful)\n- **report** (string, Optional) (default: json): Report format (json, yaml)\n- **additional_args** (string, Optional): Additional kube-hunter arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/kube-hunter`\n\n**Returns:** Kubernetes penetration testing results\n\n## Files Included\n\n- `kube_hunter_scan.yaml` - Tool configuration\n- `kube_hunter_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "kube_hunter_scan.yaml",
          "content": "name: kube_hunter_scan\ncategory: container_scanning\ntags: [vulnerability_assessment, penetration_testing, kubernetes, kube_hunter]\nendpoint: api/tools/kube-hunter\ndescription: 'Execute kube-hunter for Kubernetes penetration testing. target: Specific\n  target to scan remote: Remote target to scan cidr: CIDR range to scan interface:\n  Network interface to scan active: Enable active hunting (potentially harmful) report:\n  Report format (json, yaml) additional_args: Additional kube-hunter arguments'\nreturns: Kubernetes penetration testing results\nparameters:\n- name: target\n  type: string\n  required: false\n  description: Specific target to scan\n  default: ''\n- name: remote\n  type: string\n  required: false\n  description: Remote target to scan\n  default: ''\n- name: cidr\n  type: string\n  required: false\n  description: CIDR range to scan\n  default: ''\n- name: interface\n  type: string\n  required: false\n  description: Network interface to scan\n  default: ''\n- name: active\n  type: boolean\n  required: false\n  description: Enable active hunting (potentially harmful)\n  default: false\n- name: report\n  type: string\n  required: false\n  description: Report format (json, yaml)\n  default: json\n- name: additional_args\n  type: string\n  required: false\n  description: Additional kube-hunter arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "kube_hunter_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass KubeHunterHandler(AbstractHandler):\n    \"\"\"Handler for kube_hunter functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute kube_hunter with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            remote = data.get(\"remote\", \"\")\n            cidr = data.get(\"cidr\", \"\")\n            interface = data.get(\"interface\", \"\")\n            active = data.get(\"active\", False)\n            report = data.get(\"report\", \"json\")\n            additional_args = data.get(\"additional_args\", \"\")\n            command = \"kube-hunter\"\n            if target:\n                command += f\" --remote {target}\"\n            elif remote:\n                command += f\" --remote {remote}\"\n            elif cidr:\n                command += f\" --cidr {cidr}\"\n            elif interface:\n                command += f\" --interface {interface}\"\n            else:\n                command += \" --pod\"\n            if active:\n                command += \" --active\"\n            if report:\n                command += f\" --report {report}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"â˜ï¸  Starting kube-hunter Kubernetes scan\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š kube-hunter scan completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in kube-hunter endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182582
    },
    {
      "id": "container_scanning-terrascan_iac_scan",
      "name": "Terrascan Iac Scan",
      "description": "Execute Terrascan for infrastructure as code security scanning. scan_type: Type of scan (all, terraform, k8s, etc.) iac_dir: Infrastructure as code directory policy_type: Policy type to use output_format: Output format (json, yaml, xml) severity: Severity filter (high, medium, low) additional_args: Additional Terrascan arguments",
      "license": "MIT",
      "content": "---\nname: terrascan_iac_scan\ncapabilities: ['scan-type', 'iac-dir', 'policy-type', 'output-format', 'severity', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'terrascan']\n---\n\n# Terrascan Iac Scan\n\nExecute Terrascan for infrastructure as code security scanning. scan_type: Type of scan (all, terraform, k8s, etc.) iac_dir: Infrastructure as code directory policy_type: Policy type to use output_format: Output format (json, yaml, xml) severity: Severity filter (high, medium, low) additional_args: Additional Terrascan arguments\n\n## Parameters\n- **scan_type** (string, Optional) (default: all): Type of scan (all, terraform, k8s, etc.)\n- **iac_dir** (string, Optional) (default: .): Infrastructure as code directory\n- **policy_type** (string, Optional): Policy type to use\n- **output_format** (string, Optional) (default: json): Output format (json, yaml, xml)\n- **severity** (string, Optional): Severity filter (high, medium, low)\n- **additional_args** (string, Optional): Additional Terrascan arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/terrascan`\n\n**Returns:** Infrastructure as code security scanning results\n\n## Files Included\n\n- `terrascan_iac_scan.yaml` - Tool configuration\n- `terrascan_iac_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: terrascan_iac_scan\ncapabilities: ['scan-type', 'iac-dir', 'policy-type', 'output-format', 'severity', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'terrascan']\n---\n\n# Terrascan Iac Scan\n\nExecute Terrascan for infrastructure as code security scanning. scan_type: Type of scan (all, terraform, k8s, etc.) iac_dir: Infrastructure as code directory policy_type: Policy type to use output_format: Output format (json, yaml, xml) severity: Severity filter (high, medium, low) additional_args: Additional Terrascan arguments\n\n## Parameters\n- **scan_type** (string, Optional) (default: all): Type of scan (all, terraform, k8s, etc.)\n- **iac_dir** (string, Optional) (default: .): Infrastructure as code directory\n- **policy_type** (string, Optional): Policy type to use\n- **output_format** (string, Optional) (default: json): Output format (json, yaml, xml)\n- **severity** (string, Optional): Severity filter (high, medium, low)\n- **additional_args** (string, Optional): Additional Terrascan arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/terrascan`\n\n**Returns:** Infrastructure as code security scanning results\n\n## Files Included\n\n- `terrascan_iac_scan.yaml` - Tool configuration\n- `terrascan_iac_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "terrascan_iac_scan.yaml",
          "content": "name: terrascan_iac_scan\ncategory: container_scanning\ntags: [vulnerability_assessment, penetration_testing, terrascan]\nendpoint: api/tools/terrascan\ndescription: 'Execute Terrascan for infrastructure as code security scanning. scan_type:\n  Type of scan (all, terraform, k8s, etc.) iac_dir: Infrastructure as code directory\n  policy_type: Policy type to use output_format: Output format (json, yaml, xml) severity:\n  Severity filter (high, medium, low) additional_args: Additional Terrascan arguments'\nreturns: Infrastructure as code security scanning results\nparameters:\n- name: scan_type\n  type: string\n  required: false\n  description: Type of scan (all, terraform, k8s, etc.)\n  default: all\n- name: iac_dir\n  type: string\n  required: false\n  description: Infrastructure as code directory\n  default: .\n- name: policy_type\n  type: string\n  required: false\n  description: Policy type to use\n  default: ''\n- name: output_format\n  type: string\n  required: false\n  description: Output format (json, yaml, xml)\n  default: json\n- name: severity\n  type: string\n  required: false\n  description: Severity filter (high, medium, low)\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Terrascan arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "terrascan_iac_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass TerrascanHandler(AbstractHandler):\n    \"\"\"Handler for terrascan functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute terrascan with enhanced logging\"\"\"\n        try:\n            scan_type = data.get(\"scan_type\", \"all\")  # all, terraform, k8s, etc.\n            iac_dir = data.get(\"iac_dir\", \".\")\n            policy_type = data.get(\"policy_type\", \"\")\n            output_format = data.get(\"output_format\", \"json\")\n            severity = data.get(\"severity\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            command = f\"terrascan scan -t {scan_type} -d {iac_dir}\"\n            if policy_type:\n                command += f\" -p {policy_type}\"\n            if output_format:\n                command += f\" -o {output_format}\"\n            if severity:\n                command += f\" --severity {severity}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Terrascan IaC scan: {iac_dir}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Terrascan scan completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in terrascan endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767081182584
    }
  ],
  "total": 60,
  "scanned": 60,
  "categories": [
    "credential_testing",
    "network_scanning",
    "authentication_bypass",
    "binary_vulnerability_analysis",
    "subdomain_enumeration",
    "password_cracking",
    "binary_exploitation",
    "osint_gathering",
    "container_scanning",
    "web_security",
    "web_application_scanning"
  ],
  "generated_at": "2025-12-30T15:53:02.584305"
}
