# yamllint disable
# License: Commons Clause License Condition v1.0[LGPL-2.1-only]
# https://github.com/semgrep/semgrep-rules/blob/release/java/lang/security/audit/crypto/use-of-rc2.yaml
# yamllint enable
---
rules:
  - id: java_crypto_rule-UseOfRC2
    languages:
      - java
    pattern-either:
      - pattern: |
          javax.crypto.Cipher.getInstance("RC2")
      - patterns:
          - pattern-inside: |
              class $CLS{
                ...
                String $ALG = "RC2";
                ...
              }
          - pattern: |
              javax.crypto.Cipher.getInstance($ALG);
    message: |
      Use of RC2, a deprecated cryptographic algorithm vulnerable to related-key
      attacks, was detected. Modern cryptographic standards recommend the
      adoption of algorithms that integrate message integrity to ensure the
      ciphertext remains unaltered.

      To mitigate the issue, use any of the below algorithms instead:
      1. `ChaCha20Poly1305` - Preferred for its simplicity and speed, suitable for 
      environments where cryptographic acceleration is absent.
      2. `AES-256-GCM` - Highly recommended when hardware support is available, 
      despite being somewhat slower than `ChaCha20Poly1305`. It is crucial to avoid 
      nonce reuse with AES-256-GCM to prevent security compromises.

      Secure code example using `ChaCha20Poly1305` in Java:
      ```
      public void encryptAndDecrypt() throws Exception {
          SecureRandom random = new SecureRandom();
          byte[] secretKey = new byte[32];  // 256-bit key
          byte[] nonce = new byte[12];      // 96-bit nonce
          random.nextBytes(secretKey);
          random.nextBytes(nonce);

          Cipher cipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
          SecretKeySpec keySpec = new SecretKeySpec(secretKey, "ChaCha20");
          GCMParameterSpec spec = new GCMParameterSpec(128, nonce);

          cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
          byte[] plaintext = "Secret text".getBytes(StandardCharsets.UTF_8);
          byte[] ciphertext = cipher.doFinal(plaintext);
          System.out.println("Encrypted: " + Base64.getEncoder().encodeToString(ciphertext));

          cipher.init(Cipher.DECRYPT_MODE, keySpec, spec);
          byte[] decrypted = cipher.doFinal(ciphertext);
          System.out.println("Decrypted: " + new String(decrypted, StandardCharsets.UTF_8));
      }
      ```
      For more on Java Cryptography, refer:
      https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
    severity: "WARNING"
    metadata:
      shortDescription: "Use of a broken or risky cryptographic algorithm"
      category: "security"
      cwe: "CWE-327"
      owasp:
        - "A3:2017-Sensitive Data Exposure"
        - "A02:2021-Cryptographic Failures"
      technology:
        - "java"
      security-severity: "MEDIUM"
      references:
        - "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
      subcategory:
        - "vuln"
      likelihood: "MEDIUM"
      impact: "MEDIUM"
      confidence: "HIGH"
