# yamllint disable
# License: Commons Clause License Condition v1.0[LGPL-2.1-only]
# https://github.com/semgrep/semgrep-rules/blob/release/java/lang/security/audit/crypto/use-of-rc4.yaml
# yamllint enable
---
rules:
  - id: java_crypto_rule-UseOfRC4
    languages:
      - java
    pattern-either:
      - pattern: |
          javax.crypto.Cipher.getInstance("RC4")
      - patterns:
          - pattern-inside: |
              class $CLS{
                ...
                String $ALG = "RC4";
                ...
              }
          - pattern: |
              javax.crypto.Cipher.getInstance($ALG);
    message: |
      Use of RC4 was detected. RC4 is vulnerable to several types of attacks,
      including stream cipher attacks where attackers can recover plaintexts by
      analyzing a large number of encrypted messages, and bit-flipping attacks
      that can alter messages without knowing the encryption key.

      To mitigate the issue, use any of the below algorithms instead:
      1. `ChaCha20Poly1305` - Preferred for its simplicity and speed, suitable for 
      environments where cryptographic acceleration is absent.
      2. `AES-256-GCM` - Highly recommended when hardware support is available, 
      despite being somewhat slower than `ChaCha20Poly1305`. It is crucial to avoid 
      nonce reuse with AES-256-GCM to prevent security compromises.

      Secure code example using `ChaCha20Poly1305` in Java:
      ```
      public void encryptAndDecrypt() throws Exception {
          SecureRandom random = new SecureRandom();
          byte[] secretKey = new byte[32];  // 256-bit key
          byte[] nonce = new byte[12];      // 96-bit nonce
          random.nextBytes(secretKey);
          random.nextBytes(nonce);

          Cipher cipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
          SecretKeySpec keySpec = new SecretKeySpec(secretKey, "ChaCha20");
          GCMParameterSpec spec = new GCMParameterSpec(128, nonce);

          cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);
          byte[] plaintext = "Secret text".getBytes(StandardCharsets.UTF_8);
          byte[] ciphertext = cipher.doFinal(plaintext);
          System.out.println("Encrypted: " + Base64.getEncoder().encodeToString(ciphertext));

          cipher.init(Cipher.DECRYPT_MODE, keySpec, spec);
          byte[] decrypted = cipher.doFinal(ciphertext);
          System.out.println("Decrypted: " + new String(decrypted, StandardCharsets.UTF_8));
      }
      ```
      For more information, refer:
      https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions
    severity: "WARNING"
    metadata:
      shortDescription: "Use of a broken or risky cryptographic algorithm"
      category: "security"
      cwe: "CWE-327"
      owasp:
        - "A3:2017-Sensitive Data Exposure"
        - "A02:2021-Cryptographic Failures"
      technology:
        - "java"
      security-severity: "MEDIUM"
      references:
        - "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        - "https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html"
      subcategory:
        - "vuln"
      likelihood: "MEDIUM"
      impact: "MEDIUM"
      confidence: "HIGH"
