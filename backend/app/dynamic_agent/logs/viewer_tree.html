<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Interaction Viewer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #1a1a2e;
            color: #eee;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        h1 {
            color: #00d9ff;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .controls button, .controls select {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .controls select {
            background: #2d2d44;
            color: #eee;
            min-width: 150px;
        }
        
        .controls button {
            background: #4a4a6a;
            color: #eee;
        }
        
        .controls button:hover {
            background: #5a5a7a;
        }
        
        .controls button.primary {
            background: #00d9ff;
            color: #1a1a2e;
            font-weight: 600;
        }
        
        .controls button.primary:hover {
            background: #00b8d9;
        }
        
        .search-box {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #2d2d44;
            padding: 8px 15px;
            border-radius: 6px;
        }
        
        .search-box input {
            background: transparent;
            border: none;
            color: #eee;
            font-size: 14px;
            width: 200px;
            outline: none;
        }
        
        .search-box input::placeholder {
            color: #666;
        }
        
        .match-count {
            font-size: 12px;
            color: #00d9ff;
            padding: 2px 8px;
            background: rgba(0, 217, 255, 0.2);
            border-radius: 4px;
        }
        
        .nav-btn {
            background: #4a4a6a;
            color: #eee;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            min-width: 28px;
        }
        
        .nav-btn:hover {
            background: #5a5a7a;
        }
        
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #888;
        }
        
        .auto-refresh input {
            width: 16px;
            height: 16px;
        }
        
        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .view-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #3a3a5a;
            color: #888;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .view-btn:hover {
            background: #4a4a6a;
        }
        
        .view-btn.active {
            background: #00d9ff;
            color: #1a1a2e;
            font-weight: 600;
        }
        
        /* Stats Bar */
        .stats {
            display: none;
            gap: 20px;
            padding: 15px 20px;
            background: #2d2d44;
            border-radius: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
        }
        
        .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #00d9ff;
        }
        
        .stat-item:nth-child(2) .stat-value { color: #ffd700; }
        .stat-item:nth-child(3) .stat-value { color: #00ff88; }
        .stat-item:nth-child(4) .stat-value { color: #e74c3c; }
        .stat-item:nth-child(5) .stat-value { color: #ff6b6b; }
        .stat-item:nth-child(6) .stat-value { color: #9b59b6; }
        
        /* Tree Container */
        .tree-container {
            background: #2d2d44;
            border-radius: 8px;
            padding: 20px;
            min-height: 400px;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }
        
        .empty-state h2 {
            margin-bottom: 10px;
            color: #888;
        }
        
        /* Tree Node */
        .tree-node {
            position: relative;
            margin-left: 0;
        }
        
        /* Depth-based indentation */
        .tree-node.depth-0 > .node-children { padding-left: 0; }
        .tree-node.depth-1 > .node-children { padding-left: 30px; border-left: 3px solid #9b59b6; margin-left: 15px; }
        .tree-node.depth-2 > .node-children { padding-left: 30px; border-left: 3px solid #e74c3c; margin-left: 15px; }
        .tree-node.depth-3 > .node-children { padding-left: 30px; border-left: 3px solid #f39c12; margin-left: 15px; }
        .tree-node.depth-4 > .node-children { padding-left: 30px; border-left: 3px solid #3498db; margin-left: 15px; }
        
        /* Sub-Agent special styling - make it stand out */
        .tree-node > .node-header.sub_agent {
            margin-top: 15px;
            margin-bottom: 5px;
        }
        
        .tree-node > .node-header.sub_agent + .node-content + .node-children {
            background: rgba(231, 76, 60, 0.05);
            border-radius: 8px;
            padding: 10px;
            margin-top: 5px;
        }
        
        /* Node Header */
        .node-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #1a1a2e;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 8px;
            border-left: 4px solid #4a4a6a;
            transition: all 0.2s;
        }
        
        .node-header:hover {
            background: #252540;
        }
        
        .node-header.highlighted {
            background: rgba(0, 217, 255, 0.15);
            box-shadow: 0 0 0 2px rgba(0, 217, 255, 0.5);
        }
        
        .node-header.has-matching-child {
            border-left-color: #00d9ff;
        }
        
        /* ÂÖ≥ÈîÆÂ≠óÈ´ò‰∫ÆÊ†∑Âºè */
        .search-highlight {
            background: rgba(255, 215, 0, 0.4);
            color: #fff;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }
        
        /* Node Type Colors */
        .node-header.main_agent { 
            border-left-color: #9b59b6; 
            border-left-width: 6px;
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.2) 0%, #1a1a2e 100%);
            font-size: 16px;
            font-weight: 600;
        }
        .node-header.sub_agent { 
            border-left-color: #e74c3c; 
            border-left-width: 6px;
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.2) 0%, #1a1a2e 100%);
            font-weight: 600;
        }
        .node-header.tool_call { border-left-color: #00d9ff; }
        .node-header.llm_input { border-left-color: #ff9800; }
        .node-header.llm_call { border-left-color: #ffd700; }
        .node-header.llm_response { border-left-color: #00ff88; }
        .node-header.error { border-left-color: #ff4444; }
        
        .node-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }
        
        .node-title {
            flex: 1;
            font-weight: 500;
        }
        
        .node-meta {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #888;
        }
        
        .node-status {
            font-size: 14px;
        }
        
        .node-duration {
            color: #00d9ff;
            font-family: monospace;
        }
        
        .expand-icon {
            transition: transform 0.2s;
            color: #666;
        }
        
        .tree-node.expanded > .node-header .expand-icon {
            transform: rotate(90deg);
        }
        
        /* Node Content (Details) */
        .node-content {
            display: none;
            margin-left: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background: #1a1a2e;
            border-radius: 6px;
            border-left: 2px solid #4a4a6a;
        }
        
        .tree-node.expanded > .node-content {
            display: block;
        }
        
        .detail-section {
            margin-bottom: 15px;
        }
        
        .detail-section:last-child {
            margin-bottom: 0;
        }
        
        .detail-title {
            font-size: 12px;
            color: #00d9ff;
            text-transform: uppercase;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .detail-content {
            background: #252540;
            padding: 12px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .detail-content.system-prompt {
            border-left: 3px solid #ffd700;
            background: rgba(255, 215, 0, 0.05);
        }
        
        .detail-content.response {
            border-left: 3px solid #00ff88;
            background: rgba(0, 255, 136, 0.05);
        }
        
        .detail-content.tool-calls {
            border-left: 3px solid #00d9ff;
            background: rgba(0, 217, 255, 0.05);
        }
        
        .detail-content.error {
            border-left: 3px solid #ff4444;
            background: rgba(255, 68, 68, 0.05);
        }
        
        /* JSON Syntax Highlighting */
        .json-key { color: #9b59b6; }
        .json-string { color: #00ff88; }
        .json-number { color: #00d9ff; }
        .json-boolean { color: #ffd700; }
        .json-null { color: #888; }
        
        /* Token Usage */
        .token-usage {
            display: flex;
            gap: 20px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        
        .token-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .token-label {
            font-size: 10px;
            color: #666;
        }
        
        .token-value {
            font-size: 16px;
            font-weight: 600;
            color: #00d9ff;
        }
        
        /* Children Container */
        .node-children {
            display: none;
        }
        
        .tree-node.expanded > .node-children {
            display: block;
        }
        
        /* Collapsible Prompt Styles */
        .prompt-collapsible {
            margin: 8px 0;
        }
        
        .prompt-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #2a2a3e;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        
        .prompt-toggle:hover {
            background: #3a3a4e;
        }
        
        .prompt-toggle .toggle-icon {
            font-size: 10px;
            color: #888;
            transition: transform 0.2s;
        }
        
        .prompt-toggle.expanded .toggle-icon {
            transform: rotate(90deg);
        }
        
        .prompt-length {
            font-size: 10px;
            color: #666;
            background: #1a1a2e;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .prompt-content {
            display: none;
            padding: 12px;
            margin-top: 4px;
            background: #1e1e2e;
            border-radius: 6px;
            border-left: 3px solid #ff9800;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        
        .prompt-content.expanded {
            display: block;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÑ Agent Interaction Viewer</h1>
        
        <div class="controls">
            <select id="log-file-select">
                <option value="">Loading log files...</option>
            </select>
            
            <div class="search-box">
                <span>üîç</span>
                <input type="text" id="search-input" placeholder="ÊêúÁ¥¢Âπ∂Ë∑≥ËΩ¨..." onkeydown="handleSearchKeydown(event)">
                <button id="prev-match" class="nav-btn" title="‰∏ä‰∏Ä‰∏™ÂåπÈÖç (‚Üë)" onclick="navigateMatch(-1)" style="display: none;">‚Üë</button>
                <button id="next-match" class="nav-btn" title="‰∏ã‰∏Ä‰∏™ÂåπÈÖç (‚Üì)" onclick="navigateMatch(1)" style="display: none;">‚Üì</button>
                <span class="match-count" id="match-count" style="display: none;">0/0</span>
            </div>
            
            <select id="type-filter">
                <option value="">All Types</option>
                <option value="TOOL_CALL">üîß Tool Calls</option>
                <option value="LLM_CALL">üß† LLM Calls</option>
                <option value="LLM_RESPONSE">üí¨ LLM Responses</option>
                <option value="ERROR">‚ùå Errors</option>
            </select>
            
            <select id="status-filter">
                <option value="">All Status</option>
                <option value="success">‚úÖ Success</option>
                <option value="fail">‚ùå Failed</option>
                <option value="running">‚è≥ Running</option>
            </select>
            
        </div>
        
        <div class="stats" id="stats">
            <div class="stat-item">
                <span class="stat-label">LLM Rounds</span>
                <span class="stat-value" id="stat-llm">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Tool Calls</span>
                <span class="stat-value" id="stat-tool">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Sub-Agents</span>
                <span class="stat-value" id="stat-subagent">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Errors</span>
                <span class="stat-value" id="stat-error">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Total Tokens</span>
                <span class="stat-value" id="stat-tokens">0</span>
            </div>
        </div>
        
        <!-- Tree View Container -->
        <div class="tree-container" id="tree-container">
            <div class="tree-view" id="tree-view">
                <div class="empty-state">
                    <h2>No logs loaded</h2>
                    <p>Select a log file from the dropdown above</p>
                    <p style="margin-top: 10px; font-size: 12px; color: #555;">
                        File format: <code>session_*.jsonl</code>
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Debug mode flag - set to false in production
        window.DEBUG_MODE = false;

        // ============================================
        // State
        // ============================================
        let allLogs = [];
        let tree = null;
        let currentFile = null;
        let expandedNodes = new Set();
        let searchQuery = '';
        let matchingNodes = new Set();
        let matchingNodeIds = [];  // Ordered list of matching node IDs for navigation
        let currentMatchIndex = -1;  // Current position in matchingNodeIds
        let shownSystemPrompts = new Set();  // Track shown prompts for deduplication
        
        // ============================================
        // DOM Elements
        // ============================================
        const searchInput = document.getElementById('search-input');
        const typeFilter = document.getElementById('type-filter');
        const statusFilter = document.getElementById('status-filter');
        const treeView = document.getElementById('tree-view');
        const treeContainer = document.getElementById('tree-container');
        const stats = document.getElementById('stats');
        const matchCountEl = document.getElementById('match-count');
        
        // ============================================
        // Event Listeners
        // ============================================
        searchInput.addEventListener('input', debounce(handleSearch, 300));
        typeFilter.addEventListener('change', applyFilters);
        statusFilter.addEventListener('change', applyFilters);
        
        // Initialize
        loadAvailableLogFiles();
        autoLoadLatestLog();
        
        // ============================================
        // File Loading
        // ============================================
        function loadLogFile(filename) {
            fetch(filename)
                .then(response => {
                    if (!response.ok) throw new Error('File not found');
                    return response.text();
                })
                .then(content => {
                    currentFile = filename;
                    parseJsonLines(content);
                    updateLogFileSelect(filename);
                })
                .catch(err => {
                    if (window.DEBUG_MODE) {
                        console.error('Could not load log file:', err);
                    }
                });
        }
        
        // ============================================
        // Auto Load Latest Log
        // ============================================
        let availableLogFiles = [];
        
        function loadAvailableLogFiles() {
            // Try to fetch directory listing - works with Python http.server
            fetch('./')
                .then(response => response.text())
                .then(html => {
                    availableLogFiles = [];
                    
                    // Method 1: Parse HTML links (Python http.server format)
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const links = doc.querySelectorAll('a');
                    
                    links.forEach(link => {
                        const href = link.getAttribute('href');
                        if (href && href.endsWith('.jsonl')) {
                            availableLogFiles.push(decodeURIComponent(href));
                        }
                    });
                    
                    // Method 2: Try regex to find .jsonl files in raw HTML
                    if (availableLogFiles.length === 0) {
                        const matches = html.match(/[\w\-\.]+\.jsonl/g);
                        if (matches) {
                            availableLogFiles = [...new Set(matches)];
                        }
                    }
                    
                    // Sort by name (session files have timestamps) - newest first
                    availableLogFiles.sort().reverse();
                    
                    // Update dropdown
                    updateLogFileDropdown();

                    if (window.DEBUG_MODE) {
                        console.log('Found log files:', availableLogFiles);
                    }
                })
                .catch(err => {
                    if (window.DEBUG_MODE) {
                        console.error('Could not load directory listing:', err);
                    }
                    updateLogFileDropdown();
                });
        }
        
        function updateLogFileDropdown() {
            const select = document.getElementById('log-file-select');
            
            if (availableLogFiles.length === 0) {
                select.innerHTML = '<option value="">No log files found</option>';
                return;
            }
            
            select.innerHTML = '<option value="">Select Log File (' + availableLogFiles.length + ')...</option>';
            
            availableLogFiles.forEach(file => {
                const option = document.createElement('option');
                option.value = file;
                // Display friendly name
                const displayName = file.replace('session_', '').replace('.jsonl', '');
                option.textContent = displayName;
                select.appendChild(option);
            });
        }
        
        function updateLogFileSelect(filename) {
            const select = document.getElementById('log-file-select');
            select.value = filename;
        }
        
        function autoLoadLatestLog() {
            // Wait a bit for directory listing to load
            setTimeout(() => {
                if (availableLogFiles.length > 0) {
                    // Load the first (latest) file
                    loadLogFile(availableLogFiles[0]);
                }
            }, 500);
        }
        
        // Event listener for log file dropdown
        document.getElementById('log-file-select').addEventListener('change', (e) => {
            if (e.target.value) {
                loadLogFile(e.target.value);
            }
        });
        
        // ============================================
        // JSONL Parsing (T005, T008)
        // ============================================
        function parseJsonLines(content) {
            allLogs = [];
            const lines = content.trim().split('\n');
            let parseErrors = 0;
            
            for (const line of lines) {
                if (!line.trim()) continue;
                try {
                    const entry = JSON.parse(line);
                    allLogs.push(entry);
                } catch (e) {
                    parseErrors++;
                    console.warn('Failed to parse line:', line.substring(0, 100));
                }
            }
            
            if (parseErrors > 0) {
                console.warn(`Skipped ${parseErrors} malformed JSON lines`);
            }
            
            // Sort by timestamp
            allLogs.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Build tree
            tree = buildTree(allLogs);
            shownSystemPrompts.clear();
            
            // Update UI
            updateStats();
            applyFilters();
        }
        
        // ============================================
        // Tree Building (T006, T007)
        // ============================================
        function buildTree(logs) {
            // Create root node for main agent
            const root = {
                id: 'root',
                type: 'main_agent',
                label: 'Main Agent',
                timestamp: logs[0]?.timestamp || new Date().toISOString(),
                status: 'running',
                depth: 0,
                entries: [],
                children: [],
                collapsed: false,
                highlighted: false,
                hasMatchingChild: false
            };
            
            // Stack to track current context: [{node, runId}]
            const contextStack = [{ node: root, runId: null }];
            
            // Map to track tool call start events by run_id
            const toolCallStarts = new Map();
            
            for (const entry of logs) {
                const data = entry.data || {};
                const currentContext = contextStack[contextStack.length - 1];
                
                if (entry.event_type === 'TOOL_CALL') {
                    if (data.phase === 'start') {
                        // Check if this is an agent_tool (sub-agent)
                        if (data.tool_name === 'agent_tool') {
                            // Create sub-agent node
                            const subAgentNode = {
                                id: data.run_id || `subagent_${Date.now()}`,
                                type: 'sub_agent',
                                label: `Sub-Agent: ${(data.input?.task_details?.[0] || 'Task').substring(0, 50)}`,
                                timestamp: entry.timestamp,
                                status: 'running',
                                depth: currentContext.node.depth + 1,
                                entries: [entry],
                                children: [],
                                collapsed: true,
                                highlighted: false,
                                hasMatchingChild: false,
                                input: data.input
                            };
                            
                            currentContext.node.children.push(subAgentNode);
                            contextStack.push({ node: subAgentNode, runId: data.run_id });
                            toolCallStarts.set(data.run_id, subAgentNode);
                        } else {
                            // Regular tool call - create node
                            const toolNode = {
                                id: data.run_id || `tool_${Date.now()}`,
                                type: 'tool_call',
                                label: data.tool_name || 'Unknown Tool',
                                timestamp: entry.timestamp,
                                status: 'running',
                                depth: currentContext.node.depth + 1,
                                entries: [entry],
                                children: [],
                                collapsed: true,
                                highlighted: false,
                                hasMatchingChild: false,
                                input: data.input
                            };
                            
                            currentContext.node.children.push(toolNode);
                            toolCallStarts.set(data.run_id, toolNode);
                        }
                    } else if (data.phase === 'end') {
                        // Find the matching start node
                        const startNode = toolCallStarts.get(data.run_id);
                        if (startNode) {
                            startNode.entries.push(entry);
                            startNode.status = data.success !== false ? 'success' : 'fail';
                            startNode.duration_ms = parseDuration(data.duration);
                            startNode.output = data.output;
                            
                            // If this is an agent_tool end, pop from context stack
                            if (data.tool_name === 'agent_tool') {
                                // Find and pop the matching context
                                for (let i = contextStack.length - 1; i >= 0; i--) {
                                    if (contextStack[i].runId === data.run_id) {
                                        contextStack.splice(i, 1);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                } else if (entry.event_type === 'LLM_INPUT') {
                    const inputNode = {
                        id: `llm_input_${entry.timestamp}`,
                        type: 'llm_input',
                        label: `üì• LLM Input (${data.message_count || 0} messages)`,
                        timestamp: entry.timestamp,
                        status: 'success',
                        depth: currentContext.node.depth + 1,
                        entries: [entry],
                        children: [],
                        collapsed: true,
                        highlighted: false,
                        hasMatchingChild: false,
                        system_prompt: data.system_prompt,
                        messages: data.messages,
                        message_count: data.message_count
                    };
                    
                    currentContext.node.children.push(inputNode);
                    // Track last LLM input for context
                    currentContext.lastLlmInput = inputNode;
                } else if (entry.event_type === 'LLM_CALL') {
                    const llmNode = {
                        id: `llm_${entry.timestamp}`,
                        type: 'llm_call',
                        label: `LLM: ${data.model || 'Unknown'}`,
                        timestamp: entry.timestamp,
                        status: 'running',
                        depth: currentContext.node.depth + 1,
                        entries: [entry],
                        children: [],
                        collapsed: true,
                        highlighted: false,
                        hasMatchingChild: false,
                        model: data.model,
                        system_prompt: data.system_prompt,
                        messages: data.messages,
                        tools: data.tools,
                        temperature: data.temperature,
                        max_tokens: data.max_tokens
                    };
                    
                    currentContext.node.children.push(llmNode);
                    // Track last LLM call for pairing with response
                    currentContext.lastLlmNode = llmNode;
                } else if (entry.event_type === 'LLM_RESPONSE') {
                    // Deduplicate consecutive LLM_RESPONSE nodes with same content
                    const lastChild = currentContext.node.children[currentContext.node.children.length - 1];
                    const isDuplicate = lastChild && 
                                      lastChild.type === 'llm_response' && 
                                      (data.content === lastChild.content || 
                                       (JSON.stringify(data.tool_calls) === JSON.stringify(lastChild.tool_calls) && !data.content && !lastChild.content));
                    
                    if (!isDuplicate) {
                        // Update the last LLM_CALL node status to success
                        if (currentContext.lastLlmNode) {
                            currentContext.lastLlmNode.status = 'success';
                            currentContext.lastLlmNode.usage = data.usage;
                        }
                        
                        const responseNode = {
                            id: `response_${entry.timestamp}`,
                            type: 'llm_response',
                            label: data.tool_calls?.length ? `Response (${data.tool_calls.length} tools)` : 'Response',
                            timestamp: entry.timestamp,
                            status: 'success',
                            depth: currentContext.node.depth + 1,
                            entries: [entry],
                            children: [],
                            collapsed: true,
                            highlighted: false,
                            hasMatchingChild: false,
                            content: data.content,
                            tool_calls: data.tool_calls,
                            usage: data.usage
                        };
                        
                        currentContext.node.children.push(responseNode);
                    } else {
                        // Merge usage info if available to the existing node
                        if (data.usage && lastChild) {
                            lastChild.usage = data.usage;
                        }
                        // Also Add entry to the existing node so we have the record
                        if (lastChild) {
                            lastChild.entries.push(entry);
                        }
                    }
                } else if (entry.event_type === 'ERROR') {
                    const errorNode = {
                        id: `error_${entry.timestamp}`,
                        type: 'error',
                        label: `Error: ${data.error_type || 'Unknown'}`,
                        timestamp: entry.timestamp,
                        status: 'fail',
                        depth: currentContext.node.depth + 1,
                        entries: [entry],
                        children: [],
                        collapsed: true,
                        highlighted: false,
                        hasMatchingChild: false,
                        error_type: data.error_type,
                        message: data.message,
                        stacktrace: data.stacktrace
                    };
                    
                    currentContext.node.children.push(errorNode);
                }
            }
            
            // Update root status based on children
            if (root.children.length > 0) {
                const hasError = root.children.some(c => c.status === 'fail');
                const allDone = root.children.every(c => c.status !== 'running');
                root.status = hasError ? 'fail' : (allDone ? 'success' : 'running');
            }
            
            return root;
        }
        
        function parseDuration(durationStr) {
            if (!durationStr) return null;
            // Parse formats like "1.5s", "150ms", "2m30s"
            const match = durationStr.match(/(\d+\.?\d*)(ms|s|m)/);
            if (match) {
                const value = parseFloat(match[1]);
                const unit = match[2];
                if (unit === 'ms') return value;
                if (unit === 's') return value * 1000;
                if (unit === 'm') return value * 60000;
            }
            return null;
        }
        
        // ============================================
        // Tree Rendering (T009, T010, T011, T012)
        // ============================================
        function renderTree() {
            if (!tree) {
                treeView.innerHTML = `
                    <div class="empty-state">
                        <h2>No logs loaded</h2>
                        <p>Select a log file from the dropdown above</p>
                    </div>
                `;
                return;
            }
            
            treeView.innerHTML = renderNode(tree);
            attachNodeEventListeners();
        }
        
        function renderNode(node) {
            if (!shouldShowNode(node)) return '';
            
            // Get tool name for tool_call nodes
            const toolName = node.entries?.[0]?.data?.tool_name;
            const icon = getNodeIcon(node.type, toolName);
            const statusIcon = getStatusIcon(node.status);
            const duration = formatDuration(node.duration_ms);
            const time = new Date(node.timestamp).toLocaleTimeString();
            
            const expandedClass = expandedNodes.has(node.id) || !node.collapsed ? 'expanded' : '';
            const highlightedClass = node.highlighted ? 'highlighted' : '';
            const hasMatchClass = node.hasMatchingChild ? 'has-matching-child' : '';
            
            const childrenHtml = node.children.map(child => renderNode(child)).join('');
            
            // È´ò‰∫ÆËäÇÁÇπÊ†áÈ¢ò‰∏≠ÁöÑÂÖ≥ÈîÆÂ≠ó
            const highlightedLabel = searchQuery ? highlightKeywords(node.label, searchQuery) : escapeHtml(node.label);
            
            return `
                <div class="tree-node depth-${node.depth} ${expandedClass}" data-id="${node.id}">
                    <div class="node-header ${node.type} ${highlightedClass} ${hasMatchClass}">
                        <span class="expand-icon">${node.children.length > 0 ? '‚ñ∂' : '‚Ä¢'}</span>
                        <span class="node-icon">${icon}</span>
                        <span class="node-title">${highlightedLabel}</span>
                        <div class="node-meta">
                            <span class="node-status">${statusIcon}</span>
                            ${duration ? `<span class="node-duration">${duration}</span>` : ''}
                            <span>${time}</span>
                        </div>
                    </div>
                    <div class="node-content">
                        ${renderNodeDetails(node)}
                    </div>
                    <div class="node-children">
                        ${childrenHtml}
                    </div>
                </div>
            `;
        }
        
        function shouldShowNode(node) {
            const typeValue = typeFilter.value;
            const statusValue = statusFilter.value;
            
            // Type filter
            if (typeValue) {
                const typeMap = {
                    'TOOL_CALL': ['tool_call', 'sub_agent'],
                    'LLM_INPUT': ['llm_input'],
                    'LLM_CALL': ['llm_call'],
                    'LLM_RESPONSE': ['llm_response'],
                    'ERROR': ['error']
                };
                if (!typeMap[typeValue]?.includes(node.type) && node.type !== 'main_agent') {
                    // Check if any child matches
                    if (!node.children.some(c => shouldShowNode(c))) {
                        return false;
                    }
                }
            }
            
            // Status filter
            if (statusValue && node.status !== statusValue && node.type !== 'main_agent') {
                if (!node.children.some(c => shouldShowNode(c))) {
                    return false;
                }
            }
            
            return true;
        }
        
        function getToolIcon(toolName) {
            const toolIcons = {
                // Thinking & Planning
                'think_tool': 'üí≠',
                'plan_tasks': 'üìã',
                'replan_tasks': 'üîÑ',
                'complete_task': '‚úÖ',
                'fail_task': '‚ùå',
                
                // Execution
                'execute_shell_command': 'üíª',
                'execute_python_script': 'üêç',
                'curl_request': 'üåê',
                'nc_connect': 'üîå',
                
                // Knowledge & Search
                'knowledge_search': 'üìö',
                
                // Agent
                'agent_tool': 'üîÄ',
                
                // File operations
                'read_file': 'üìñ',
                'write_file': '‚úèÔ∏è',
                
                // Default
                'default': 'üîß'
            };
            return toolIcons[toolName] || toolIcons['default'];
        }
        
        function getNodeIcon(type, toolName) {
            if (type === 'tool_call' && toolName) {
                return getToolIcon(toolName);
            }
            const icons = {
                'main_agent': 'ü§ñ',
                'sub_agent': 'üîÄ',
                'tool_call': 'üîß',
                'llm_input': 'üì•',
                'llm_call': 'üß†',
                'llm_response': 'üí¨',
                'error': '‚ùå'
            };
            return icons[type] || 'üìÑ';
        }
        
        function getStatusIcon(status) {
            const icons = {
                'success': '‚úÖ',
                'fail': '‚ùå',
                'running': '‚è≥'
            };
            return icons[status] || '';
        }
        
        function formatDuration(ms) {
            if (ms === null || ms === undefined) return '';
            if (ms < 1000) return `${Math.round(ms)}ms`;
            if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
            return `${Math.floor(ms / 60000)}m${Math.round((ms % 60000) / 1000)}s`;
        }
        
        // ============================================
        // Node Details Rendering (T017-T021)
        // ============================================
        function renderNodeDetails(node) {
            switch (node.type) {
                case 'tool_call':
                    return renderToolCallDetails(node);
                case 'sub_agent':
                    return renderSubAgentDetails(node);
                case 'llm_input':
                    return renderLLMInputDetails(node);
                case 'llm_call':
                    return renderLLMCallDetails(node);
                case 'llm_response':
                    return renderLLMResponseDetails(node);
                case 'error':
                    return renderErrorDetails(node);
                case 'main_agent':
                    return renderMainAgentDetails(node);
                default:
                    return `<div class="detail-content">${syntaxHighlightJson(node.entries)}</div>`;
            }
        }
        
        function renderToolCallDetails(node) {
            const entry = node.entries[0];
            const data = entry?.data || {};
            const toolName = data.tool_name || 'Unknown';
            const isThinkTool = toolName === 'think_tool';
            
            let html = `
                <div class="detail-section">
                    <div class="detail-title">${isThinkTool ? 'üí≠ Think Tool' : 'üîß Tool Info'}</div>
                    <div class="detail-content tool-calls">Tool: ${toolName}
Run ID: ${data.run_id || 'Unknown'}
Status: ${node.status}
Duration: ${formatDuration(node.duration_ms) || 'N/A'}</div>
                </div>
            `;
            
            // For think_tool, always show thought content prominently
            if (isThinkTool) {
                const thought = node.input?.thought || data.input?.thought;
                if (thought) {
                    html += `
                        <div class="detail-section">
                            <div class="detail-title">üí≠ Thought</div>
                            <div class="detail-content" style="background: #1a1a2e; border-left: 3px solid #9b59b6; padding: 12px; white-space: pre-wrap;">${searchQuery ? highlightKeywords(thought, searchQuery) : escapeHtml(thought)}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="detail-section">
                            <div class="detail-title">ÔøΩ Thought</div>
                            <div class="detail-content" style="color: #888;">No thought content found</div>
                        </div>
                    `;
                }
            } else if (node.input) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">üì• Input</div>
                        <div class="detail-content">${syntaxHighlightJson(node.input)}</div>
                    </div>
                `;
            }
            
            // For think_tool, skip the boring "logged successfully" output
            if (node.output !== undefined && !isThinkTool) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">üì§ Output</div>
                        <div class="detail-content response">${searchQuery ? highlightKeywords(typeof node.output === 'string' ? node.output : JSON.stringify(node.output, null, 2), searchQuery) : escapeHtml(typeof node.output === 'string' ? node.output : JSON.stringify(node.output, null, 2))}</div>
                    </div>
                `;
            }
            
            return html;
        }
        
        function renderSubAgentDetails(node) {
            const input = node.input || {};
            
            let html = `
                <div class="detail-section">
                    <div class="detail-title">üîÄ Sub-Agent</div>
                    <div class="detail-content tool-calls">Status: ${node.status}
Duration: ${formatDuration(node.duration_ms) || 'N/A'}</div>
                </div>
            `;
            
            if (input.context) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">üìã Context</div>
                        <div class="detail-content">${searchQuery ? highlightKeywords(input.context, searchQuery) : escapeHtml(input.context)}</div>
                    </div>
                `;
            }
            
            if (input.task_details) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">üìù Task Details</div>
                        <div class="detail-content">${syntaxHighlightJson(input.task_details)}</div>
                    </div>
                `;
            }
            
            if (node.output) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">üì§ Result</div>
                        <div class="detail-content response">${searchQuery ? highlightKeywords(node.output, searchQuery) : escapeHtml(node.output)}</div>
                    </div>
                `;
            }
            
            return html;
        }
        
        function renderLLMInputDetails(node) {
            let html = `
                <div class="detail-section">
                    <div class="detail-title">üì• LLM Input</div>
                    <div class="detail-content">Message Count: ${node.message_count || 0}</div>
                </div>
            `;
            
            let promptIndex = 0;
            
            // System Prompt
            if (node.system_prompt) {
                html += renderCollapsiblePrompt(node.id, promptIndex++, 'System Prompt', 'üìù', node.system_prompt, []);
            }
            
            // Messages (conversation history + current user message)
            if (node.messages && node.messages.length > 0) {
                // Build a map of tool_call_id -> tool_name from assistant messages
                const toolCallIdToName = {};
                for (const msg of node.messages) {
                    if (msg.tool_calls && msg.tool_calls.length > 0) {
                        for (const tc of msg.tool_calls) {
                            if (tc.id && tc.name) {
                                toolCallIdToName[tc.id] = tc.name;
                            }
                        }
                    }
                }
                
                for (const msg of node.messages) {
                    const role = msg.role || 'unknown';
                    let icon = role === 'user' ? 'üë§' : (role === 'assistant' ? 'ü§ñ' : (role === 'tool' ? 'üîß' : 'üìÑ'));
                    let title = `${role.charAt(0).toUpperCase() + role.slice(1)} Message`;
                    
                    let content = msg.content || '';
                    
                    // For assistant messages with tool_calls, show tool names in title
                    if (msg.tool_calls && msg.tool_calls.length > 0) {
                        const toolNames = msg.tool_calls.map(tc => tc.name).join(', ');
                        title = `ü§ñ Calls: ${toolNames}`;
                        content += '\n\n**Tool Calls:**\n' + JSON.stringify(msg.tool_calls, null, 2);
                    }
                    
                    // For tool messages, show tool name instead of just ID
                    if (msg.tool_call_id) {
                        const toolName = toolCallIdToName[msg.tool_call_id] || 'unknown';
                        icon = getToolIcon(toolName);
                        title = `Tool Result: ${toolName}`;
                    }
                    
                    html += renderCollapsiblePrompt(node.id, promptIndex++, title, icon, content, []);
                }
            }
            
            return html;
        }
        
        function renderLLMCallDetails(node) {
            let html = `
                <div class="detail-section">
                    <div class="detail-title">üß† LLM Call</div>
                    <div class="detail-content">Model: ${node.model || 'Unknown'}
Temperature: ${node.temperature ?? 'default'}
Max Tokens: ${node.max_tokens ?? 'default'}</div>
                </div>
            `;
            
            // Render all prompts as collapsible sections
            let promptIndex = 0;
            
            // 1. System Prompt - split by sources if multiple
            if (node.system_prompt) {
                // Try to find sources from first system message
                let systemSources = [];
                if (node.messages && node.messages.length > 0) {
                    const sysMsg = node.messages.find(m => m.role === 'system');
                    if (sysMsg && sysMsg.sources) {
                        systemSources = sysMsg.sources;
                    }
                }
                
                // If multiple sources, show each as separate collapsible
                if (systemSources.length > 1) {
                    for (const source of systemSources) {
                        // Extract content for this source based on known markers
                        const sourceContent = extractSourceContent(node.system_prompt, source);
                        if (sourceContent) {
                            html += renderCollapsiblePrompt(node.id, promptIndex++, source, 'üìù', sourceContent, [source]);
                        }
                    }
                } else {
                    const sysTitle = systemSources.length > 0 ? systemSources[0] : 'System Prompt';
                    html += renderCollapsiblePrompt(node.id, promptIndex++, sysTitle, 'üìù', node.system_prompt, systemSources);
                }
            }
            
            // 2. Tool Definitions - show available tools for this LLM call
            if (node.tools && node.tools.length > 0) {
                let toolsContent = node.tools.map(t => 
                    `**${t.name}**\n${t.description || '(no description)'}`
                ).join('\n\n---\n\n');
                html += renderCollapsiblePrompt(
                    node.id, 
                    promptIndex++, 
                    `Tools (${node.tools.length})`, 
                    'üîß', 
                    toolsContent,
                    ['tools']
                );
            }
            
            // 3. Messages - only show user inputs (system, human/user), skip tool results and AI responses
            if (node.messages && node.messages.length > 0) {
                for (let i = 0; i < node.messages.length; i++) {
                    const msg = node.messages[i];
                    const content = typeof msg === 'string' ? msg : (msg.content || '');
                    const role = typeof msg === 'object' ? (msg.role || 'unknown') : 'message';
                    const type = typeof msg === 'object' ? msg.type : null;
                    const sources = typeof msg === 'object' ? (msg.sources || []) : [];
                    
                    // Skip if same as system_prompt (already shown)
                    if (role === 'system' && content === node.system_prompt) continue;
                    
                    // Skip tool results - these are not user inputs
                    if (role === 'tool' || type === 'tool_result') continue;
                    
                    // Skip AI responses - these are not user inputs
                    if (role === 'ai' || role === 'assistant') continue;
                    
                    // Identify prompt type - use sources if available, otherwise fallback
                    const promptInfo = identifyPromptType(content, role, type);
                    
                    // Use sources as title if available
                    const title = sources.length > 0 
                        ? sources.join(' + ') 
                        : promptInfo.name;
                    const tags = sources.length > 0 ? sources : promptInfo.tags;
                    
                    html += renderCollapsiblePrompt(
                        node.id, 
                        promptIndex++, 
                        title, 
                        promptInfo.icon, 
                        content,
                        tags
                    );
                }
            }
            
            // 4. Raw prompts (fallback if messages were empty)
            if (node.raw_prompts && node.raw_prompts.length > 0 && (!node.messages || node.messages.length === 0)) {
                for (let i = 0; i < node.raw_prompts.length; i++) {
                    const prompt = node.raw_prompts[i];
                    // Skip if same as system_prompt
                    if (prompt === node.system_prompt) continue;
                    
                    const promptInfo = identifyPromptType(prompt, i === 0 ? 'system' : 'user');
                    html += renderCollapsiblePrompt(
                        node.id,
                        promptIndex++,
                        `Raw Prompt ${i + 1}`,
                        'üìÑ',
                        prompt,
                        ['raw']
                    );
                }
            }
            
            return html;
        }
        
        function extractSourceContent(fullContent, source) {
            // Map source names to their XML tag markers
            const sourceMarkers = {
                'main_agent.md': ['<identity>', '<rules>', '<role>', '<workflow>', '<tools>', '<decision>', '<after_each_result>', '<on_error>', '<on_success>'],
                'ctf_mode.md': ['<ctf_mode>', '<adapt>', '<python_template>', '<knowledge_search>', '<reference>', '<stuck_protocol>'],
                'sub_agent.md': ['<identity>', '<rules>', '<loop>', '<tools>', '<on_error>', '<output>', '<extract>'],
                'session_context': ['<session_context>'],
                'think_tool.md': ['<think_tool>'],
                'knowledge_search.md': ['<knowledge_search>'],
            };
            
            const markers = sourceMarkers[source];
            if (!markers) {
                return null;
            }
            
            // Find content between first and last marker for this source
            let startPos = -1;
            let endPos = -1;
            
            for (const marker of markers) {
                const pos = fullContent.indexOf(marker);
                if (pos !== -1) {
                    if (startPos === -1 || pos < startPos) {
                        startPos = pos;
                    }
                    // Find closing tag
                    const closeTag = marker.replace('<', '</');
                    const closePos = fullContent.lastIndexOf(closeTag);
                    if (closePos !== -1 && closePos > endPos) {
                        endPos = closePos + closeTag.length;
                    }
                }
            }
            
            if (startPos !== -1 && endPos !== -1 && endPos > startPos) {
                return fullContent.substring(startPos, endPos);
            }
            
            // Fallback: return content if any marker found
            if (startPos !== -1) {
                // Find next source's start or end of content
                return fullContent.substring(startPos);
            }
            
            return null;
        }
        
        function identifyPromptType(content, role, type) {
            // Use type from log if available (set by rich_console.py)
            const typeMap = {
                'system_prompt': { name: 'System Prompt', icon: 'üìù', tags: ['system'] },
                'tool_result': { name: 'Tool Result', icon: 'üì§', tags: ['tool'] },
                'ai_response': { name: 'AI Response', icon: 'ü§ñ', tags: ['ai'] },
                'user_request': { name: 'User Request', icon: 'üë§', tags: ['user'] },
                'user_message': { name: 'User Message', icon: 'üë§', tags: ['user'] },
            };
            
            if (type && typeMap[type]) {
                return typeMap[type];
            }
            
            // Fallback to role-based identification
            const roleMap = {
                'system': { name: 'System Prompt', icon: 'üìù', tags: ['system'] },
                'tool': { name: 'Tool Result', icon: 'üì§', tags: ['tool'] },
                'ai': { name: 'AI Response', icon: 'ü§ñ', tags: ['ai'] },
                'assistant': { name: 'AI Response', icon: 'ü§ñ', tags: ['ai'] },
                'human': { name: 'User Message', icon: 'üë§', tags: ['user'] },
                'user': { name: 'User Message', icon: 'üë§', tags: ['user'] },
            };
            
            return roleMap[role] || { name: `Message (${role})`, icon: 'üí¨', tags: [role] };
        }
        
        function renderCollapsiblePrompt(nodeId, index, title, icon, content, tags = []) {
            const promptId = `prompt_${nodeId}_${index}`;
            const contentLength = content.length;
            const preview = content.substring(0, 60).replace(/\n/g, ' ').trim();
            const tagsHtml = tags.length > 0 
                ? tags.map(t => `<span style="background: #3a3a5a; padding: 2px 6px; border-radius: 3px; font-size: 10px; color: #888;">${t}</span>`).join(' ')
                : '';
            
            return `
                <div class="detail-section prompt-collapsible">
                    <div class="prompt-toggle" onclick="togglePrompt('${promptId}', this)">
                        <span class="toggle-icon">‚ñ∂</span>
                        <span>${icon} ${title}</span>
                        ${tagsHtml}
                        <span style="color: #666; font-size: 11px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin: 0 10px;">${escapeHtml(preview)}...</span>
                        <span class="prompt-length">${contentLength} chars</span>
                    </div>
                    <div class="prompt-content" id="${promptId}">${searchQuery ? highlightKeywords(content, searchQuery) : escapeHtml(content)}</div>
                </div>
            `;
        }
        
        function renderLLMResponseDetails(node) {
            let html = '';
            
            if (node.content) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">üìù Response Content</div>
                        <div class="detail-content response">${searchQuery ? highlightKeywords(node.content, searchQuery) : escapeHtml(node.content)}</div>
                    </div>
                `;
            }
            
            if (node.tool_calls && node.tool_calls.length > 0) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">üîß Tool Calls (${node.tool_calls.length})</div>
                        <div class="detail-content tool-calls">${syntaxHighlightJson(node.tool_calls)}</div>
                    </div>
                `;
            }
            
            if (node.usage) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">üìä Token Usage</div>
                        <div class="token-usage">
                            <div class="token-item">
                                <span class="token-label">Prompt</span>
                                <span class="token-value">${node.usage.prompt_tokens || '-'}</span>
                            </div>
                            <div class="token-item">
                                <span class="token-label">Completion</span>
                                <span class="token-value">${node.usage.completion_tokens || '-'}</span>
                            </div>
                            <div class="token-item">
                                <span class="token-label">Total</span>
                                <span class="token-value">${node.usage.total_tokens || '-'}</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            return html || '<div class="detail-content">No response data</div>';
        }
        
        function renderErrorDetails(node) {
            let html = `
                <div class="detail-section">
                    <div class="detail-title">‚ùå ${node.error_type || 'Error'}</div>
                    <div class="detail-content error">${searchQuery ? highlightKeywords(node.message || 'Unknown error', searchQuery) : escapeHtml(node.message || 'Unknown error')}</div>
                </div>
            `;
            
            if (node.stacktrace) {
                html += `
                    <div class="detail-section">
                        <div class="detail-title">üìú Stack Trace</div>
                        <div class="detail-content error">${searchQuery ? highlightKeywords(node.stacktrace, searchQuery) : escapeHtml(node.stacktrace)}</div>
                    </div>
                `;
            }
            
            return html;
        }
        
        function renderMainAgentDetails(node) {
            return `
                <div class="detail-section">
                    <div class="detail-title">ü§ñ Main Agent</div>
                    <div class="detail-content">Status: ${node.status}
Children: ${node.children.length} nodes
Started: ${new Date(node.timestamp).toLocaleString()}</div>
                </div>
            `;
        }
        
        function renderMessages(messages) {
            if (!Array.isArray(messages)) return escapeHtml(JSON.stringify(messages, null, 2));
            
            return messages.map(msg => {
                if (typeof msg === 'string') return escapeHtml(msg);
                return `<div style="margin-bottom: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <div style="font-size: 11px; color: #888; text-transform: uppercase; margin-bottom: 4px;">${msg.role || 'unknown'}</div>
                    <div>${escapeHtml(typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content))}</div>
                </div>`;
            }).join('');
        }
        
        // ============================================
        // JSON Syntax Highlighting (T021)
        // ============================================
        function syntaxHighlightJson(obj) {
            const json = JSON.stringify(obj, null, 2);
            return json
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?)/g, (match) => {
                    let cls = 'json-string';
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    }
                    return `<span class="${cls}">${match}</span>`;
                })
                .replace(/\b(true|false)\b/g, '<span class="json-boolean">$1</span>')
                .replace(/\b(null)\b/g, '<span class="json-null">$1</span>')
                .replace(/\b(-?\d+\.?\d*)\b/g, '<span class="json-number">$1</span>');
        }
        
        // ============================================
        // Event Handlers (T013, T014, T015)
        // ============================================
        function attachNodeEventListeners() {
            document.querySelectorAll('.node-header').forEach(header => {
                header.addEventListener('click', (e) => {
                    const node = header.parentElement;
                    const nodeId = node.dataset.id;
                    
                    if (node.classList.contains('expanded')) {
                        node.classList.remove('expanded');
                        expandedNodes.delete(nodeId);
                    } else {
                        node.classList.add('expanded');
                        expandedNodes.add(nodeId);
                    }
                });
            });
        }
        
        // ============================================
        // Search & Navigation (T026, T027, T028)
        // ============================================
        function handleSearch() {
            searchQuery = searchInput.value.toLowerCase().trim();
            
            if (!searchQuery) {
                matchingNodes.clear();
                matchingNodeIds = [];
                currentMatchIndex = -1;
                matchCountEl.style.display = 'none';
                document.getElementById('prev-match').style.display = 'none';
                document.getElementById('next-match').style.display = 'none';
                if (tree) {
                    clearHighlights(tree);
                    renderTree();
                }
                return;
            }
            
            matchingNodes.clear();
            matchingNodeIds = [];
            if (tree) {
                searchTree(tree, searchQuery);
                
                // Ëá™Âä®Â±ïÂºÄÊâÄÊúâÂåπÈÖçËäÇÁÇπÁöÑË∑ØÂæÑ
                if (matchingNodeIds.length > 0) {
                    matchingNodeIds.forEach(nodeId => {
                        expandNodePath(nodeId);
                    });
                }
                
                matchCountEl.textContent = matchingNodeIds.length > 0 ? `${currentMatchIndex + 1}/${matchingNodeIds.length}` : '0/0';
                matchCountEl.style.display = 'inline';
                
                // Show navigation buttons if there are matches
                if (matchingNodeIds.length > 0) {
                    document.getElementById('prev-match').style.display = 'inline-block';
                    document.getElementById('next-match').style.display = 'inline-block';
                    // Auto jump to first match
                    currentMatchIndex = 0;
                } else {
                    document.getElementById('prev-match').style.display = 'none';
                    document.getElementById('next-match').style.display = 'none';
                    currentMatchIndex = -1;
                }
                
                renderTree();
                
                // Ê∏≤ÊüìÂÆåÊàêÂêéË∑≥ËΩ¨Âà∞Á¨¨‰∏Ä‰∏™ÂåπÈÖçÈ°π
                if (matchingNodeIds.length > 0) {
                    setTimeout(() => {
                        jumpToMatch(0);
                    }, 50);
                }
            }
        }
        
        function searchTree(node, query) {
            let hasMatch = false;
            
            // Check if this node matches
            const searchableText = [
                node.label,
                node.type,
                JSON.stringify(node.input || ''),
                node.output || '',
                node.content || '',
                node.message || ''
            ].join(' ').toLowerCase();
            
            if (searchableText.includes(query)) {
                node.highlighted = true;
                matchingNodes.add(node.id);
                matchingNodeIds.push(node.id);  // Add to ordered list
                hasMatch = true;
            } else {
                node.highlighted = false;
            }
            
            // Check children
            node.hasMatchingChild = false;
            for (const child of node.children) {
                if (searchTree(child, query)) {
                    node.hasMatchingChild = true;
                    hasMatch = true;
                }
            }
            
            return hasMatch;
        }
        
        function navigateMatch(direction) {
            if (matchingNodeIds.length === 0) return;
            
            // ÁßªÈô§‰πãÂâçÂΩìÂâçÂåπÈÖçÈ°πÁöÑÈ¢ùÂ§ñÈ´ò‰∫Æ
            if (currentMatchIndex >= 0 && currentMatchIndex < matchingNodeIds.length) {
                const prevNodeId = matchingNodeIds[currentMatchIndex];
                const prevNodeElement = document.querySelector(`[data-id="${prevNodeId}"]`);
                if (prevNodeElement) {
                    const prevHeader = prevNodeElement.querySelector('.node-header');
                    if (prevHeader) {
                        prevHeader.style.transform = 'scale(1)';
                    }
                }
            }
            
            currentMatchIndex += direction;
            
            // Wrap around
            if (currentMatchIndex < 0) {
                currentMatchIndex = matchingNodeIds.length - 1;
            } else if (currentMatchIndex >= matchingNodeIds.length) {
                currentMatchIndex = 0;
            }
            
            jumpToMatch(currentMatchIndex);
            updateMatchCounter();
        }
        
        function jumpToMatch(index) {
            if (index < 0 || index >= matchingNodeIds.length) return;
            
            const nodeId = matchingNodeIds[index];
            const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
            
            if (!nodeElement) {
                // Node not rendered yet, need to expand parents first
                expandNodePath(nodeId);
                // Re-render and try again
                renderTree();
                setTimeout(() => {
                    const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
                    if (nodeElement) {
                        scrollToNode(nodeElement);
                    }
                }, 100);
                return;
            }
            
            scrollToNode(nodeElement);
        }
        
        function expandNodePath(nodeId) {
            // Find the node in the tree
            function findNode(node, targetId, path = []) {
                if (node.id === targetId) {
                    return path;
                }
                for (const child of node.children) {
                    const result = findNode(child, targetId, [...path, node.id]);
                    if (result) return result;
                }
                return null;
            }
            
            if (!tree) return;
            const path = findNode(tree, nodeId);
            if (path) {
                // Expand all nodes in the path
                path.forEach(id => expandedNodes.add(id));
            }
            // Also expand the target node itself
            expandedNodes.add(nodeId);
        }
        
        function scrollToNode(nodeElement) {
            // Expand the node if collapsed
            if (!nodeElement.classList.contains('expanded')) {
                nodeElement.classList.add('expanded');
                const nodeId = nodeElement.dataset.id;
                expandedNodes.add(nodeId);
            }
            
            // Scroll to the node
            nodeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Á°Æ‰øùÂåπÈÖçÁöÑËäÇÁÇπ‰øùÊåÅÈ´ò‰∫ÆÔºàÈ´ò‰∫ÆÁä∂ÊÄÅÂ∑≤ÁªèÂú®Ê∏≤ÊüìÊó∂ÈÄöËøá node.highlighted ËÆæÁΩÆÔºâ
            const header = nodeElement.querySelector('.node-header');
            if (header) {
                // Â¶ÇÊûúËäÇÁÇπÊòØÂåπÈÖçÁöÑÔºåÊ∑ªÂä†È´ò‰∫ÆÁ±ªÔºàËøô‰∏™Á±ªÂú®Ê∏≤ÊüìÊó∂Â∑≤ÁªèÊ∑ªÂä†Ôºå‰ΩÜÁ°Æ‰øùÂÆÉÂ≠òÂú®Ôºâ
                const nodeId = nodeElement.dataset.id;
                if (matchingNodes.has(nodeId)) {
                    header.classList.add('highlighted');
                }
                
                // Ê∑ªÂä†‰∏Ä‰∏™Áü≠ÊöÇÁöÑËÑâÂÜ≤ÊïàÊûúÊù•Âê∏ÂºïÊ≥®ÊÑèÂäõ
                header.style.transition = 'all 0.3s';
                header.style.transform = 'scale(1.02)';
                setTimeout(() => {
                    header.style.transform = 'scale(1)';
                }, 300);
            }
        }
        
        function updateMatchCounter() {
            if (matchingNodeIds.length > 0) {
                matchCountEl.textContent = `${currentMatchIndex + 1}/${matchingNodeIds.length}`;
            }
        }
        
        function handleSearchKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                // Â¶ÇÊûúËøòÊ≤°ÊúâÂåπÈÖçÁªìÊûúÔºåÂÖàÁ´ãÂç≥ÊâßË°åÊêúÁ¥¢
                if (matchingNodeIds.length === 0 && searchInput.value.trim()) {
                    handleSearch();
                    // Á≠âÂæÖÊêúÁ¥¢ÂÆåÊàêÂêéÂØºËà™
                    setTimeout(() => {
                        if (matchingNodeIds.length > 0) {
                            if (event.shiftKey) {
                                navigateMatch(-1);  // Shift+Enter = previous
                            } else {
                                navigateMatch(1);   // Enter = next
                            }
                        }
                    }, 100);
                } else {
                    if (event.shiftKey) {
                        navigateMatch(-1);  // Shift+Enter = previous
                    } else {
                        navigateMatch(1);   // Enter = next
                    }
                }
            } else if (event.key === 'ArrowUp' && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();
                navigateMatch(-1);
            } else if (event.key === 'ArrowDown' && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();
                navigateMatch(1);
            }
        }
        
        function clearHighlights(node) {
            node.highlighted = false;
            node.hasMatchingChild = false;
            for (const child of node.children) {
                clearHighlights(child);
            }
        }
        
        // ============================================
        // Filters (T029)
        // ============================================
        function applyFilters() {
            renderTree();
        }
        
        // ============================================
        // Stats
        // ============================================
        function updateStats() {
            // LLM rounds = LLM_INPUT events (each input triggers one LLM call)
            const llmRounds = allLogs.filter(l => l.event_type === 'LLM_INPUT').length;
            
            // Tool calls (excluding agent_tool which is counted as sub-agent)
            const toolCalls = allLogs.filter(l => 
                l.event_type === 'TOOL_CALL' && 
                l.data?.phase === 'start' && 
                l.data?.tool_name !== 'agent_tool'
            ).length;
            
            // Sub-agents
            const subAgents = allLogs.filter(l => 
                l.event_type === 'TOOL_CALL' && 
                l.data?.tool_name === 'agent_tool' && 
                l.data?.phase === 'start'
            ).length;
            
            // Errors
            const errors = allLogs.filter(l => l.event_type === 'ERROR').length;
            
            // Total tokens from LLM_RESPONSE usage
            let totalTokens = 0;
            allLogs.filter(l => l.event_type === 'LLM_RESPONSE').forEach(l => {
                const usage = l.data?.usage || {};
                totalTokens += usage.total_tokens || 0;
            });
            
            document.getElementById('stat-llm').textContent = llmRounds;
            document.getElementById('stat-tool').textContent = toolCalls;
            document.getElementById('stat-subagent').textContent = subAgents;
            document.getElementById('stat-error').textContent = errors;
            document.getElementById('stat-tokens').textContent = totalTokens.toLocaleString();
            
            // Show stats bar
            document.getElementById('stats').style.display = 'flex';
        }
        
        // ============================================
        // Collapsible Prompt Toggle
        // ============================================
        function togglePrompt(promptId, toggleEl) {
            const contentEl = document.getElementById(promptId);
            if (!contentEl) return;
            
            const isExpanded = contentEl.classList.contains('expanded');
            
            if (isExpanded) {
                contentEl.classList.remove('expanded');
                toggleEl.classList.remove('expanded');
            } else {
                contentEl.classList.add('expanded');
                toggleEl.classList.add('expanded');
            }
        }
        
        // ============================================
        // Utilities
        // ============================================
        function escapeHtml(text) {
            if (typeof text !== 'string') return String(text);
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // È´ò‰∫ÆÂÖ≥ÈîÆÂ≠óÂáΩÊï∞
        function highlightKeywords(text, query) {
            if (!query || !text) return escapeHtml(text);
            
            const escapedText = escapeHtml(text);
            const escapedQuery = escapeHtml(query);
            
            // ‰ΩøÁî®‰∏çÂå∫ÂàÜÂ§ßÂ∞èÂÜôÁöÑÊ≠£ÂàôË°®ËææÂºèÂåπÈÖç
            const regex = new RegExp(`(${escapedQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            
            return escapedText.replace(regex, '<span class="search-highlight">$1</span>');
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
    </script>
</body>
</html>
