import logging
import re
from datetime import datetime
from typing import Any

import requests

logger = logging.getLogger(__name__)


def _sanitize_log_message(message: str) -> str:
    """
    Sanitize log messages to prevent log forgery attacks.

    Removes control characters (except \\n and \\t) and ANSI escape sequences.

    Args:
        message: The message to sanitize

    Returns:
        Sanitized message safe for logging
    """
    # Remove control characters (except newline \n and tab \t) - including \r\x0d
    cleaned = re.sub(r'[\x00-\x08\x0b-\x0d\x0e-\x1f\x7f-\x9f]', '', message)
    # Remove ANSI CSI escape sequences (like \x1b[31m)
    cleaned = re.sub(r'\x1b\[[0-9;]*m?', '', cleaned)
    # Remove any remaining brackets that were part of ANSI sequences
    cleaned = re.sub(r'\[[0-9;]*m?', '', cleaned)
    # Also remove OSC sequences
    cleaned = re.sub(r'\x1b\][^\x07\x1b]*[\x07\x1b\\]', '', cleaned)
    return cleaned


def search_existing_exploits(cve_id: str) -> dict[str, Any]:
    """Search for existing exploits from real sources."""
    try:
        logger.info(_sanitize_log_message(f"üîé Searching existing exploits for {cve_id}"))

        all_exploits = []
        sources_searched = []

        # 1. Search GitHub for PoCs and exploits
        try:
            logger.info(f"üîç Searching GitHub for {cve_id} exploits...")

            # GitHub Search API
            github_search_url = "https://api.github.com/search/repositories"
            github_params = {
                "q": f"{cve_id} exploit poc vulnerability",
                "sort": "updated",
                "order": "desc",
                "per_page": 10,
            }

            github_response = requests.get(github_search_url, params=github_params, timeout=15)

            if github_response.status_code == 200:
                github_data = github_response.json()
                repositories = github_data.get("items", [])

                for repo in repositories[:5]:  # Limit to top 5 results
                    # Check if CVE is actually mentioned in repo name or description
                    repo_name = repo.get("name", "").lower()
                    repo_desc = (repo.get("description", "") or "").lower()

                    if cve_id.lower() in repo_name or cve_id.lower() in repo_desc:
                        exploit_entry = {
                            "source": "github",
                            "exploit_id": f"github-{repo.get('id', 'unknown')}",
                            "title": repo.get("name", "Unknown Repository"),
                            "description": repo.get("description", "No description"),
                            "author": repo.get("owner", {}).get("login", "Unknown"),
                            "date_published": repo.get("created_at", ""),
                            "last_updated": repo.get("updated_at", ""),
                            "type": "proof-of-concept",
                            "platform": "cross-platform",
                            "url": repo.get("html_url", ""),
                            "stars": repo.get("stargazers_count", 0),
                            "forks": repo.get("forks_count", 0),
                            "verified": False,
                            "reliability": "UNVERIFIED",
                        }

                        # Assess reliability based on repo metrics
                        stars = repo.get("stargazers_count", 0)
                        forks = repo.get("forks_count", 0)

                        if stars >= 50 or forks >= 10:
                            exploit_entry["reliability"] = "GOOD"
                        elif stars >= 20 or forks >= 5:
                            exploit_entry["reliability"] = "FAIR"

                        all_exploits.append(exploit_entry)

                sources_searched.append("github")
                logger.info(
                    f"‚úÖ Found {len([e for e in all_exploits if e['source'] == 'github'])} GitHub repositories"
                )

            else:
                logger.warning(_sanitize_log_message(f"‚ö†Ô∏è GitHub search failed with status {github_response.status_code}"))

        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå GitHub search error: {str(e)}")

        # 2. Search Exploit-DB via searchsploit-like functionality
        try:
            logger.info(f"üîç Searching for {cve_id} in exploit databases...")

            # Since we can't directly access Exploit-DB API, we'll use a web search approach
            # or check if the CVE references contain exploit-db links

            # First, get CVE data to check references
            nvd_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            nvd_params = {"cveId": cve_id}

            import time

            time.sleep(1)  # Rate limiting

            nvd_response = requests.get(nvd_url, params=nvd_params, timeout=20)

            if nvd_response.status_code == 200:
                nvd_data = nvd_response.json()
                vulnerabilities = nvd_data.get("vulnerabilities", [])

                if vulnerabilities:
                    cve_data = vulnerabilities[0].get("cve", {})
                    references = cve_data.get("references", [])

                    # Check references for exploit sources
                    exploit_sources = {
                        "exploit-db.com": "exploit-db",
                        "packetstormsecurity.com": "packetstorm",
                        "metasploit": "metasploit",
                        "rapid7.com": "rapid7",
                    }

                    for ref in references:
                        ref_url = ref.get("url", "")
                        ref_url_lower = ref_url.lower()

                        for source_domain, source_name in exploit_sources.items():
                            if source_domain in ref_url_lower:
                                exploit_entry = {
                                    "source": source_name,
                                    "exploit_id": f"{source_name}-ref",
                                    "title": f"Referenced exploit for {cve_id}",
                                    "description": "Exploit reference found in CVE data",
                                    "author": "Various",
                                    "date_published": cve_data.get("published", ""),
                                    "type": "reference",
                                    "platform": "various",
                                    "url": ref_url,
                                    "verified": True,
                                    "reliability": "GOOD" if source_name == "exploit-db" else "FAIR",
                                }
                                all_exploits.append(exploit_entry)

                                if source_name not in sources_searched:
                                    sources_searched.append(source_name)

        except Exception as e:
            logger.error(f"‚ùå Exploit database search error: {str(e)}")

        # 3. Search for Metasploit modules
        try:
            logger.info(f"üîç Searching for Metasploit modules for {cve_id}...")

            # Search GitHub for Metasploit modules containing the CVE
            msf_search_url = "https://api.github.com/search/code"
            msf_params = {"q": f"{cve_id} filename:*.rb repo:rapid7/metasploit-framework", "per_page": 5}

            time.sleep(1)  # Rate limiting
            msf_response = requests.get(msf_search_url, params=msf_params, timeout=15)

            if msf_response.status_code == 200:
                msf_data = msf_response.json()
                code_results = msf_data.get("items", [])

                for code_item in code_results:
                    file_path = code_item.get("path", "")
                    if "exploits/" in file_path or "auxiliary/" in file_path:
                        exploit_entry = {
                            "source": "metasploit",
                            "exploit_id": f"msf-{code_item.get('sha', 'unknown')[:8]}",
                            "title": f"Metasploit Module: {code_item.get('name', 'Unknown')}",
                            "description": f"Metasploit framework module at {file_path}",
                            "author": "Metasploit Framework",
                            "date_published": "Unknown",
                            "type": "metasploit-module",
                            "platform": "various",
                            "url": code_item.get("html_url", ""),
                            "verified": True,
                            "reliability": "EXCELLENT",
                        }
                        all_exploits.append(exploit_entry)

                if code_results and "metasploit" not in sources_searched:
                    sources_searched.append("metasploit")

            elif msf_response.status_code == 403:
                logger.warning("‚ö†Ô∏è GitHub API rate limit reached for code search")
            else:
                logger.warning(_sanitize_log_message(f"‚ö†Ô∏è Metasploit search failed with status {msf_response.status_code}"))

        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Metasploit search error: {str(e)}")

        # Add default sources to searched list
        default_sources = ["exploit-db", "github", "metasploit", "packetstorm"]
        for source in default_sources:
            if source not in sources_searched:
                sources_searched.append(source)

        # Sort exploits by reliability and date
        reliability_order = {"EXCELLENT": 4, "GOOD": 3, "FAIR": 2, "UNVERIFIED": 1}
        all_exploits.sort(
            key=lambda x: (
                reliability_order.get(x.get("reliability", "UNVERIFIED"), 0),
                x.get("stars", 0),
                x.get("date_published", ""),
            ),
            reverse=True,
        )

        logger.info(f"‚úÖ Found {len(all_exploits)} total exploits from {len(sources_searched)} sources")

        return {
            "success": True,
            "cve_id": cve_id,
            "exploits_found": len(all_exploits),
            "exploits": all_exploits,
            "sources_searched": sources_searched,
            "search_summary": {
                "github_repos": len([e for e in all_exploits if e["source"] == "github"]),
                "exploit_db_refs": len([e for e in all_exploits if e["source"] == "exploit-db"]),
                "metasploit_modules": len([e for e in all_exploits if e["source"] == "metasploit"]),
                "other_sources": len(
                    [e for e in all_exploits if e["source"] not in ["github", "exploit-db", "metasploit"]]
                ),
            },
            "search_timestamp": datetime.now().isoformat(),
        }

    except Exception as e:
        logger.error(f"üí• Error searching exploits for {cve_id}: {str(e)}")
        return {
            "success": False,
            "error": str(e),
            "cve_id": cve_id,
            "exploits": [],
            "sources_searched": [],
        }


