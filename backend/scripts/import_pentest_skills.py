#!/usr/bin/env python3
"""
æ‰¹é‡å¯¼å…¥æ¸—é€æµ‹è¯•æŠ€èƒ½åˆ° JoySafeter æŠ€èƒ½å¸‚åœº

ä½¿ç”¨æ–¹æ³•:
    uv run python scripts/import_pentest_skills.py --owner-id <USER_UUID>

å‚æ•°:
    --owner-id: æŠ€èƒ½æ‰€æœ‰è€… UUID (å¿…éœ€)
    --is-public: æ˜¯å¦å…¬å¼€ (é»˜è®¤ true)
    --update-existing: æ›´æ–°å·²å­˜åœ¨çš„æŠ€èƒ½ (é»˜è®¤ true)
    --dry-run: é¢„è§ˆæ¨¡å¼ï¼Œä¸å®é™…å¯¼å…¥
"""

import argparse
import asyncio
import sys
from pathlib import Path
from typing import Dict, List

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import async_session_factory
from app.models.auth import AuthUser
from app.services.skill_service import SkillService

# æºç›®å½•é…ç½® - ä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼Œä» backend/scripts/ å®šä½åˆ°é¡¹ç›®æ ¹ç›®å½•çš„ skills/
SOURCE_DIR = Path(__file__).parent.parent.parent / "skills"


class ImportStats:
    """å¯¼å…¥ç»Ÿè®¡"""

    def __init__(self):
        self.total = 0
        self.success = 0
        self.updated = 0
        self.failed = 0
        self.total_files = 0
        self.errors: List[Dict[str, str]] = []

    def add_success(self, skill_name: str, file_count: int, is_update: bool = False):
        self.success += 1
        if is_update:
            self.updated += 1
        self.total_files += file_count
        print(f"  âœ… {skill_name} - {file_count} ä¸ªæ–‡ä»¶")

    def add_failure(self, skill_name: str, error: str):
        self.failed += 1
        self.errors.append({"skill": skill_name, "error": error})
        print(f"  âŒ {skill_name} - å¤±è´¥: {error}")

    def print_report(self):
        """æ‰“å°æœ€ç»ˆæŠ¥å‘Š"""
        print("\n" + "=" * 60)
        print("å¯¼å…¥å®Œæˆï¼")
        print("=" * 60)
        print(f"âœ… æˆåŠŸå¯¼å…¥: {self.success} ä¸ªæŠ€èƒ½")
        print(f"ğŸ”„ æ›´æ–°è¦†ç›–: {self.updated} ä¸ªæŠ€èƒ½")
        print(f"âŒ å¤±è´¥: {self.failed} ä¸ªæŠ€èƒ½")
        print(f"ğŸ“ æ€»æ–‡ä»¶æ•°: {self.total_files} ä¸ª")

        if self.errors:
            print("\nå¤±è´¥è¯¦æƒ…:")
            for err in self.errors:
                print(f"  - {err['skill']}: {err['error']}")


async def verify_owner_exists(session: AsyncSession, owner_id: str) -> bool:
    """éªŒè¯ owner_id æ˜¯å¦å­˜åœ¨"""
    result = await session.execute(select(AuthUser).where(AuthUser.id == owner_id))
    user = result.scalar_one_or_none()
    return user is not None


def scan_skill_directories(source_dir: Path) -> List[Path]:
    """æ‰«ææºç›®å½•ï¼Œè·å–æ‰€æœ‰æœ‰æ•ˆçš„æŠ€èƒ½ç›®å½•"""
    skill_dirs = []

    if not source_dir.exists():
        raise FileNotFoundError(f"æºç›®å½•ä¸å­˜åœ¨: {source_dir}")

    for item in source_dir.iterdir():
        if item.is_dir() and not item.name.startswith("."):
            # æ£€æŸ¥æ˜¯å¦åŒ…å« SKILL.md
            skill_md = item / "SKILL.md"
            skill_md_lower = item / "skill.md"

            if skill_md.exists() or skill_md_lower.exists():
                skill_dirs.append(item)

    return sorted(skill_dirs)


async def import_single_skill(
    session: AsyncSession,
    skill_dir: Path,
    owner_id: str,
    is_public: bool,
    dry_run: bool,
    stats: ImportStats,
) -> None:
    """å¯¼å…¥å•ä¸ªæŠ€èƒ½"""
    skill_name = skill_dir.name

    try:
        if dry_run:
            print(f"  [DRY RUN] {skill_name}")
            # è®¡ç®—æ–‡ä»¶æ•°é‡
            file_count = sum(1 for _ in skill_dir.rglob("*") if _.is_file())
            stats.add_success(skill_name, file_count, False)
            return

        # ä½¿ç”¨ SkillService å¯¼å…¥
        skill_service = SkillService(session)

        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        try:
            await skill_service.get_skill_by_name(skill_name, current_user_id=owner_id)
            is_update = True
        except Exception:
            is_update = False

        # æ‰§è¡Œå¯¼å…¥
        skill = await skill_service.import_skill_from_directory(
            skill_dir=str(skill_dir),
            owner_id=owner_id,
            is_public=is_public,
        )

        # ç»Ÿè®¡æ–‡ä»¶æ•°é‡
        file_count = len(skill.files) if skill.files else 0
        stats.add_success(skill_name, file_count, is_update)

    except Exception as e:
        stats.add_failure(skill_name, str(e))


async def import_all_skills(
    owner_id: str,
    is_public: bool = True,
    dry_run: bool = False,
) -> ImportStats:
    """æ‰¹é‡å¯¼å…¥æ‰€æœ‰æŠ€èƒ½"""
    stats = ImportStats()

    # é¢„æ£€æŸ¥
    print("ğŸ” é¢„æ£€æŸ¥...")
    print(f"  æºç›®å½•: {SOURCE_DIR}")

    # æ‰«ææŠ€èƒ½ç›®å½•
    skill_dirs = scan_skill_directories(SOURCE_DIR)
    stats.total = len(skill_dirs)

    print(f"  æ‰¾åˆ° {stats.total} ä¸ªæŠ€èƒ½ç›®å½•")

    if stats.total == 0:
        print("âŒ æœªæ‰¾åˆ°ä»»ä½•æŠ€èƒ½ç›®å½•")
        return stats

    # éªŒè¯ owner_id
    async with async_session_factory() as session:
        if not await verify_owner_exists(session, owner_id):
            print(f"âŒ Owner ID ä¸å­˜åœ¨: {owner_id}")
            print("\næç¤º: ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æŸ¥è¯¢ç°æœ‰ç”¨æˆ·:")
            print("  psql -d joysafeter -c 'SELECT id, username FROM \"user\";'")
            sys.exit(1)

    print(f"  Owner ID éªŒè¯é€šè¿‡: {owner_id}")
    print(f"  å…¬å¼€çŠ¶æ€: {'æ˜¯' if is_public else 'å¦'}")

    if dry_run:
        print("\nâš ï¸  DRY RUN æ¨¡å¼ - ä¸ä¼šå®é™…å¯¼å…¥\n")

    # å¼€å§‹å¯¼å…¥
    print(f"\nğŸ“¦ å¼€å§‹å¯¼å…¥ {stats.total} ä¸ªæŠ€èƒ½...\n")

    for idx, skill_dir in enumerate(skill_dirs, 1):
        print(f"[{idx}/{stats.total}] {skill_dir.name}")

        async with async_session_factory() as session:
            await import_single_skill(
                session=session,
                skill_dir=skill_dir,
                owner_id=owner_id,
                is_public=is_public,
                dry_run=dry_run,
                stats=stats,
            )

    return stats


def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(
        description="æ‰¹é‡å¯¼å…¥æ¸—é€æµ‹è¯•æŠ€èƒ½åˆ° JoySafeter æŠ€èƒ½å¸‚åœº",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "--owner-id",
        required=True,
        help="æŠ€èƒ½æ‰€æœ‰è€… UUID (å¿…éœ€)",
    )

    parser.add_argument(
        "--is-public",
        action="store_true",
        default=True,
        help="æ˜¯å¦å…¬å¼€ (é»˜è®¤ true)",
    )

    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="é¢„è§ˆæ¨¡å¼ï¼Œä¸å®é™…å¯¼å…¥",
    )

    args = parser.parse_args()

    # è¿è¡Œå¯¼å…¥
    stats = asyncio.run(
        import_all_skills(
            owner_id=args.owner_id,
            is_public=args.is_public,
            dry_run=args.dry_run,
        )
    )

    # æ‰“å°æŠ¥å‘Š
    stats.print_report()

    # è¿”å›é€€å‡ºç 
    sys.exit(0 if stats.failed == 0 else 1)


if __name__ == "__main__":
    main()
