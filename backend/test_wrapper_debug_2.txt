============================= test session starts ==============================
platform darwin -- Python 3.13.5, pytest-9.0.2, pluggy-1.6.0
rootdir: /Users/yuzhenjiang1/Downloads/workspace/JoySafeter/backend
configfile: pyproject.toml
plugins: langsmith-0.5.2, anyio-4.12.0, asyncio-1.3.0
asyncio: mode=Mode.AUTO, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 2 items

tests/core/graph/test_global_error.py F.                                 [100%]

=================================== FAILURES ===================================
___________________________ test_global_error_policy ___________________________

    @pytest.mark.asyncio
    async def test_global_error_policy():
        """Test that an unhandled exception triggers a jump to the fallback node."""

        # Define a node that raises an error
        error_node = NodeSchema(
            id="node_error",
            type="function_node",
            label="Error Node",
        )

        # Define a fallback node
        fallback_node = NodeSchema(
            id="node_fallback",
            type="function_node",
            label="Fallback Node",
        )

        # Define state fields
        state_fields = [
            StateFieldSchema(name="result", field_type="any", reducer="replace"),
            StateFieldSchema(name="error", field_type="string", reducer="replace"),
            StateFieldSchema(name="error_source_node", field_type="string", reducer="replace"),
            StateFieldSchema(name="error_timestamp", field_type="float", reducer="replace"),
        ]

        schema = GraphSchema(
            name="Error Policy Test",
            nodes=[error_node, fallback_node],
            edges=[
                EdgeSchema(source="node_error", target="node_fallback"),
            ],
            fallback_node_id="node_fallback",
            state_fields=state_fields,
            use_default_state=False,
        )

        # Mock builder to create executors
        class MockNode:
            def __init__(self, node_id):
                self.id = node_id

        class MockBuilder:
            def __init__(self):
                # Populate builder.nodes with mocks matching schema IDs
                self.nodes = [
                    MockNode("node_error"),
                    MockNode("node_fallback")
                ]
                self._node_id_to_name = {}

            async def _get_or_create_executor(self, db_node, name):
                # Return simple async callables
                if name.startswith("node_error"):
                    async def error_exec(state: GraphState):
                        raise ValueError("Intentional Failure")
                    return error_exec
                else:
                    async def fallback_exec(state: GraphState):
                        # Fallback node logic
                        return {"result": "Recovered"}
                    return fallback_exec

            async def _create_node_executor(self, *args):
                pass

        # Compile
        result = await compile_from_schema(schema, builder=MockBuilder(), checkpointer=False)
        compiled = result.compiled_graph

        # Run
        # Current LangGraph behavior: Command(goto=...) interrupts the current node and schedules the target.
        # We need to ensure we can run it.

        inputs = GraphState()

        # Use a try-except block just in case, but expectation is graceful handling
        try:
            # Run until end. The 'node_error' should be the start node implicitly or explicit start
            # If no start node defined, we need to be careful.
            # graph_compiler auto-adds start edge to nodes with no incoming.
            # Here 'node_error' has no incoming, so it's a start node.

            final_state = await compiled.ainvoke(inputs)

            print(f"DEBUG: final_state type: {type(final_state)}")
            print(f"DEBUG: final_state content: {final_state}")

            # Check if fallback was executed
            # The fallback node returns {"result": "Recovered"}
            # And the wrapper adds "error" info to state before jumping

            if final_state is None:
                 pytest.fail("final_state is None! Check graph execution.")

            assert final_state.get("result") == "Recovered"
>           assert final_state.get("error") == "Intentional Failure"
E           AssertionError: assert None == 'Intentional Failure'
E            +  where None = <built-in method get of dict object at 0x113c1a300>('error')
E            +    where <built-in method get of dict object at 0x113c1a300> = {'result': 'Recovered'}.get

tests/core/graph/test_global_error.py:106: AssertionError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_global_error_policy():
        """Test that an unhandled exception triggers a jump to the fallback node."""

        # Define a node that raises an error
        error_node = NodeSchema(
            id="node_error",
            type="function_node",
            label="Error Node",
        )

        # Define a fallback node
        fallback_node = NodeSchema(
            id="node_fallback",
            type="function_node",
            label="Fallback Node",
        )

        # Define state fields
        state_fields = [
            StateFieldSchema(name="result", field_type="any", reducer="replace"),
            StateFieldSchema(name="error", field_type="string", reducer="replace"),
            StateFieldSchema(name="error_source_node", field_type="string", reducer="replace"),
            StateFieldSchema(name="error_timestamp", field_type="float", reducer="replace"),
        ]

        schema = GraphSchema(
            name="Error Policy Test",
            nodes=[error_node, fallback_node],
            edges=[
                EdgeSchema(source="node_error", target="node_fallback"),
            ],
            fallback_node_id="node_fallback",
            state_fields=state_fields,
            use_default_state=False,
        )

        # Mock builder to create executors
        class MockNode:
            def __init__(self, node_id):
                self.id = node_id

        class MockBuilder:
            def __init__(self):
                # Populate builder.nodes with mocks matching schema IDs
                self.nodes = [
                    MockNode("node_error"),
                    MockNode("node_fallback")
                ]
                self._node_id_to_name = {}

            async def _get_or_create_executor(self, db_node, name):
                # Return simple async callables
                if name.startswith("node_error"):
                    async def error_exec(state: GraphState):
                        raise ValueError("Intentional Failure")
                    return error_exec
                else:
                    async def fallback_exec(state: GraphState):
                        # Fallback node logic
                        return {"result": "Recovered"}
                    return fallback_exec

            async def _create_node_executor(self, *args):
                pass

        # Compile
        result = await compile_from_schema(schema, builder=MockBuilder(), checkpointer=False)
        compiled = result.compiled_graph

        # Run
        # Current LangGraph behavior: Command(goto=...) interrupts the current node and schedules the target.
        # We need to ensure we can run it.

        inputs = GraphState()

        # Use a try-except block just in case, but expectation is graceful handling
        try:
            # Run until end. The 'node_error' should be the start node implicitly or explicit start
            # If no start node defined, we need to be careful.
            # graph_compiler auto-adds start edge to nodes with no incoming.
            # Here 'node_error' has no incoming, so it's a start node.

            final_state = await compiled.ainvoke(inputs)

            print(f"DEBUG: final_state type: {type(final_state)}")
            print(f"DEBUG: final_state content: {final_state}")

            # Check if fallback was executed
            # The fallback node returns {"result": "Recovered"}
            # And the wrapper adds "error" info to state before jumping

            if final_state is None:
                 pytest.fail("final_state is None! Check graph execution.")

            assert final_state.get("result") == "Recovered"
            assert final_state.get("error") == "Intentional Failure"
            assert final_state.get("error_source_node") == "node_error"

        except Exception as e:
>           pytest.fail(f"Graph raised exception instead of fallback: {e}")
E           Failed: Graph raised exception instead of fallback: assert None == 'Intentional Failure'
E            +  where None = <built-in method get of dict object at 0x113c1a300>('error')
E            +    where <built-in method get of dict object at 0x113c1a300> = {'result': 'Recovered'}.get

tests/core/graph/test_global_error.py:110: Failed
----------------------------- Captured stdout call -----------------------------
DEBUG: NodeExecutionWrapper initialized. COMMAND_AVAILABLE=True, fallback=Fallback_Node
DEBUG: NodeExecutionWrapper initialized. COMMAND_AVAILABLE=True, fallback=None
DEBUG: final_state type: <class 'dict'>
DEBUG: final_state content: {'result': 'Recovered'}
----------------------------- Captured stderr call -----------------------------
2026-02-15 17:15:52.537 | INFO     | app.core.graph.graph_compiler:compile_from_schema:121 - [GraphCompiler] ========== Starting schema compilation ========== | name='Error Policy Test' | nodes=2 | edges=1
2026-02-15 17:15:52.537 | INFO     | app.core.graph.graph_compiler:compile_from_schema:135 - [GraphCompiler] Built dynamic state class with 4 custom fields
2026-02-15 17:15:52.537 | INFO     | app.core.graph.graph_compiler:compile_from_schema:200 - [GraphCompiler] Identified 0 loop body nodes | 0 parallel nodes
2026-02-15 17:15:52.537 | INFO     | app.core.graph.graph_compiler:compile_from_schema:215 - [GraphCompiler] Global error fallback enabled -> Fallback_Node
2026-02-15 17:15:52.538 | INFO     | app.core.graph.graph_compiler:compile_from_schema:354 - [GraphCompiler] ========== Compilation complete ========== | elapsed=1.56ms | nodes=2 | edges=1
2026-02-15 17:15:52.539 | INFO     | app.core.graph.trace_utils:log_node_execution:161 - [Trace] Node execution completed | node_id=node_error | node_type=function_node | duration=0.01ms
2026-02-15 17:15:52.539 | INFO     | app.core.graph.trace_utils:log_node_execution:161 - [Trace] Node execution completed | node_id=node_fallback | node_type=function_node | duration=0.00ms
=============================== warnings summary ===============================
app/schemas/graph_deployment_version.py:12
  /Users/yuzhenjiang1/Downloads/workspace/JoySafeter/backend/app/schemas/graph_deployment_version.py:12: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class GraphDeploymentVersionResponse(BaseModel):

app/schemas/graph_deployment_version.py:26
  /Users/yuzhenjiang1/Downloads/workspace/JoySafeter/backend/app/schemas/graph_deployment_version.py:26: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class GraphDeploymentVersionResponseCamel(BaseModel):

app/schemas/graph_deployment_version.py:41
  /Users/yuzhenjiang1/Downloads/workspace/JoySafeter/backend/app/schemas/graph_deployment_version.py:41: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class GraphDeploymentVersionStateResponse(BaseModel):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/core/graph/test_global_error.py::test_global_error_policy - Fail...
=================== 1 failed, 1 passed, 3 warnings in 1.38s ====================
