{
  "skills": [
    {
      "id": "container_scanning-clair_vulnerability_scan",
      "name": "Clair Vulnerability Scan",
      "description": "Execute Clair for container vulnerability analysis. image: Container image to scan config: Clair configuration file output_format: Output format (json, yaml) additional_args: Additional Clair arguments",
      "license": "MIT",
      "content": "---\nname: clair_vulnerability_scan\ncapabilities: ['image', 'config', 'output-format', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'clair']\n---\n\n# Clair Vulnerability Scan\n\nExecute Clair for container vulnerability analysis. image: Container image to scan config: Clair configuration file output_format: Output format (json, yaml) additional_args: Additional Clair arguments\n\n## Parameters\n- **image** (string, Required): Container image to scan\n- **config** (string, Optional) (default: /etc/clair/config.yaml): Clair configuration file\n- **output_format** (string, Optional) (default: json): Output format (json, yaml)\n- **additional_args** (string, Optional): Additional Clair arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/clair`\n\n**Returns:** Container vulnerability analysis results\n\n## Files Included\n\n- `clair_vulnerability_scan.yaml` - Tool configuration\n- `clair_vulnerability_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: clair_vulnerability_scan\ncapabilities: ['image', 'config', 'output-format', 'additional-args']\ncategory: container_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'clair']\n---\n\n# Clair Vulnerability Scan\n\nExecute Clair for container vulnerability analysis. image: Container image to scan config: Clair configuration file output_format: Output format (json, yaml) additional_args: Additional Clair arguments\n\n## Parameters\n- **image** (string, Required): Container image to scan\n- **config** (string, Optional) (default: /etc/clair/config.yaml): Clair configuration file\n- **output_format** (string, Optional) (default: json): Output format (json, yaml)\n- **additional_args** (string, Optional): Additional Clair arguments\n\n\n## Usage\n\nThis tool is part of the container_scanning category.\n\n**Endpoint:** `api/tools/clair`\n\n**Returns:** Container vulnerability analysis results\n\n## Files Included\n\n- `clair_vulnerability_scan.yaml` - Tool configuration\n- `clair_vulnerability_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "clair_vulnerability_scan.yaml",
          "content": "name: clair_vulnerability_scan\ncategory: container_scanning\ntags: [vulnerability_assessment, penetration_testing, clair]\nendpoint: api/tools/clair\ndescription: 'Execute Clair for container vulnerability analysis. image: Container\n  image to scan config: Clair configuration file output_format: Output format (json,\n  yaml) additional_args: Additional Clair arguments'\nreturns: Container vulnerability analysis results\nparameters:\n- name: image\n  type: string\n  required: true\n  description: Container image to scan\n- name: config\n  type: string\n  required: false\n  description: Clair configuration file\n  default: /etc/clair/config.yaml\n- name: output_format\n  type: string\n  required: false\n  description: Output format (json, yaml)\n  default: json\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Clair arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "clair_vulnerability_scan.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass ClairHandler(AbstractHandler):\n    \"\"\"Handler for clair functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute clair with enhanced logging\"\"\"\n        try:\n            image = data.get(\"image\", \"\")\n            config = data.get(\"config\", \"/etc/clair/config.yaml\")\n            output_format = data.get(\"output_format\", \"json\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not image:\n                logger.warning(\"ðŸ³ Clair called without image parameter\")\n                return {\"error\": \"Image parameter is required\"}\n            command = f\"clairctl analyze {image}\"\n            if config:\n                command += f\" --config {config}\"\n            if output_format:\n                command += f\" --format {output_format}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ³ Starting Clair vulnerability scan: {image}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Clair scan completed for {image}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in clair endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640254
    },
    {
      "id": "web_application_scanning-nuclei_scan",
      "name": "Nuclei Scan",
      "description": "Execute Nuclei vulnerability scanner with enhanced logging and real-time progress. target: The target URL or IP severity: Filter by severity (critical,high,medium,low,info) tags: Filter by tags (e.g. cve,rce,lfi) template: Custom template path additional_args: Additional Nuclei arguments",
      "license": "MIT",
      "content": "---\nname: nuclei_scan\ncapabilities: ['target', 'severity', 'tags', 'template', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nuclei']\n---\n\n# Nuclei Scan\n\nExecute Nuclei vulnerability scanner with enhanced logging and real-time progress. target: The target URL or IP severity: Filter by severity (critical,high,medium,low,info) tags: Filter by tags (e.g. cve,rce,lfi) template: Custom template path additional_args: Additional Nuclei arguments\n\n## Parameters\n- **target** (string, Required): The target URL or IP\n- **severity** (string, Optional): Filter by severity (critical,high,medium,low,info)\n- **tags** (string, Optional): Filter by tags (e.g. cve,rce,lfi)\n- **template** (string, Optional): Custom template path\n- **additional_args** (string, Optional): Additional Nuclei arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/nuclei`\n\n**Returns:** Scan results with discovered vulnerabilities and telemetry\n\n## Files Included\n\n- `nuclei_scan.yaml` - Tool configuration\n- `nuclei_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: nuclei_scan\ncapabilities: ['target', 'severity', 'tags', 'template', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nuclei']\n---\n\n# Nuclei Scan\n\nExecute Nuclei vulnerability scanner with enhanced logging and real-time progress. target: The target URL or IP severity: Filter by severity (critical,high,medium,low,info) tags: Filter by tags (e.g. cve,rce,lfi) template: Custom template path additional_args: Additional Nuclei arguments\n\n## Parameters\n- **target** (string, Required): The target URL or IP\n- **severity** (string, Optional): Filter by severity (critical,high,medium,low,info)\n- **tags** (string, Optional): Filter by tags (e.g. cve,rce,lfi)\n- **template** (string, Optional): Custom template path\n- **additional_args** (string, Optional): Additional Nuclei arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/nuclei`\n\n**Returns:** Scan results with discovered vulnerabilities and telemetry\n\n## Files Included\n\n- `nuclei_scan.yaml` - Tool configuration\n- `nuclei_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "nuclei_scan.yaml",
          "content": "name: nuclei_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, nuclei]\nendpoint: api/tools/nuclei\ndescription: 'Execute Nuclei vulnerability scanner with enhanced logging and real-time\n  progress. target: The target URL or IP severity: Filter by severity (critical,high,medium,low,info)\n  tags: Filter by tags (e.g. cve,rce,lfi) template: Custom template path additional_args:\n  Additional Nuclei arguments'\nreturns: Scan results with discovered vulnerabilities and telemetry\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target URL or IP\n- name: severity\n  type: string\n  required: false\n  description: Filter by severity (critical,high,medium,low,info)\n  default: ''\n- name: tags\n  type: string\n  required: false\n  description: Filter by tags (e.g. cve,rce,lfi)\n  default: ''\n- name: template\n  type: string\n  required: false\n  description: Custom template path\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Nuclei arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "nuclei_scan.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass NucleiHandler(AbstractHandler):\n    \"\"\"Handler for nuclei functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute nuclei with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            severity = data.get(\"severity\", \"\")\n            tags = data.get(\"tags\", \"\")\n            template = data.get(\"template\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ Nuclei called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"nuclei -u {target}\"\n            if severity:\n                command += f\" -severity {severity}\"\n            if tags:\n                command += f\" -tags {tags}\"\n            if template:\n                command += f\" -t {template}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”¬ Starting Nuclei vulnerability scan: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Nuclei scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in nuclei endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640256
    },
    {
      "id": "web_application_scanning-jaeles_vulnerability_scan",
      "name": "Jaeles Vulnerability Scan",
      "description": "Execute Jaeles for advanced vulnerability scanning with custom signatures. url: The target URL signatures: Custom signature path config: Configuration file threads: Number of threads timeout: Request timeout additional_args: Additional Jaeles arguments",
      "license": "MIT",
      "content": "---\nname: jaeles_vulnerability_scan\ncapabilities: ['url', 'signatures', 'config', 'threads', 'timeout', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'jaeles']\n---\n\n# Jaeles Vulnerability Scan\n\nExecute Jaeles for advanced vulnerability scanning with custom signatures. url: The target URL signatures: Custom signature path config: Configuration file threads: Number of threads timeout: Request timeout additional_args: Additional Jaeles arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **signatures** (string, Optional): Custom signature path\n- **config** (string, Optional): Configuration file\n- **threads** (integer, Optional) (default: 20): Number of threads\n- **timeout** (integer, Optional) (default: 20): Request timeout\n- **additional_args** (string, Optional): Additional Jaeles arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/jaeles`\n\n**Returns:** Advanced vulnerability scanning results with custom signatures\n\n## Files Included\n\n- `jaeles_vulnerability_scan.yaml` - Tool configuration\n- `jaeles_vulnerability_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: jaeles_vulnerability_scan\ncapabilities: ['url', 'signatures', 'config', 'threads', 'timeout', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'jaeles']\n---\n\n# Jaeles Vulnerability Scan\n\nExecute Jaeles for advanced vulnerability scanning with custom signatures. url: The target URL signatures: Custom signature path config: Configuration file threads: Number of threads timeout: Request timeout additional_args: Additional Jaeles arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **signatures** (string, Optional): Custom signature path\n- **config** (string, Optional): Configuration file\n- **threads** (integer, Optional) (default: 20): Number of threads\n- **timeout** (integer, Optional) (default: 20): Request timeout\n- **additional_args** (string, Optional): Additional Jaeles arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/jaeles`\n\n**Returns:** Advanced vulnerability scanning results with custom signatures\n\n## Files Included\n\n- `jaeles_vulnerability_scan.yaml` - Tool configuration\n- `jaeles_vulnerability_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "jaeles_vulnerability_scan.yaml",
          "content": "name: jaeles_vulnerability_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, jaeles]\nendpoint: api/tools/jaeles\ndescription: 'Execute Jaeles for advanced vulnerability scanning with custom signatures.\n  url: The target URL signatures: Custom signature path config: Configuration file\n  threads: Number of threads timeout: Request timeout additional_args: Additional\n  Jaeles arguments'\nreturns: Advanced vulnerability scanning results with custom signatures\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL\n- name: signatures\n  type: string\n  required: false\n  description: Custom signature path\n  default: ''\n- name: config\n  type: string\n  required: false\n  description: Configuration file\n  default: ''\n- name: threads\n  type: integer\n  required: false\n  description: Number of threads\n  default: 20\n- name: timeout\n  type: integer\n  required: false\n  description: Request timeout\n  default: 20\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Jaeles arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "jaeles_vulnerability_scan.py",
          "content": "import logging\nfrom typing import Any, Dict\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass JaelesHandler(AbstractHandler):\n    \"\"\"Handler for jaeles functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute jaeles with enhanced logging\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            signatures = data.get(\"signatures\", \"\")\n            config = data.get(\"config\", \"\")\n            threads = data.get(\"threads\", 20)\n            timeout = data.get(\"timeout\", 20)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not url:\n                logger.warning(\"ðŸŒ Jaeles called without URL parameter\")\n                return {\"error\": \"URL parameter is required\"}\n            command = f\"jaeles scan -u {url} -c {threads} --timeout {timeout}\"\n            if signatures:\n                command += f\" -s {signatures}\"\n            if config:\n                command += f\" --config {config}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”¬ Starting Jaeles vulnerability scan: {url}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Jaeles vulnerability scan completed for {url}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in jaeles endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640258
    },
    {
      "id": "network_scanning-rpcclient_enumeration",
      "name": "Rpcclient Enumeration",
      "description": "Execute rpcclient for RPC enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication commands: Semicolon-separated RPC commands additional_args: Additional rpcclient arguments",
      "license": "MIT",
      "content": "---\nname: rpcclient_enumeration\ncapabilities: ['target', 'username', 'password', 'domain', 'commands', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'rpcclient']\n---\n\n# Rpcclient Enumeration\n\nExecute rpcclient for RPC enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication commands: Semicolon-separated RPC commands additional_args: Additional rpcclient arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **commands** (string, Optional) (default: enumdomusers;enumdomgroups;querydominfo): Semicolon-separated RPC commands\n- **additional_args** (string, Optional): Additional rpcclient arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/rpcclient`\n\n**Returns:** RPC enumeration results\n\n## Files Included\n\n- `rpcclient_enumeration.yaml` - Tool configuration\n- `rpcclient_enumeration.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: rpcclient_enumeration\ncapabilities: ['target', 'username', 'password', 'domain', 'commands', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'rpcclient']\n---\n\n# Rpcclient Enumeration\n\nExecute rpcclient for RPC enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication commands: Semicolon-separated RPC commands additional_args: Additional rpcclient arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **commands** (string, Optional) (default: enumdomusers;enumdomgroups;querydominfo): Semicolon-separated RPC commands\n- **additional_args** (string, Optional): Additional rpcclient arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/rpcclient`\n\n**Returns:** RPC enumeration results\n\n## Files Included\n\n- `rpcclient_enumeration.yaml` - Tool configuration\n- `rpcclient_enumeration.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "rpcclient_enumeration.yaml",
          "content": "name: rpcclient_enumeration\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, rpcclient]\nendpoint: api/tools/rpcclient\ndescription: 'Execute rpcclient for RPC enumeration with enhanced logging. target:\n  The target IP address username: Username for authentication password: Password for\n  authentication domain: Domain for authentication commands: Semicolon-separated RPC\n  commands additional_args: Additional rpcclient arguments'\nreturns: RPC enumeration results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address\n- name: username\n  type: string\n  required: false\n  description: Username for authentication\n  default: ''\n- name: password\n  type: string\n  required: false\n  description: Password for authentication\n  default: ''\n- name: domain\n  type: string\n  required: false\n  description: Domain for authentication\n  default: ''\n- name: commands\n  type: string\n  required: false\n  description: Semicolon-separated RPC commands\n  default: enumdomusers;enumdomgroups;querydominfo\n- name: additional_args\n  type: string\n  required: false\n  description: Additional rpcclient arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "rpcclient_enumeration.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass RpcclientHandler(AbstractHandler):\n    \"\"\"Handler for rpcclient functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute rpcclient with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            username = data.get(\"username\", \"\")\n            password = data.get(\"password\", \"\")\n            domain = data.get(\"domain\", \"\")\n            commands = data.get(\"commands\", \"enumdomusers;enumdomgroups;querydominfo\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ rpcclient called without target parameter\")\n                return {\"error\": \"Target parameter is required\"}\n            if username and password:\n                auth_string = f\"-U {username}%{password}\"\n            elif username:\n                auth_string = f\"-U {username}\"\n            else:\n                auth_string = \"-U ''\"  # Anonymous\n            if domain:\n                auth_string += f\" -W {domain}\"\n            command_sequence = commands.replace(\";\", \"\\n\")\n            command = f\"echo -e '{command_sequence}' | rpcclient {auth_string} {target}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting rpcclient: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š rpcclient completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in rpcclient endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640259
    },
    {
      "id": "web_application_scanning-zap_scan",
      "name": "Zap Scan",
      "description": "Execute OWASP ZAP with enhanced logging. target: Target URL scan_type: Type of scan (baseline, full, api) api_key: ZAP API key daemon: Run in daemon mode port: Port for ZAP daemon host: Host for ZAP daemon format_type: Output format (xml, json, html) output_file: Output file path additional_args: Additional ZAP arguments",
      "license": "MIT",
      "content": "---\nname: zap_scan\ncapabilities: ['target', 'scan-type', 'api-key', 'daemon', 'port', 'host', 'format-type', 'output-file', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'owasp', 'zap']\n---\n\n# Zap Scan\n\nExecute OWASP ZAP with enhanced logging. target: Target URL scan_type: Type of scan (baseline, full, api) api_key: ZAP API key daemon: Run in daemon mode port: Port for ZAP daemon host: Host for ZAP daemon format_type: Output format (xml, json, html) output_file: Output file path additional_args: Additional ZAP arguments\n\n## Parameters\n- **target** (string, Optional): Target URL\n- **scan_type** (string, Optional) (default: baseline): Type of scan (baseline, full, api)\n- **api_key** (string, Optional): ZAP API key\n- **daemon** (boolean, Optional): Run in daemon mode\n- **port** (string, Optional) (default: 8090): Port for ZAP daemon\n- **host** (string, Optional) (default: 0.0.0.0): Host for ZAP daemon\n- **format_type** (string, Optional) (default: xml): Output format (xml, json, html)\n- **output_file** (string, Optional): Output file path\n- **additional_args** (string, Optional): Additional ZAP arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/zap`\n\n**Returns:** ZAP scan results\n\n## Files Included\n\n- `zap_scan.yaml` - Tool configuration\n- `zap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: zap_scan\ncapabilities: ['target', 'scan-type', 'api-key', 'daemon', 'port', 'host', 'format-type', 'output-file', 'additional-args']\ncategory: web_application_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'owasp', 'zap']\n---\n\n# Zap Scan\n\nExecute OWASP ZAP with enhanced logging. target: Target URL scan_type: Type of scan (baseline, full, api) api_key: ZAP API key daemon: Run in daemon mode port: Port for ZAP daemon host: Host for ZAP daemon format_type: Output format (xml, json, html) output_file: Output file path additional_args: Additional ZAP arguments\n\n## Parameters\n- **target** (string, Optional): Target URL\n- **scan_type** (string, Optional) (default: baseline): Type of scan (baseline, full, api)\n- **api_key** (string, Optional): ZAP API key\n- **daemon** (boolean, Optional): Run in daemon mode\n- **port** (string, Optional) (default: 8090): Port for ZAP daemon\n- **host** (string, Optional) (default: 0.0.0.0): Host for ZAP daemon\n- **format_type** (string, Optional) (default: xml): Output format (xml, json, html)\n- **output_file** (string, Optional): Output file path\n- **additional_args** (string, Optional): Additional ZAP arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/zap`\n\n**Returns:** ZAP scan results\n\n## Files Included\n\n- `zap_scan.yaml` - Tool configuration\n- `zap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "zap_scan.yaml",
          "content": "name: zap_scan\ncategory: web_application_scanning\ntags: [vulnerability_assessment, penetration_testing, owasp, zap]\nendpoint: api/tools/zap\ndescription: 'Execute OWASP ZAP with enhanced logging. target: Target URL scan_type:\n  Type of scan (baseline, full, api) api_key: ZAP API key daemon: Run in daemon mode\n  port: Port for ZAP daemon host: Host for ZAP daemon format_type: Output format (xml,\n  json, html) output_file: Output file path additional_args: Additional ZAP arguments'\nreturns: ZAP scan results\nparameters:\n- name: target\n  type: string\n  required: false\n  description: Target URL\n  default: ''\n- name: scan_type\n  type: string\n  required: false\n  description: Type of scan (baseline, full, api)\n  default: baseline\n- name: api_key\n  type: string\n  required: false\n  description: ZAP API key\n  default: ''\n- name: daemon\n  type: boolean\n  required: false\n  description: Run in daemon mode\n  default: false\n- name: port\n  type: string\n  required: false\n  description: Port for ZAP daemon\n  default: '8090'\n- name: host\n  type: string\n  required: false\n  description: Host for ZAP daemon\n  default: 0.0.0.0\n- name: format_type\n  type: string\n  required: false\n  description: Output format (xml, json, html)\n  default: xml\n- name: output_file\n  type: string\n  required: false\n  description: Output file path\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional ZAP arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "zap_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass ZapHandler(AbstractHandler):\n    \"\"\"Handler for zap functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute zap with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            scan_type = data.get(\"scan_type\", \"baseline\")\n            api_key = data.get(\"api_key\", \"\")\n            daemon = data.get(\"daemon\", False)\n            port = data.get(\"port\", \"8090\")\n            host = data.get(\"host\", \"0.0.0.0\")\n            format_type = data.get(\"format\", \"xml\")\n            output_file = data.get(\"output_file\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target and scan_type != \"daemon\":\n                logger.warning(\"ðŸŽ¯ ZAP called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required for scans\"\n                \n                }\n            if daemon:\n                command = f\"zaproxy -daemon -host {host} -port {port}\"\n                if api_key:\n                    command += f\" -config api.key={api_key}\"\n            else:\n                command = f\"zaproxy -cmd -quickurl {target}\"\n                if format_type:\n                    command += f\" -quickout {format_type}\"\n                if output_file:\n                    command += f\" -quickprogress -dir \\\"{output_file}\\\"\"\n                if api_key:\n                    command += f\" -config api.key={api_key}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting ZAP scan: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š ZAP scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in zap endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640261
    },
    {
      "id": "binary_vulnerability_analysis-xxd_hexdump",
      "name": "Xxd Hexdump",
      "description": "Create a hex dump of a file using xxd with enhanced logging. file_path: Path to the file offset: Offset to start reading from length: Number of bytes to read additional_args: Additional xxd arguments",
      "license": "MIT",
      "content": "---\nname: xxd_hexdump\ncapabilities: ['file-path', 'offset', 'length', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'xxd']\n---\n\n# Xxd Hexdump\n\nCreate a hex dump of a file using xxd with enhanced logging. file_path: Path to the file offset: Offset to start reading from length: Number of bytes to read additional_args: Additional xxd arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file\n- **offset** (string, Optional) (default: 0): Offset to start reading from\n- **length** (string, Optional): Number of bytes to read\n- **additional_args** (string, Optional): Additional xxd arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/xxd`\n\n**Returns:** Hex dump results\n\n## Files Included\n\n- `xxd_hexdump.yaml` - Tool configuration\n- `xxd_hexdump.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: xxd_hexdump\ncapabilities: ['file-path', 'offset', 'length', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'xxd']\n---\n\n# Xxd Hexdump\n\nCreate a hex dump of a file using xxd with enhanced logging. file_path: Path to the file offset: Offset to start reading from length: Number of bytes to read additional_args: Additional xxd arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file\n- **offset** (string, Optional) (default: 0): Offset to start reading from\n- **length** (string, Optional): Number of bytes to read\n- **additional_args** (string, Optional): Additional xxd arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/xxd`\n\n**Returns:** Hex dump results\n\n## Files Included\n\n- `xxd_hexdump.yaml` - Tool configuration\n- `xxd_hexdump.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "xxd_hexdump.yaml",
          "content": "name: xxd_hexdump\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, xxd]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/xxd\ndescription: 'Create a hex dump of a file using xxd with enhanced logging. file_path:\n  Path to the file offset: Offset to start reading from length: Number of bytes to\n  read additional_args: Additional xxd arguments'\nreturns: Hex dump results\nparameters:\n- name: file_path\n  type: string\n  required: true\n  description: Path to the file\n- name: offset\n  type: string\n  required: false\n  description: Offset to start reading from\n  default: '0'\n- name: length\n  type: string\n  required: false\n  description: Number of bytes to read\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional xxd arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "xxd_hexdump.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass XxdHandler(AbstractHandler):\n    \"\"\"Handler for xxd functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute xxd with enhanced logging\"\"\"\n        try:\n            file_path = data.get(\"file_path\", \"\")\n            offset = data.get(\"offset\", \"0\")\n            length = data.get(\"length\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not file_path:\n                logger.warning(\"ðŸ”§ XXD called without file_path parameter\")\n                return {\n    \n                    \"error\": \"File path parameter is required\"\n                \n                }\n            command = f\"xxd -s {offset}\"\n            if length:\n                command += f\" -l {length}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {file_path}\"\n            logger.info(f\"ðŸ”§ Starting XXD hex dump: {file_path}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š XXD hex dump completed for {file_path}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in xxd endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640262
    },
    {
      "id": "binary_exploitation-libc_database_lookup",
      "name": "Libc Database Lookup",
      "description": "Execute libc-database for libc identification and offset lookup. action: Action to perform (find, dump, download) symbols: Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\") libc_id: Libc ID for dump/download actions additional_args: Additional arguments",
      "license": "MIT",
      "content": "---\nname: libc_database_lookup\ncapabilities: ['action', 'symbols', 'libc-id', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'libc-database']\n---\n\n# Libc Database Lookup\n\nExecute libc-database for libc identification and offset lookup. action: Action to perform (find, dump, download) symbols: Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\") libc_id: Libc ID for dump/download actions additional_args: Additional arguments\n\n## Parameters\n- **action** (string, Optional) (default: find): Action to perform (find, dump, download)\n- **symbols** (string, Optional): Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\")\n- **libc_id** (string, Optional): Libc ID for dump/download actions\n- **additional_args** (string, Optional): Additional arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/libc-database`\n\n**Returns:** Libc database lookup results\n\n## Files Included\n\n- `libc_database_lookup.yaml` - Tool configuration\n- `libc_database_lookup.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: libc_database_lookup\ncapabilities: ['action', 'symbols', 'libc-id', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'libc-database']\n---\n\n# Libc Database Lookup\n\nExecute libc-database for libc identification and offset lookup. action: Action to perform (find, dump, download) symbols: Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\") libc_id: Libc ID for dump/download actions additional_args: Additional arguments\n\n## Parameters\n- **action** (string, Optional) (default: find): Action to perform (find, dump, download)\n- **symbols** (string, Optional): Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\")\n- **libc_id** (string, Optional): Libc ID for dump/download actions\n- **additional_args** (string, Optional): Additional arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/libc-database`\n\n**Returns:** Libc database lookup results\n\n## Files Included\n\n- `libc_database_lookup.yaml` - Tool configuration\n- `libc_database_lookup.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "libc_database_lookup.yaml",
          "content": "name: libc_database_lookup\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, libc-database]\ncategory: binary_exploitation\nendpoint: api/tools/libc-database\ndescription: 'Execute libc-database for libc identification and offset lookup. action:\n  Action to perform (find, dump, download) symbols: Symbols with offsets for find\n  action (format: \"symbol1:offset1 symbol2:offset2\") libc_id: Libc ID for dump/download\n  actions additional_args: Additional arguments'\nreturns: Libc database lookup results\nparameters:\n- name: action\n  type: string\n  required: false\n  description: Action to perform (find, dump, download)\n  default: find\n- name: symbols\n  type: string\n  required: false\n  description: 'Symbols with offsets for find action (format: \"symbol1:offset1 symbol2:offset2\")'\n  default: ''\n- name: libc_id\n  type: string\n  required: false\n  description: Libc ID for dump/download actions\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "libc_database_lookup.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass LibcDatabaseHandler(AbstractHandler):\n    \"\"\"Handler for libc_database functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute libc_database with enhanced logging\"\"\"\n        try:\n            action = data.get(\"action\", \"find\")  # find, dump, download\n            symbols = data.get(\"symbols\", \"\")  # format: \"symbol1:offset1 symbol2:offset2\"\n            libc_id = data.get(\"libc_id\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if action == \"find\" and not symbols:\n                logger.warning(\"ðŸ”§ libc-database find called without symbols\")\n                return {\"error\": \"Symbols parameter is required for find action\"}\n            if action in [\"dump\", \"download\"] and not libc_id:\n                logger.warning(\"ðŸ”§ libc-database called without libc_id for dump/download\")\n                return {\"error\": \"libc_id parameter is required for dump/download actions\"}\n            base_command = \"cd /opt/libc-database 2>/dev/null || cd ~/libc-database 2>/dev/null || echo 'libc-database not found'\"\n            if action == \"find\":\n                command = f\"{base_command} && ./find {symbols}\"\n            elif action == \"dump\":\n                command = f\"{base_command} && ./dump {libc_id}\"\n            elif action == \"download\":\n                command = f\"{base_command} && ./download {libc_id}\"\n            else:\n                return {\"error\": f\"Invalid action: {action}\"}\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting libc-database {action}: {symbols or libc_id}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š libc-database {action} completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in libc-database endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640264
    },
    {
      "id": "binary_exploitation-ropper_gadget_search",
      "name": "Ropper Gadget Search",
      "description": "Execute ropper for advanced ROP/JOP gadget searching. binary: Binary to search for gadgets gadget_type: Type of gadgets (rop, jop, sys, all) quality: Gadget quality level (1-5) arch: Target architecture (x86, x86_64, arm, etc.) search_string: Specific gadget pattern to search for additional_args: Additional ropper arguments",
      "license": "MIT",
      "content": "---\nname: ropper_gadget_search\ncapabilities: ['binary', 'gadget-type', 'quality', 'arch', 'search-string', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ropper']\n---\n\n# Ropper Gadget Search\n\nExecute ropper for advanced ROP/JOP gadget searching. binary: Binary to search for gadgets gadget_type: Type of gadgets (rop, jop, sys, all) quality: Gadget quality level (1-5) arch: Target architecture (x86, x86_64, arm, etc.) search_string: Specific gadget pattern to search for additional_args: Additional ropper arguments\n\n## Parameters\n- **binary** (string, Required): Binary to search for gadgets\n- **gadget_type** (string, Optional) (default: rop): Type of gadgets (rop, jop, sys, all)\n- **quality** (integer, Optional) (default: 1): Gadget quality level (1-5)\n- **arch** (string, Optional): Target architecture (x86, x86_64, arm, etc.)\n- **search_string** (string, Optional): Specific gadget pattern to search for\n- **additional_args** (string, Optional): Additional ropper arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/ropper`\n\n**Returns:** Advanced ROP/JOP gadget search results\n\n## Files Included\n\n- `ropper_gadget_search.yaml` - Tool configuration\n- `ropper_gadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: ropper_gadget_search\ncapabilities: ['binary', 'gadget-type', 'quality', 'arch', 'search-string', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ropper']\n---\n\n# Ropper Gadget Search\n\nExecute ropper for advanced ROP/JOP gadget searching. binary: Binary to search for gadgets gadget_type: Type of gadgets (rop, jop, sys, all) quality: Gadget quality level (1-5) arch: Target architecture (x86, x86_64, arm, etc.) search_string: Specific gadget pattern to search for additional_args: Additional ropper arguments\n\n## Parameters\n- **binary** (string, Required): Binary to search for gadgets\n- **gadget_type** (string, Optional) (default: rop): Type of gadgets (rop, jop, sys, all)\n- **quality** (integer, Optional) (default: 1): Gadget quality level (1-5)\n- **arch** (string, Optional): Target architecture (x86, x86_64, arm, etc.)\n- **search_string** (string, Optional): Specific gadget pattern to search for\n- **additional_args** (string, Optional): Additional ropper arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/ropper`\n\n**Returns:** Advanced ROP/JOP gadget search results\n\n## Files Included\n\n- `ropper_gadget_search.yaml` - Tool configuration\n- `ropper_gadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "ropper_gadget_search.yaml",
          "content": "name: ropper_gadget_search\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, ropper]\ncategory: binary_exploitation\nendpoint: api/tools/ropper\ndescription: 'Execute ropper for advanced ROP/JOP gadget searching. binary: Binary\n  to search for gadgets gadget_type: Type of gadgets (rop, jop, sys, all) quality:\n  Gadget quality level (1-5) arch: Target architecture (x86, x86_64, arm, etc.) search_string:\n  Specific gadget pattern to search for additional_args: Additional ropper arguments'\nreturns: Advanced ROP/JOP gadget search results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Binary to search for gadgets\n- name: gadget_type\n  type: string\n  required: false\n  description: Type of gadgets (rop, jop, sys, all)\n  default: rop\n- name: quality\n  type: integer\n  required: false\n  description: Gadget quality level (1-5)\n  default: 1\n- name: arch\n  type: string\n  required: false\n  description: Target architecture (x86, x86_64, arm, etc.)\n  default: ''\n- name: search_string\n  type: string\n  required: false\n  description: Specific gadget pattern to search for\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional ropper arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "ropper_gadget_search.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass RopperHandler(AbstractHandler):\n    \"\"\"Handler for ropper functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute ropper with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            gadget_type = data.get(\"gadget_type\", \"rop\")  # rop, jop, sys, all\n            quality = data.get(\"quality\", 1)  # 1-5, higher = better quality\n            arch = data.get(\"arch\", \"\")  # x86, x86_64, arm, etc.\n            search_string = data.get(\"search_string\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ ropper called without binary parameter\")\n                return {\"error\": \"Binary parameter is required\"}\n            command = f\"ropper --file {binary}\"\n            if gadget_type == \"rop\":\n                command += \" --rop\"\n            elif gadget_type == \"jop\":\n                command += \" --jop\"\n            elif gadget_type == \"sys\":\n                command += \" --sys\"\n            elif gadget_type == \"all\":\n                command += \" --all\"\n            if quality > 1:\n                command += f\" --quality {quality}\"\n            if arch:\n                command += f\" --arch {arch}\"\n            if search_string:\n                command += f\" --search '{search_string}'\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting ropper analysis: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š ropper analysis completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in ropper endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640266
    },
    {
      "id": "binary_exploitation-ropgadget_search",
      "name": "Ropgadget Search",
      "description": "Search for ROP gadgets in a binary using ROPgadget with enhanced logging. binary: Path to the binary file gadget_type: Type of gadgets to search for additional_args: Additional ROPgadget arguments",
      "license": "MIT",
      "content": "---\nname: ropgadget_search\ncapabilities: ['binary', 'gadget-type', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ropgadget']\n---\n\n# Ropgadget Search\n\nSearch for ROP gadgets in a binary using ROPgadget with enhanced logging. binary: Path to the binary file gadget_type: Type of gadgets to search for additional_args: Additional ROPgadget arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **gadget_type** (string, Optional): Type of gadgets to search for\n- **additional_args** (string, Optional): Additional ROPgadget arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/ropgadget`\n\n**Returns:** ROP gadget search results\n\n## Files Included\n\n- `ropgadget_search.yaml` - Tool configuration\n- `ropgadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: ropgadget_search\ncapabilities: ['binary', 'gadget-type', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ropgadget']\n---\n\n# Ropgadget Search\n\nSearch for ROP gadgets in a binary using ROPgadget with enhanced logging. binary: Path to the binary file gadget_type: Type of gadgets to search for additional_args: Additional ROPgadget arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **gadget_type** (string, Optional): Type of gadgets to search for\n- **additional_args** (string, Optional): Additional ROPgadget arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/ropgadget`\n\n**Returns:** ROP gadget search results\n\n## Files Included\n\n- `ropgadget_search.yaml` - Tool configuration\n- `ropgadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "ropgadget_search.yaml",
          "content": "name: ropgadget_search\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, ropgadget]\ncategory: binary_exploitation\nendpoint: api/tools/ropgadget\ndescription: 'Search for ROP gadgets in a binary using ROPgadget with enhanced logging.\n  binary: Path to the binary file gadget_type: Type of gadgets to search for additional_args:\n  Additional ROPgadget arguments'\nreturns: ROP gadget search results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: gadget_type\n  type: string\n  required: false\n  description: Type of gadgets to search for\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional ROPgadget arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "ropgadget_search.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass RopgadgetHandler(AbstractHandler):\n    \"\"\"Handler for ropgadget functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute ropgadget with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            gadget_type = data.get(\"gadget_type\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ ROPgadget called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            command = f\"ROPgadget --binary {binary}\"\n            if gadget_type:\n                command += f\" --only '{gadget_type}'\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting ROPgadget search: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š ROPgadget search completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in ropgadget endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640267
    },
    {
      "id": "binary_exploitation-gdb_peda_debug",
      "name": "Gdb Peda Debug",
      "description": "Execute GDB with PEDA for enhanced debugging and exploitation. binary: Binary to debug commands: GDB commands to execute attach_pid: Process ID to attach to core_file: Core dump file to analyze additional_args: Additional GDB arguments",
      "license": "MIT",
      "content": "---\nname: gdb_peda_debug\ncapabilities: ['binary', 'commands', 'attach-pid', 'core-file', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'gdb', 'peda']\n---\n\n# Gdb Peda Debug\n\nExecute GDB with PEDA for enhanced debugging and exploitation. binary: Binary to debug commands: GDB commands to execute attach_pid: Process ID to attach to core_file: Core dump file to analyze additional_args: Additional GDB arguments\n\n## Parameters\n- **binary** (string, Optional): Binary to debug\n- **commands** (string, Optional): GDB commands to execute\n- **attach_pid** (integer, Optional): Process ID to attach to\n- **core_file** (string, Optional): Core dump file to analyze\n- **additional_args** (string, Optional): Additional GDB arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/gdb-peda`\n\n**Returns:** Enhanced debugging results with PEDA\n\n## Files Included\n\n- `gdb_peda_debug.yaml` - Tool configuration\n- `gdb_peda_debug.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: gdb_peda_debug\ncapabilities: ['binary', 'commands', 'attach-pid', 'core-file', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'gdb', 'peda']\n---\n\n# Gdb Peda Debug\n\nExecute GDB with PEDA for enhanced debugging and exploitation. binary: Binary to debug commands: GDB commands to execute attach_pid: Process ID to attach to core_file: Core dump file to analyze additional_args: Additional GDB arguments\n\n## Parameters\n- **binary** (string, Optional): Binary to debug\n- **commands** (string, Optional): GDB commands to execute\n- **attach_pid** (integer, Optional): Process ID to attach to\n- **core_file** (string, Optional): Core dump file to analyze\n- **additional_args** (string, Optional): Additional GDB arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/gdb-peda`\n\n**Returns:** Enhanced debugging results with PEDA\n\n## Files Included\n\n- `gdb_peda_debug.yaml` - Tool configuration\n- `gdb_peda_debug.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "gdb_peda_debug.yaml",
          "content": "name: gdb_peda_debug\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, gdb, peda]\ncategory: binary_exploitation\nendpoint: api/tools/gdb-peda\ndescription: 'Execute GDB with PEDA for enhanced debugging and exploitation. binary:\n  Binary to debug commands: GDB commands to execute attach_pid: Process ID to attach\n  to core_file: Core dump file to analyze additional_args: Additional GDB arguments'\nreturns: Enhanced debugging results with PEDA\nparameters:\n- name: binary\n  type: string\n  required: false\n  description: Binary to debug\n  default: ''\n- name: commands\n  type: string\n  required: false\n  description: GDB commands to execute\n  default: ''\n- name: attach_pid\n  type: integer\n  required: false\n  description: Process ID to attach to\n  default: 0\n- name: core_file\n  type: string\n  required: false\n  description: Core dump file to analyze\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional GDB arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "gdb_peda_debug.py",
          "content": "import os\nfrom typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass GdbPedaHandler(AbstractHandler):\n    \"\"\"Handler for gdb_peda functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        try:\n            binary = data.get(\"binary\", \"\")\n            commands = data.get(\"commands\", \"\")\n            attach_pid = data.get(\"attach_pid\", 0)\n            core_file = data.get(\"core_file\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n    \n            if not binary and not attach_pid and not core_file:\n                logger.warning(\"ðŸ”§ GDB-PEDA called without binary, PID, or core file\")\n                return {\"error\": \"Binary, PID, or core file parameter is required\"}\n    \n            # Base GDB command with PEDA\n            command = \"gdb -q\"\n    \n            if binary:\n                command += f\" {binary}\"\n    \n            if core_file:\n                command += f\" {core_file}\"\n    \n            if attach_pid:\n                command += f\" -p {attach_pid}\"\n    \n            # Create command script\n            if commands:\n                temp_script = \"/tmp/gdb_peda_commands.txt\"\n                peda_commands = f\"\"\"\n    source ~/peda/peda.py\n    {commands}\n    quit\n    \"\"\"\n                with open(temp_script, \"w\") as f:\n                    f.write(peda_commands)\n                command += f\" -x {temp_script}\"\n            else:\n                # Default PEDA initialization\n                command += \" -ex 'source ~/peda/peda.py' -ex 'quit'\"\n    \n            if additional_args:\n                command += f\" {additional_args}\"\n    \n            target_info = binary or f'PID {attach_pid}' or core_file\n            logger.info(f\"ðŸ”§ Starting GDB-PEDA analysis: {target_info}\")\n            result = execute_command(command)\n    \n            # Cleanup\n            if commands and os.path.exists(\"/tmp/gdb_peda_commands.txt\"):\n                try:\n                    os.remove(\"/tmp/gdb_peda_commands.txt\")\n                except:\n                    pass\n    \n            logger.info(f\"ðŸ“Š GDB-PEDA analysis completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in gdb-peda endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640269
    },
    {
      "id": "binary_vulnerability_analysis-radare2_analyze",
      "name": "Radare2 Analyze",
      "description": "Execute Radare2 for binary analysis and reverse engineering with enhanced logging. binary: Path to the binary file commands: Radare2 commands to execute additional_args: Additional Radare2 arguments",
      "license": "MIT",
      "content": "---\nname: radare2_analyze\ncapabilities: ['binary', 'commands', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'radare2']\n---\n\n# Radare2 Analyze\n\nExecute Radare2 for binary analysis and reverse engineering with enhanced logging. binary: Path to the binary file commands: Radare2 commands to execute additional_args: Additional Radare2 arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **commands** (string, Optional): Radare2 commands to execute\n- **additional_args** (string, Optional): Additional Radare2 arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/radare2`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `radare2_analyze.yaml` - Tool configuration\n- `radare2_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: radare2_analyze\ncapabilities: ['binary', 'commands', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'radare2']\n---\n\n# Radare2 Analyze\n\nExecute Radare2 for binary analysis and reverse engineering with enhanced logging. binary: Path to the binary file commands: Radare2 commands to execute additional_args: Additional Radare2 arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **commands** (string, Optional): Radare2 commands to execute\n- **additional_args** (string, Optional): Additional Radare2 arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/radare2`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `radare2_analyze.yaml` - Tool configuration\n- `radare2_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "radare2_analyze.yaml",
          "content": "name: radare2_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, radare2]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/radare2\ndescription: 'Execute Radare2 for binary analysis and reverse engineering with enhanced\n  logging. binary: Path to the binary file commands: Radare2 commands to execute additional_args:\n  Additional Radare2 arguments'\nreturns: Binary analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: commands\n  type: string\n  required: false\n  description: Radare2 commands to execute\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Radare2 arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "radare2_analyze.py",
          "content": "import os\nfrom typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass Radare2Handler(AbstractHandler):\n    \"\"\"Handler for radare2 functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute radare2 with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            commands = data.get(\"commands\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ Radare2 called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            if commands:\n                temp_script = \"/tmp/r2_commands.txt\"\n                with open(temp_script, \"w\") as f:\n                    f.write(commands)\n                command = f\"r2 -i {temp_script} -q {binary}\"\n            else:\n                command = f\"r2 -q {binary}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting Radare2 analysis: {binary}\")\n            result = execute_command(command)\n            # todo rm files\n            if commands and os.path.exists(\"/tmp/r2_commands.txt\"):\n                try:\n                    os.remove(\"/tmp/r2_commands.txt\")\n                except:\n                    pass\n            logger.info(f\"ðŸ“Š Radare2 analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in radare2 endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640270
    },
    {
      "id": "binary_exploitation-one_gadget_search",
      "name": "One Gadget Search",
      "description": "Execute one_gadget to find one-shot RCE gadgets in libc. libc_path: Path to libc binary level: Constraint level (0, 1, 2) additional_args: Additional one_gadget arguments",
      "license": "MIT",
      "content": "---\nname: one_gadget_search\ncapabilities: ['libc-path', 'level', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'one_gadget']\n---\n\n# One Gadget Search\n\nExecute one_gadget to find one-shot RCE gadgets in libc. libc_path: Path to libc binary level: Constraint level (0, 1, 2) additional_args: Additional one_gadget arguments\n\n## Parameters\n- **libc_path** (string, Required): Path to libc binary\n- **level** (integer, Optional) (default: 1): Constraint level (0, 1, 2)\n- **additional_args** (string, Optional): Additional one_gadget arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/one-gadget`\n\n**Returns:** One-shot RCE gadget search results\n\n## Files Included\n\n- `one_gadget_search.yaml` - Tool configuration\n- `one_gadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: one_gadget_search\ncapabilities: ['libc-path', 'level', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'one_gadget']\n---\n\n# One Gadget Search\n\nExecute one_gadget to find one-shot RCE gadgets in libc. libc_path: Path to libc binary level: Constraint level (0, 1, 2) additional_args: Additional one_gadget arguments\n\n## Parameters\n- **libc_path** (string, Required): Path to libc binary\n- **level** (integer, Optional) (default: 1): Constraint level (0, 1, 2)\n- **additional_args** (string, Optional): Additional one_gadget arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/one-gadget`\n\n**Returns:** One-shot RCE gadget search results\n\n## Files Included\n\n- `one_gadget_search.yaml` - Tool configuration\n- `one_gadget_search.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "one_gadget_search.yaml",
          "content": "name: one_gadget_search\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, one_gadget]\ncategory: binary_exploitation\nendpoint: api/tools/one-gadget\ndescription: 'Execute one_gadget to find one-shot RCE gadgets in libc. libc_path:\n  Path to libc binary level: Constraint level (0, 1, 2) additional_args: Additional\n  one_gadget arguments'\nreturns: One-shot RCE gadget search results\nparameters:\n- name: libc_path\n  type: string\n  required: true\n  description: Path to libc binary\n- name: level\n  type: integer\n  required: false\n  description: Constraint level (0, 1, 2)\n  default: 1\n- name: additional_args\n  type: string\n  required: false\n  description: Additional one_gadget arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "one_gadget_search.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass OneGadgetHandler(AbstractHandler):\n    \"\"\"Handler for one_gadget functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute one_gadget with enhanced logging\"\"\"\n        try:\n            libc_path = data.get(\"libc_path\", \"\")\n            level = data.get(\"level\", 1)  # 0, 1, 2 for different constraint levels\n            additional_args = data.get(\"additional_args\", \"\")\n            if not libc_path:\n                logger.warning(\"ðŸ”§ one_gadget called without libc_path parameter\")\n                return {\"error\": \"libc_path parameter is required\"}\n            command = f\"one_gadget {libc_path} --level {level}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting one_gadget analysis: {libc_path}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š one_gadget analysis completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in one_gadget endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640271
    },
    {
      "id": "binary_vulnerability_analysis-binwalk_analyze",
      "name": "Binwalk Analyze",
      "description": "Execute Binwalk for firmware and file analysis with enhanced logging. file_path: Path to the file to analyze extract: Whether to extract discovered files additional_args: Additional Binwalk arguments",
      "license": "MIT",
      "content": "---\nname: binwalk_analyze\ncapabilities: ['file-path', 'extract', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'binwalk']\n---\n\n# Binwalk Analyze\n\nExecute Binwalk for firmware and file analysis with enhanced logging. file_path: Path to the file to analyze extract: Whether to extract discovered files additional_args: Additional Binwalk arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file to analyze\n- **extract** (boolean, Optional): Whether to extract discovered files\n- **additional_args** (string, Optional): Additional Binwalk arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/binwalk`\n\n**Returns:** Firmware analysis results\n\n## Files Included\n\n- `binwalk_analyze.yaml` - Tool configuration\n- `binwalk_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: binwalk_analyze\ncapabilities: ['file-path', 'extract', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'binwalk']\n---\n\n# Binwalk Analyze\n\nExecute Binwalk for firmware and file analysis with enhanced logging. file_path: Path to the file to analyze extract: Whether to extract discovered files additional_args: Additional Binwalk arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file to analyze\n- **extract** (boolean, Optional): Whether to extract discovered files\n- **additional_args** (string, Optional): Additional Binwalk arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/binwalk`\n\n**Returns:** Firmware analysis results\n\n## Files Included\n\n- `binwalk_analyze.yaml` - Tool configuration\n- `binwalk_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "binwalk_analyze.yaml",
          "content": "name: binwalk_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, binwalk]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/binwalk\ndescription: 'Execute Binwalk for firmware and file analysis with enhanced logging.\n  file_path: Path to the file to analyze extract: Whether to extract discovered files\n  additional_args: Additional Binwalk arguments'\nreturns: Firmware analysis results\nparameters:\n- name: file_path\n  type: string\n  required: true\n  description: Path to the file to analyze\n- name: extract\n  type: boolean\n  required: false\n  description: Whether to extract discovered files\n  default: false\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Binwalk arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "binwalk_analyze.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass BinwalkHandler(AbstractHandler):\n    \"\"\"Handler for binwalk functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute binwalk with enhanced logging\"\"\"\n        try:\n            file_path = data.get(\"file_path\", \"\")\n            extract = data.get(\"extract\", False)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not file_path:\n                logger.warning(\"ðŸ”§ Binwalk called without file_path parameter\")\n                return {\n    \n                    \"error\": \"File path parameter is required\"\n                \n                }\n            command = f\"binwalk\"\n            if extract:\n                command += \" -e\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {file_path}\"\n            logger.info(f\"ðŸ”§ Starting Binwalk analysis: {file_path}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Binwalk analysis completed for {file_path}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in binwalk endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640273
    },
    {
      "id": "binary_vulnerability_analysis-objdump_analyze",
      "name": "Objdump Analyze",
      "description": "Analyze a binary using objdump with enhanced logging. binary: Path to the binary file disassemble: Whether to disassemble the binary additional_args: Additional objdump arguments",
      "license": "MIT",
      "content": "---\nname: objdump_analyze\ncapabilities: ['binary', 'disassemble', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'objdump']\n---\n\n# Objdump Analyze\n\nAnalyze a binary using objdump with enhanced logging. binary: Path to the binary file disassemble: Whether to disassemble the binary additional_args: Additional objdump arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **disassemble** (boolean, Optional) (default: True): Whether to disassemble the binary\n- **additional_args** (string, Optional): Additional objdump arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/objdump`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `objdump_analyze.yaml` - Tool configuration\n- `objdump_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: objdump_analyze\ncapabilities: ['binary', 'disassemble', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'objdump']\n---\n\n# Objdump Analyze\n\nAnalyze a binary using objdump with enhanced logging. binary: Path to the binary file disassemble: Whether to disassemble the binary additional_args: Additional objdump arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **disassemble** (boolean, Optional) (default: True): Whether to disassemble the binary\n- **additional_args** (string, Optional): Additional objdump arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/objdump`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `objdump_analyze.yaml` - Tool configuration\n- `objdump_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "objdump_analyze.yaml",
          "content": "name: objdump_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, objdump]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/objdump\ndescription: 'Analyze a binary using objdump with enhanced logging. binary: Path to\n  the binary file disassemble: Whether to disassemble the binary additional_args:\n  Additional objdump arguments'\nreturns: Binary analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: disassemble\n  type: boolean\n  required: false\n  description: Whether to disassemble the binary\n  default: true\n- name: additional_args\n  type: string\n  required: false\n  description: Additional objdump arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "objdump_analyze.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass ObjdumpHandler(AbstractHandler):\n    \"\"\"Handler for objdump functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute objdump with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            disassemble = data.get(\"disassemble\", True)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ Objdump called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            command = f\"objdump\"\n            if disassemble:\n                command += \" -d\"\n            else:\n                command += \" -x\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {binary}\"\n            logger.info(f\"ðŸ”§ Starting Objdump analysis: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Objdump analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in objdump endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640274
    },
    {
      "id": "binary_vulnerability_analysis-checksec_analyze",
      "name": "Checksec Analyze",
      "description": "Check security features of a binary with enhanced logging. binary: Path to the binary file",
      "license": "MIT",
      "content": "---\nname: checksec_analyze\ncapabilities: ['binary']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'checksec']\n---\n\n# Checksec Analyze\n\nCheck security features of a binary with enhanced logging. binary: Path to the binary file\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/checksec`\n\n**Returns:** Security features analysis results\n\n## Files Included\n\n- `checksec_analyze.yaml` - Tool configuration\n- `checksec_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: checksec_analyze\ncapabilities: ['binary']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'checksec']\n---\n\n# Checksec Analyze\n\nCheck security features of a binary with enhanced logging. binary: Path to the binary file\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/checksec`\n\n**Returns:** Security features analysis results\n\n## Files Included\n\n- `checksec_analyze.yaml` - Tool configuration\n- `checksec_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "checksec_analyze.yaml",
          "content": "name: checksec_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, checksec]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/checksec\ndescription: 'Check security features of a binary with enhanced logging. binary: Path\n  to the binary file'\nreturns: Security features analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n",
          "language": "yaml"
        },
        {
          "name": "checksec_analyze.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass ChecksecHandler(AbstractHandler):\n    \"\"\"Handler for checksec functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute checksec with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ Checksec called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            command = f\"checksec --file={binary}\"\n            logger.info(f\"ðŸ”§ Starting Checksec analysis: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Checksec analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in checksec endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640274
    },
    {
      "id": "binary_vulnerability_analysis-gdb_analyze",
      "name": "Gdb Analyze",
      "description": "Execute GDB for binary analysis and debugging with enhanced logging. binary: Path to the binary file commands: GDB commands to execute script_file: Path to GDB script file additional_args: Additional GDB arguments",
      "license": "MIT",
      "content": "---\nname: gdb_analyze\ncapabilities: ['binary', 'commands', 'script-file', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'gdb']\n---\n\n# Gdb Analyze\n\nExecute GDB for binary analysis and debugging with enhanced logging. binary: Path to the binary file commands: GDB commands to execute script_file: Path to GDB script file additional_args: Additional GDB arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **commands** (string, Optional): GDB commands to execute\n- **script_file** (string, Optional): Path to GDB script file\n- **additional_args** (string, Optional): Additional GDB arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/gdb`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `gdb_analyze.yaml` - Tool configuration\n- `gdb_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: gdb_analyze\ncapabilities: ['binary', 'commands', 'script-file', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'gdb']\n---\n\n# Gdb Analyze\n\nExecute GDB for binary analysis and debugging with enhanced logging. binary: Path to the binary file commands: GDB commands to execute script_file: Path to GDB script file additional_args: Additional GDB arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **commands** (string, Optional): GDB commands to execute\n- **script_file** (string, Optional): Path to GDB script file\n- **additional_args** (string, Optional): Additional GDB arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/gdb`\n\n**Returns:** Binary analysis results\n\n## Files Included\n\n- `gdb_analyze.yaml` - Tool configuration\n- `gdb_analyze.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "gdb_analyze.yaml",
          "content": "name: gdb_analyze\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, gdb]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/gdb\ndescription: 'Execute GDB for binary analysis and debugging with enhanced logging.\n  binary: Path to the binary file commands: GDB commands to execute script_file: Path\n  to GDB script file additional_args: Additional GDB arguments'\nreturns: Binary analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: commands\n  type: string\n  required: false\n  description: GDB commands to execute\n  default: ''\n- name: script_file\n  type: string\n  required: false\n  description: Path to GDB script file\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional GDB arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "gdb_analyze.py",
          "content": "import os\nfrom typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass GdbHandler(AbstractHandler):\n    \"\"\"Handler for gdb functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute gdb with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            commands = data.get(\"commands\", \"\")\n            script_file = data.get(\"script_file\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ GDB called without binary parameter\")\n                return {\n    \n                    \"error\": \"Binary parameter is required\"\n                \n                }\n            command = f\"gdb {binary}\"\n            if script_file:\n                command += f\" -x {script_file}\"\n            if commands:\n                temp_script = \"/tmp/gdb_commands.txt\"\n                with open(temp_script, \"w\") as f:\n                    f.write(commands)\n                command += f\" -x {temp_script}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += \" -batch\"\n            logger.info(f\"ðŸ”§ Starting GDB analysis: {binary}\")\n            result = execute_command(command)\n            if commands and os.path.exists(\"/tmp/gdb_commands.txt\"):\n                try:\n                    os.remove(\"/tmp/gdb_commands.txt\")\n                except:\n                    pass\n            logger.info(f\"ðŸ“Š GDB analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in gdb endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640275
    },
    {
      "id": "binary_vulnerability_analysis-angr_symbolic_execution",
      "name": "Angr Symbolic Execution",
      "description": "Execute angr for symbolic execution and binary analysis. binary: Binary to analyze script_content: Custom angr script content find_address: Address to find during symbolic execution avoid_addresses: Comma-separated addresses to avoid analysis_type: Type of analysis (symbolic, cfg, static) additional_args: Additional arguments",
      "license": "MIT",
      "content": "---\nname: angr_symbolic_execution\ncapabilities: ['binary', 'script-content', 'find-address', 'avoid-addresses', 'analysis-type', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'angr']\n---\n\n# Angr Symbolic Execution\n\nExecute angr for symbolic execution and binary analysis. binary: Binary to analyze script_content: Custom angr script content find_address: Address to find during symbolic execution avoid_addresses: Comma-separated addresses to avoid analysis_type: Type of analysis (symbolic, cfg, static) additional_args: Additional arguments\n\n## Parameters\n- **binary** (string, Required): Binary to analyze\n- **script_content** (string, Optional): Custom angr script content\n- **find_address** (string, Optional): Address to find during symbolic execution\n- **avoid_addresses** (string, Optional): Comma-separated addresses to avoid\n- **analysis_type** (string, Optional) (default: symbolic): Type of analysis (symbolic, cfg, static)\n- **additional_args** (string, Optional): Additional arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/angr`\n\n**Returns:** Symbolic execution and binary analysis results\n\n## Files Included\n\n- `angr_symbolic_execution.yaml` - Tool configuration\n- `angr_symbolic_execution.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: angr_symbolic_execution\ncapabilities: ['binary', 'script-content', 'find-address', 'avoid-addresses', 'analysis-type', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'angr']\n---\n\n# Angr Symbolic Execution\n\nExecute angr for symbolic execution and binary analysis. binary: Binary to analyze script_content: Custom angr script content find_address: Address to find during symbolic execution avoid_addresses: Comma-separated addresses to avoid analysis_type: Type of analysis (symbolic, cfg, static) additional_args: Additional arguments\n\n## Parameters\n- **binary** (string, Required): Binary to analyze\n- **script_content** (string, Optional): Custom angr script content\n- **find_address** (string, Optional): Address to find during symbolic execution\n- **avoid_addresses** (string, Optional): Comma-separated addresses to avoid\n- **analysis_type** (string, Optional) (default: symbolic): Type of analysis (symbolic, cfg, static)\n- **additional_args** (string, Optional): Additional arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/angr`\n\n**Returns:** Symbolic execution and binary analysis results\n\n## Files Included\n\n- `angr_symbolic_execution.yaml` - Tool configuration\n- `angr_symbolic_execution.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "angr_symbolic_execution.yaml",
          "content": "name: angr_symbolic_execution\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, angr]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/angr\ndescription: 'Execute angr for symbolic execution and binary analysis. binary: Binary\n  to analyze script_content: Custom angr script content find_address: Address to find\n  during symbolic execution avoid_addresses: Comma-separated addresses to avoid analysis_type:\n  Type of analysis (symbolic, cfg, static) additional_args: Additional arguments'\nreturns: Symbolic execution and binary analysis results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Binary to analyze\n- name: script_content\n  type: string\n  required: false\n  description: Custom angr script content\n  default: ''\n- name: find_address\n  type: string\n  required: false\n  description: Address to find during symbolic execution\n  default: ''\n- name: avoid_addresses\n  type: string\n  required: false\n  description: Comma-separated addresses to avoid\n  default: ''\n- name: analysis_type\n  type: string\n  required: false\n  description: Type of analysis (symbolic, cfg, static)\n  default: symbolic\n- name: additional_args\n  type: string\n  required: false\n  description: Additional arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "angr_symbolic_execution.py",
          "content": "import os\nfrom typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass AngrHandler(AbstractHandler):\n    \"\"\"Handler for angr functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        try:\n            binary = data.get(\"binary\", \"\")\n            script_content = data.get(\"script_content\", \"\")\n            find_address = data.get(\"find_address\", \"\")\n            avoid_addresses = data.get(\"avoid_addresses\", \"\")\n            analysis_type = data.get(\"analysis_type\", \"symbolic\")  # symbolic, cfg, static\n            additional_args = data.get(\"additional_args\", \"\")\n    \n            if not binary:\n                logger.warning(\"ðŸ”§ angr called without binary parameter\")\n                return {\"error\": \"Binary parameter is required\"}\n    \n            # Create angr script\n            script_file = \"/tmp/angr_analysis.py\"\n    \n            if script_content:\n                with open(script_file, \"w\") as f:\n                    f.write(script_content)\n            else:\n                # Generate basic angr template\n                template = f\"\"\"#!/usr/bin/env python3\n    import angr\n    import sys\n    \n    # Load binary\n    project = angr.Project('{binary}', auto_load_libs=False)\n    print(f\"Loaded binary: {binary}\")\n    print(f\"Architecture: {{project.arch}}\")\n    print(f\"Entry point: {{hex(project.entry)}}\")\n    \n    \"\"\"\n                if analysis_type == \"symbolic\":\n                    template += f\"\"\"\n    # Symbolic execution\n    state = project.factory.entry_state()\n    simgr = project.factory.simulation_manager(state)\n    \n    # Find and avoid addresses\n    find_addr = {find_address if find_address else 'None'}\n    avoid_addrs = {avoid_addresses.split(',') if avoid_addresses else '[]'}\n    \n    if find_addr:\n        simgr.explore(find=find_addr, avoid=avoid_addrs)\n        if simgr.found:\n            print(\"Found solution!\")\n            solution_state = simgr.found[0]\n            print(f\"Input: {{solution_state.posix.dumps(0)}}\")\n        else:\n            print(\"No solution found\")\n    else:\n        print(\"No find address specified, running basic analysis\")\n    \"\"\"\n                elif analysis_type == \"cfg\":\n                    template += \"\"\"\n    # Control Flow Graph analysis\n    cfg = project.analyses.CFGFast()\n    print(f\"CFG nodes: {len(cfg.graph.nodes())}\")\n    print(f\"CFG edges: {len(cfg.graph.edges())}\")\n    \n    # Function analysis\n    for func_addr, func in cfg.functions.items():\n        print(f\"Function: {func.name} at {hex(func_addr)}\")\n    \"\"\"\n    \n                with open(script_file, \"w\") as f:\n                    f.write(template)\n    \n            command = f\"python3 {script_file}\"\n    \n            if additional_args:\n                command += f\" {additional_args}\"\n    \n            logger.info(f\"ðŸ”§ Starting angr analysis: {binary}\")\n            result = execute_command(command, timeout=600)  # Longer timeout for symbolic execution\n    \n            # Cleanup\n            try:\n                os.remove(script_file)\n            except:\n                pass\n    \n            logger.info(f\"ðŸ“Š angr analysis completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in angr endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640277
    },
    {
      "id": "binary_vulnerability_analysis-strings_extract",
      "name": "Strings Extract",
      "description": "Extract strings from a binary file with enhanced logging. file_path: Path to the file min_len: Minimum string length additional_args: Additional strings arguments",
      "license": "MIT",
      "content": "---\nname: strings_extract\ncapabilities: ['file-path', 'min-len', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing']\n---\n\n# Strings Extract\n\nExtract strings from a binary file with enhanced logging. file_path: Path to the file min_len: Minimum string length additional_args: Additional strings arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file\n- **min_len** (integer, Optional) (default: 4): Minimum string length\n- **additional_args** (string, Optional): Additional strings arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/strings`\n\n**Returns:** String extraction results\n\n## Files Included\n\n- `strings_extract.yaml` - Tool configuration\n- `strings_extract.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: strings_extract\ncapabilities: ['file-path', 'min-len', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing']\n---\n\n# Strings Extract\n\nExtract strings from a binary file with enhanced logging. file_path: Path to the file min_len: Minimum string length additional_args: Additional strings arguments\n\n## Parameters\n- **file_path** (string, Required): Path to the file\n- **min_len** (integer, Optional) (default: 4): Minimum string length\n- **additional_args** (string, Optional): Additional strings arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/strings`\n\n**Returns:** String extraction results\n\n## Files Included\n\n- `strings_extract.yaml` - Tool configuration\n- `strings_extract.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "strings_extract.yaml",
          "content": "name: strings_extract\ntags: [binary_analysis, vulnerability_assessment, penetration_testing]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/strings\ndescription: 'Extract strings from a binary file with enhanced logging. file_path:\n  Path to the file min_len: Minimum string length additional_args: Additional strings\n  arguments'\nreturns: String extraction results\nparameters:\n- name: file_path\n  type: string\n  required: true\n  description: Path to the file\n- name: min_len\n  type: integer\n  required: false\n  description: Minimum string length\n  default: 4\n- name: additional_args\n  type: string\n  required: false\n  description: Additional strings arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "strings_extract.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass StringsHandler(AbstractHandler):\n    \"\"\"Handler for strings functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute strings with enhanced logging\"\"\"\n        try:\n            file_path = data.get(\"file_path\", \"\")\n            min_len = data.get(\"min_len\", 4)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not file_path:\n                logger.warning(\"ðŸ”§ Strings called without file_path parameter\")\n                return {\n    \n                    \"error\": \"File path parameter is required\"\n                \n                }\n            command = f\"strings -n {min_len}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += f\" {file_path}\"\n            logger.info(f\"ðŸ”§ Starting Strings extraction: {file_path}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Strings extraction completed for {file_path}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in strings endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640278
    },
    {
      "id": "binary_exploitation-pwninit_setup",
      "name": "Pwninit Setup",
      "description": "Execute pwninit for CTF binary exploitation setup. binary: Binary file to set up libc: Libc file to use ld: Loader file to use template_type: Template type (python, c) additional_args: Additional pwninit arguments",
      "license": "MIT",
      "content": "---\nname: pwninit_setup\ncapabilities: ['binary', 'libc', 'ld', 'template-type', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'pwninit']\n---\n\n# Pwninit Setup\n\nExecute pwninit for CTF binary exploitation setup. binary: Binary file to set up libc: Libc file to use ld: Loader file to use template_type: Template type (python, c) additional_args: Additional pwninit arguments\n\n## Parameters\n- **binary** (string, Required): Binary file to set up\n- **libc** (string, Optional): Libc file to use\n- **ld** (string, Optional): Loader file to use\n- **template_type** (string, Optional) (default: python): Template type (python, c)\n- **additional_args** (string, Optional): Additional pwninit arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/pwninit`\n\n**Returns:** CTF binary exploitation setup results\n\n## Files Included\n\n- `pwninit_setup.yaml` - Tool configuration\n- `pwninit_setup.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: pwninit_setup\ncapabilities: ['binary', 'libc', 'ld', 'template-type', 'additional-args']\ncategory: binary_exploitation\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'pwninit']\n---\n\n# Pwninit Setup\n\nExecute pwninit for CTF binary exploitation setup. binary: Binary file to set up libc: Libc file to use ld: Loader file to use template_type: Template type (python, c) additional_args: Additional pwninit arguments\n\n## Parameters\n- **binary** (string, Required): Binary file to set up\n- **libc** (string, Optional): Libc file to use\n- **ld** (string, Optional): Loader file to use\n- **template_type** (string, Optional) (default: python): Template type (python, c)\n- **additional_args** (string, Optional): Additional pwninit arguments\n\n\n## Usage\n\nThis tool is part of the binary_exploitation category.\n\n**Endpoint:** `api/tools/pwninit`\n\n**Returns:** CTF binary exploitation setup results\n\n## Files Included\n\n- `pwninit_setup.yaml` - Tool configuration\n- `pwninit_setup.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "pwninit_setup.yaml",
          "content": "name: pwninit_setup\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, pwninit]\ncategory: binary_exploitation\nendpoint: api/tools/pwninit\ndescription: 'Execute pwninit for CTF binary exploitation setup. binary: Binary file\n  to set up libc: Libc file to use ld: Loader file to use template_type: Template\n  type (python, c) additional_args: Additional pwninit arguments'\nreturns: CTF binary exploitation setup results\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Binary file to set up\n- name: libc\n  type: string\n  required: false\n  description: Libc file to use\n  default: ''\n- name: ld\n  type: string\n  required: false\n  description: Loader file to use\n  default: ''\n- name: template_type\n  type: string\n  required: false\n  description: Template type (python, c)\n  default: python\n- name: additional_args\n  type: string\n  required: false\n  description: Additional pwninit arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "pwninit_setup.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass PwninitHandler(AbstractHandler):\n    \"\"\"Handler for pwninit functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute pwninit with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            libc = data.get(\"libc\", \"\")\n            ld = data.get(\"ld\", \"\")\n            template_type = data.get(\"template_type\", \"python\")  # python, c\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ pwninit called without binary parameter\")\n                return {\"error\": \"Binary parameter is required\"}\n            command = f\"pwninit --bin {binary}\"\n            if libc:\n                command += f\" --libc {libc}\"\n            if ld:\n                command += f\" --ld {ld}\"\n            if template_type:\n                command += f\" --template {template_type}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting pwninit setup: {binary}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š pwninit setup completed\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in pwninit endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640279
    },
    {
      "id": "binary_vulnerability_analysis-ghidra_analysis",
      "name": "Ghidra Analysis",
      "description": "Execute Ghidra for advanced binary analysis and reverse engineering. binary: Path to the binary file project_name: Ghidra project name script_file: Custom Ghidra script to run analysis_timeout: Analysis timeout in seconds output_format: Output format (xml, json) additional_args: Additional Ghidra arguments",
      "license": "MIT",
      "content": "---\nname: ghidra_analysis\ncapabilities: ['binary', 'project-name', 'script-file', 'analysis-timeout', 'output-format', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ghidra']\n---\n\n# Ghidra Analysis\n\nExecute Ghidra for advanced binary analysis and reverse engineering. binary: Path to the binary file project_name: Ghidra project name script_file: Custom Ghidra script to run analysis_timeout: Analysis timeout in seconds output_format: Output format (xml, json) additional_args: Additional Ghidra arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **project_name** (string, Optional) (default: hexstrike_analysis): Ghidra project name\n- **script_file** (string, Optional): Custom Ghidra script to run\n- **analysis_timeout** (integer, Optional) (default: 300): Analysis timeout in seconds\n- **output_format** (string, Optional) (default: xml): Output format (xml, json)\n- **additional_args** (string, Optional): Additional Ghidra arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/ghidra`\n\n**Returns:** Advanced binary analysis results from Ghidra\n\n## Files Included\n\n- `ghidra_analysis.yaml` - Tool configuration\n- `ghidra_analysis.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: ghidra_analysis\ncapabilities: ['binary', 'project-name', 'script-file', 'analysis-timeout', 'output-format', 'additional-args']\ncategory: binary_vulnerability_analysis\ntags: ['binary_analysis', 'vulnerability_assessment', 'penetration_testing', 'ghidra']\n---\n\n# Ghidra Analysis\n\nExecute Ghidra for advanced binary analysis and reverse engineering. binary: Path to the binary file project_name: Ghidra project name script_file: Custom Ghidra script to run analysis_timeout: Analysis timeout in seconds output_format: Output format (xml, json) additional_args: Additional Ghidra arguments\n\n## Parameters\n- **binary** (string, Required): Path to the binary file\n- **project_name** (string, Optional) (default: hexstrike_analysis): Ghidra project name\n- **script_file** (string, Optional): Custom Ghidra script to run\n- **analysis_timeout** (integer, Optional) (default: 300): Analysis timeout in seconds\n- **output_format** (string, Optional) (default: xml): Output format (xml, json)\n- **additional_args** (string, Optional): Additional Ghidra arguments\n\n\n## Usage\n\nThis tool is part of the binary_vulnerability_analysis category.\n\n**Endpoint:** `api/tools/ghidra`\n\n**Returns:** Advanced binary analysis results from Ghidra\n\n## Files Included\n\n- `ghidra_analysis.yaml` - Tool configuration\n- `ghidra_analysis.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "ghidra_analysis.yaml",
          "content": "name: ghidra_analysis\ntags: [binary_analysis, vulnerability_assessment, penetration_testing, ghidra]\ncategory: binary_vulnerability_analysis\nendpoint: api/tools/ghidra\ndescription: 'Execute Ghidra for advanced binary analysis and reverse engineering.\n  binary: Path to the binary file project_name: Ghidra project name script_file: Custom\n  Ghidra script to run analysis_timeout: Analysis timeout in seconds output_format:\n  Output format (xml, json) additional_args: Additional Ghidra arguments'\nreturns: Advanced binary analysis results from Ghidra\nparameters:\n- name: binary\n  type: string\n  required: true\n  description: Path to the binary file\n- name: project_name\n  type: string\n  required: false\n  description: Ghidra project name\n  default: hexstrike_analysis\n- name: script_file\n  type: string\n  required: false\n  description: Custom Ghidra script to run\n  default: ''\n- name: analysis_timeout\n  type: integer\n  required: false\n  description: Analysis timeout in seconds\n  default: 300\n- name: output_format\n  type: string\n  required: false\n  description: Output format (xml, json)\n  default: xml\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Ghidra arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "ghidra_analysis.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass GhidraHandler(AbstractHandler):\n    \"\"\"Handler for ghidra functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute ghidra with enhanced logging\"\"\"\n        try:\n            binary = data.get(\"binary\", \"\")\n            project_name = data.get(\"project_name\", \"hexstrike_analysis\")\n            script_file = data.get(\"script_file\", \"\")\n            analysis_timeout = data.get(\"analysis_timeout\", 300)\n            output_format = data.get(\"output_format\", \"xml\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not binary:\n                logger.warning(\"ðŸ”§ Ghidra called without binary parameter\")\n                return {\"error\": \"Binary parameter is required\"}\n            project_dir = f\"/tmp/ghidra_projects/{project_name}\"\n            os.makedirs(project_dir, exist_ok=True)\n            command = f\"analyzeHeadless {project_dir} {project_name} -import {binary} -deleteProject\"\n            if script_file:\n                command += f\" -postScript {script_file}\"\n            if output_format == \"xml\":\n                command += f\" -postScript ExportXml.java {project_dir}/analysis.xml\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ”§ Starting Ghidra analysis: {binary}\")\n            result = execute_command(command, timeout=analysis_timeout)\n            logger.info(f\"ðŸ“Š Ghidra analysis completed for {binary}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in ghidra endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640281
    },
    {
      "id": "network_scanning-smbmap_scan",
      "name": "Smbmap Scan",
      "description": "Execute SMBMap for SMB share enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication additional_args: Additional SMBMap arguments",
      "license": "MIT",
      "content": "---\nname: smbmap_scan\ncapabilities: ['target', 'username', 'password', 'domain', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'smbmap']\n---\n\n# Smbmap Scan\n\nExecute SMBMap for SMB share enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication additional_args: Additional SMBMap arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **additional_args** (string, Optional): Additional SMBMap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/smbmap`\n\n**Returns:** SMB share enumeration results\n\n## Files Included\n\n- `smbmap_scan.yaml` - Tool configuration\n- `smbmap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: smbmap_scan\ncapabilities: ['target', 'username', 'password', 'domain', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'smbmap']\n---\n\n# Smbmap Scan\n\nExecute SMBMap for SMB share enumeration with enhanced logging. target: The target IP address username: Username for authentication password: Password for authentication domain: Domain for authentication additional_args: Additional SMBMap arguments\n\n## Parameters\n- **target** (string, Required): The target IP address\n- **username** (string, Optional): Username for authentication\n- **password** (string, Optional): Password for authentication\n- **domain** (string, Optional): Domain for authentication\n- **additional_args** (string, Optional): Additional SMBMap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/smbmap`\n\n**Returns:** SMB share enumeration results\n\n## Files Included\n\n- `smbmap_scan.yaml` - Tool configuration\n- `smbmap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "smbmap_scan.yaml",
          "content": "name: smbmap_scan\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, smbmap]\nendpoint: api/tools/smbmap\ndescription: 'Execute SMBMap for SMB share enumeration with enhanced logging. target:\n  The target IP address username: Username for authentication password: Password for\n  authentication domain: Domain for authentication additional_args: Additional SMBMap\n  arguments'\nreturns: SMB share enumeration results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address\n- name: username\n  type: string\n  required: false\n  description: Username for authentication\n  default: ''\n- name: password\n  type: string\n  required: false\n  description: Password for authentication\n  default: ''\n- name: domain\n  type: string\n  required: false\n  description: Domain for authentication\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional SMBMap arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "smbmap_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass SmbmapHandler(AbstractHandler):\n    \"\"\"Handler for smbmap functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute smbmap with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            username = data.get(\"username\", \"\")\n            password = data.get(\"password\", \"\")\n            domain = data.get(\"domain\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ SMBMap called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"smbmap -H {target}\"\n            if username:\n                command += f\" -u {username}\"\n            if password:\n                command += f\" -p {password}\"\n            if domain:\n                command += f\" -d {domain}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting SMBMap: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š SMBMap completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in smbmap endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640282
    },
    {
      "id": "network_scanning-masscan_high_speed",
      "name": "Masscan High Speed",
      "description": "Execute Masscan for high-speed Internet-scale port scanning with intelligent rate limiting. target: The target IP address or CIDR range ports: Port range to scan rate: Packets per second rate interface: Network interface to use router_mac: Router MAC address source_ip: Source IP address banners: Enable banner grabbing additional_args: Additional Masscan arguments",
      "license": "MIT",
      "content": "---\nname: masscan_high_speed\ncapabilities: ['target', 'ports', 'rate', 'interface', 'router-mac', 'source-ip', 'banners', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'masscan']\n---\n\n# Masscan High Speed\n\nExecute Masscan for high-speed Internet-scale port scanning with intelligent rate limiting. target: The target IP address or CIDR range ports: Port range to scan rate: Packets per second rate interface: Network interface to use router_mac: Router MAC address source_ip: Source IP address banners: Enable banner grabbing additional_args: Additional Masscan arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or CIDR range\n- **ports** (string, Optional) (default: 1-65535): Port range to scan\n- **rate** (integer, Optional) (default: 1000): Packets per second rate\n- **interface** (string, Optional): Network interface to use\n- **router_mac** (string, Optional): Router MAC address\n- **source_ip** (string, Optional): Source IP address\n- **banners** (boolean, Optional): Enable banner grabbing\n- **additional_args** (string, Optional): Additional Masscan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/masscan`\n\n**Returns:** High-speed port scanning results with intelligent rate limiting\n\n## Files Included\n\n- `masscan_high_speed.yaml` - Tool configuration\n- `masscan_high_speed.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: masscan_high_speed\ncapabilities: ['target', 'ports', 'rate', 'interface', 'router-mac', 'source-ip', 'banners', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'masscan']\n---\n\n# Masscan High Speed\n\nExecute Masscan for high-speed Internet-scale port scanning with intelligent rate limiting. target: The target IP address or CIDR range ports: Port range to scan rate: Packets per second rate interface: Network interface to use router_mac: Router MAC address source_ip: Source IP address banners: Enable banner grabbing additional_args: Additional Masscan arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or CIDR range\n- **ports** (string, Optional) (default: 1-65535): Port range to scan\n- **rate** (integer, Optional) (default: 1000): Packets per second rate\n- **interface** (string, Optional): Network interface to use\n- **router_mac** (string, Optional): Router MAC address\n- **source_ip** (string, Optional): Source IP address\n- **banners** (boolean, Optional): Enable banner grabbing\n- **additional_args** (string, Optional): Additional Masscan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/masscan`\n\n**Returns:** High-speed port scanning results with intelligent rate limiting\n\n## Files Included\n\n- `masscan_high_speed.yaml` - Tool configuration\n- `masscan_high_speed.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "masscan.yaml",
          "content": "name: masscan_high_speed\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, masscan]\nendpoint: api/tools/masscan\ndescription: 'Execute Masscan for high-speed Internet-scale port scanning with intelligent rate limiting. target: The\n  target IP address or CIDR range ports: Port range to scan rate: Packets per second rate interface: Network interface\n  to use router_mac: Router MAC address source_ip: Source IP address banners: Enable banner grabbing additional_args:\n  Additional Masscan arguments'\nreturns: High-speed port scanning results with intelligent rate limiting\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address or CIDR range\n- name: ports\n  type: string\n  required: false\n  description: Port range to scan\n  default: 1-65535\n- name: rate\n  type: integer\n  required: false\n  description: Packets per second rate\n  default: 1000\n- name: interface\n  type: string\n  required: false\n  description: Network interface to use\n  default: ''\n- name: router_mac\n  type: string\n  required: false\n  description: Router MAC address\n  default: ''\n- name: source_ip\n  type: string\n  required: false\n  description: Source IP address\n  default: ''\n- name: banners\n  type: boolean\n  required: false\n  description: Enable banner grabbing\n  default: false\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Masscan arguments\n  default: ''",
          "language": "yaml"
        },
        {
          "name": "masscan.py",
          "content": "import logging\nfrom typing import Dict, Any\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass NmapHandler(AbstractHandler):\n    \"\"\"\n    ä»»æ„shellå‘½ä»¤\n    \"\"\"\n\n    def __init__(self, config: Dict):\n        super().__init__(config)\n\n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n\n    def handle(self, data: Dict) -> Any:\n        try:\n            target = data.get(\"target\", \"\")\n            ports = data.get(\"ports\", \"1-65535\")\n            rate = data.get(\"rate\", 1000)\n            interface = data.get(\"interface\", \"\")\n            router_mac = data.get(\"router_mac\", \"\")\n            source_ip = data.get(\"source_ip\", \"\")\n            banners = data.get(\"banners\", False)\n            additional_args = data.get(\"additional_args\", \"\")\n    \n            if not target:\n                logger.warning(\"ðŸŽ¯ Masscan called without target parameter\")\n                return {\"error\": \"Target parameter is required\"}\n    \n            command = f\"masscan {target} -p{ports} --rate={rate}\"\n    \n            if interface:\n                command += f\" -e {interface}\"\n    \n            if router_mac:\n                command += f\" --router-mac {router_mac}\"\n    \n            if source_ip:\n                command += f\" --source-ip {source_ip}\"\n    \n            if banners:\n                command += \" --banners\"\n    \n            if additional_args:\n                command += f\" {additional_args}\"\n    \n            logger.info(f\"ðŸš€ Starting Masscan: {target} at rate {rate}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Masscan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in masscan endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640284
    },
    {
      "id": "network_scanning-nmap_scan",
      "name": "Nmap Scan",
      "description": "Execute an enhanced Nmap scan against a target with real-time logging. target: The IP address or hostname to scan scan_type: Scan type (e.g., -sV for version detection, -sC for scripts) ports: Comma-separated list of ports or port ranges additional_args: Additional Nmap arguments",
      "license": "MIT",
      "content": "---\nname: nmap_scan\ncapabilities: ['target', 'scan-type', 'ports', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nmap']\n---\n\n# Nmap Scan\n\nExecute an enhanced Nmap scan against a target with real-time logging. target: The IP address or hostname to scan scan_type: Scan type (e.g., -sV for version detection, -sC for scripts) ports: Comma-separated list of ports or port ranges additional_args: Additional Nmap arguments\n\n## Parameters\n- **target** (string, Required): The IP address or hostname to scan\n- **scan_type** (string, Optional) (default: -sV): Scan type (e.g., -sV for version detection, -sC for scripts)\n- **ports** (string, Optional): Comma-separated list of ports or port ranges\n- **additional_args** (string, Optional): Additional Nmap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nmap`\n\n**Returns:** Scan results with enhanced telemetry\n\n## Files Included\n\n- `nmap_scan.yaml` - Tool configuration\n- `nmap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: nmap_scan\ncapabilities: ['target', 'scan-type', 'ports', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'nmap']\n---\n\n# Nmap Scan\n\nExecute an enhanced Nmap scan against a target with real-time logging. target: The IP address or hostname to scan scan_type: Scan type (e.g., -sV for version detection, -sC for scripts) ports: Comma-separated list of ports or port ranges additional_args: Additional Nmap arguments\n\n## Parameters\n- **target** (string, Required): The IP address or hostname to scan\n- **scan_type** (string, Optional) (default: -sV): Scan type (e.g., -sV for version detection, -sC for scripts)\n- **ports** (string, Optional): Comma-separated list of ports or port ranges\n- **additional_args** (string, Optional): Additional Nmap arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nmap`\n\n**Returns:** Scan results with enhanced telemetry\n\n## Files Included\n\n- `nmap_scan.yaml` - Tool configuration\n- `nmap_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "nmap_scan.yaml",
          "content": "name: nmap_scan\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, nmap]\nendpoint: api/tools/nmap\ndescription: 'Execute an enhanced Nmap scan against a target with real-time logging. target: The IP address or hostname\n  to scan scan_type: Scan type (e.g., -sV for version detection, -sC for scripts) ports: Comma-separated list of ports\n  or port ranges additional_args: Additional Nmap arguments'\nreturns: Scan results with enhanced telemetry\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The IP address or hostname to scan\n- name: scan_type\n  type: string\n  required: false\n  description: Scan type (e.g., -sV for version detection, -sC for scripts)\n  default: -sV\n- name: ports\n  type: string\n  required: false\n  description: Comma-separated list of ports or port ranges\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Nmap arguments\n  default: ''",
          "language": "yaml"
        },
        {
          "name": "nmap_scan.py",
          "content": "import logging\nfrom typing import Dict, Any\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass NmapHandler(AbstractHandler):\n    \"\"\"\n    ä»»æ„shellå‘½ä»¤\n    \"\"\"\n\n    def __init__(self, config: Dict):\n        super().__init__(config)\n\n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n\n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute nmap scan with enhanced logging, caching, and intelligent error handling\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            scan_type = data.get(\"scan_type\", \"-sCV\")\n            ports = data.get(\"ports\", \"\")\n            additional_args = data.get(\"additional_args\", \"-T4 -Pn\")\n\n            if not target:\n                logger.warning(\"ðŸŽ¯ Nmap called without target parameter\")\n                return {\n                    \"error\": \"Target parameter is required\"\n                }\n\n            command = f\"nmap {scan_type}\"\n\n            if ports:\n                command += f\" -p {ports}\"\n\n            if additional_args:\n                command += f\" {additional_args}\"\n\n            command += f\" {target}\"\n\n            logger.info(f\"ðŸ” Starting Nmap scan: {target}\")\n            result = execute_command(command)\n\n            logger.info(f\"ðŸ“Š Nmap scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in nmap endpoint: {str(e)}\")\n            return {\n                \"error\": f\"Server error: {str(e)}\"\n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640285
    },
    {
      "id": "web_application_scanning-dotdotpwn_scan",
      "name": "Dotdotpwn Scan",
      "description": "Execute DotDotPwn for directory traversal testing with enhanced logging. target: The target hostname or IP module: Module to use (http, ftp, tftp, etc.) additional_args: Additional DotDotPwn arguments",
      "license": "MIT",
      "content": "---\nname: dotdotpwn_scan\ncapabilities: ['target', 'module', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dotdotpwn']\n---\n\n# Dotdotpwn Scan\n\nExecute DotDotPwn for directory traversal testing with enhanced logging. target: The target hostname or IP module: Module to use (http, ftp, tftp, etc.) additional_args: Additional DotDotPwn arguments\n\n## Parameters\n- **target** (string, Required): The target hostname or IP\n- **module** (string, Optional) (default: http): Module to use (http, ftp, tftp, etc.)\n- **additional_args** (string, Optional): Additional DotDotPwn arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/dotdotpwn`\n\n**Returns:** Directory traversal test results\n\n## Files Included\n\n- `dotdotpwn_scan.yaml` - Tool configuration\n- `dotdotpwn_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: dotdotpwn_scan\ncapabilities: ['target', 'module', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dotdotpwn']\n---\n\n# Dotdotpwn Scan\n\nExecute DotDotPwn for directory traversal testing with enhanced logging. target: The target hostname or IP module: Module to use (http, ftp, tftp, etc.) additional_args: Additional DotDotPwn arguments\n\n## Parameters\n- **target** (string, Required): The target hostname or IP\n- **module** (string, Optional) (default: http): Module to use (http, ftp, tftp, etc.)\n- **additional_args** (string, Optional): Additional DotDotPwn arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/dotdotpwn`\n\n**Returns:** Directory traversal test results\n\n## Files Included\n\n- `dotdotpwn_scan.yaml` - Tool configuration\n- `dotdotpwn_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "dotdotpwn_scan.yaml",
          "content": "name: dotdotpwn_scan\ncategory: web_application_scanning\ntags: [network_scanning, vulnerability_assessment, penetration_testing, dotdotpwn]\nendpoint: api/tools/dotdotpwn\ndescription: 'Execute DotDotPwn for directory traversal testing with enhanced logging.\n  target: The target hostname or IP module: Module to use (http, ftp, tftp, etc.)\n  additional_args: Additional DotDotPwn arguments'\nreturns: Directory traversal test results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target hostname or IP\n- name: module\n  type: string\n  required: false\n  description: Module to use (http, ftp, tftp, etc.)\n  default: http\n- name: additional_args\n  type: string\n  required: false\n  description: Additional DotDotPwn arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "dotdotpwn_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass DotdotpwnHandler(AbstractHandler):\n    \"\"\"Handler for dotdotpwn functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute dotdotpwn with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            module = data.get(\"module\", \"http\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ DotDotPwn called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"dotdotpwn -m {module} -h {target}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            command += \" -b\"\n            logger.info(f\"ðŸ” Starting DotDotPwn scan: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š DotDotPwn scan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in dotdotpwn endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640286
    },
    {
      "id": "web_application_scanning-wafw00f_scan",
      "name": "Wafw00F Scan",
      "description": "Execute wafw00f to identify and fingerprint WAF products with enhanced logging. target: Target URL or IP additional_args: Additional wafw00f arguments",
      "license": "MIT",
      "content": "---\nname: wafw00f_scan\ncapabilities: ['target', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'wafw00f', 'waf']\n---\n\n# Wafw00F Scan\n\nExecute wafw00f to identify and fingerprint WAF products with enhanced logging. target: Target URL or IP additional_args: Additional wafw00f arguments\n\n## Parameters\n- **target** (string, Required): Target URL or IP\n- **additional_args** (string, Optional): Additional wafw00f arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/wafw00f`\n\n**Returns:** WAF detection results\n\n## Files Included\n\n- `wafw00f_scan.yaml` - Tool configuration\n- `wafw00f_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: wafw00f_scan\ncapabilities: ['target', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'wafw00f', 'waf']\n---\n\n# Wafw00F Scan\n\nExecute wafw00f to identify and fingerprint WAF products with enhanced logging. target: Target URL or IP additional_args: Additional wafw00f arguments\n\n## Parameters\n- **target** (string, Required): Target URL or IP\n- **additional_args** (string, Optional): Additional wafw00f arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/wafw00f`\n\n**Returns:** WAF detection results\n\n## Files Included\n\n- `wafw00f_scan.yaml` - Tool configuration\n- `wafw00f_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "wafw00f_scan.yaml",
          "content": "name: wafw00f_scan\ncategory: web_application_scanning\ntags: [network_scanning, vulnerability_assessment, penetration_testing, wafw00f, waf]\nendpoint: api/tools/wafw00f\ndescription: 'Execute wafw00f to identify and fingerprint WAF products with enhanced\n  logging. target: Target URL or IP additional_args: Additional wafw00f arguments'\nreturns: WAF detection results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: Target URL or IP\n- name: additional_args\n  type: string\n  required: false\n  description: Additional wafw00f arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "wafw00f_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass Wafw00fHandler(AbstractHandler):\n    \"\"\"Handler for wafw00f functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute wafw00f with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸ›¡ï¸ Wafw00f called without target parameter\")\n                return {\n    \n                    \"error\": \"Target parameter is required\"\n                \n                }\n            command = f\"wafw00f {target}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ›¡ï¸ Starting Wafw00f WAF detection: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Wafw00f completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in wafw00f endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640287
    },
    {
      "id": "subdomain_enumeration-dnsenum_scan",
      "name": "Dnsenum Scan",
      "description": "Execute dnsenum for DNS enumeration with enhanced logging. domain: Target domain dns_server: DNS server to use wordlist: Wordlist for brute forcing additional_args: Additional dnsenum arguments",
      "license": "MIT",
      "content": "---\nname: dnsenum_scan\ncapabilities: ['domain', 'dns-server', 'wordlist', 'additional-args']\ncategory: subdomain_enumeration\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dnsenum']\n---\n\n# Dnsenum Scan\n\nExecute dnsenum for DNS enumeration with enhanced logging. domain: Target domain dns_server: DNS server to use wordlist: Wordlist for brute forcing additional_args: Additional dnsenum arguments\n\n## Parameters\n- **domain** (string, Required): Target domain\n- **dns_server** (string, Optional): DNS server to use\n- **wordlist** (string, Optional): Wordlist for brute forcing\n- **additional_args** (string, Optional): Additional dnsenum arguments\n\n\n## Usage\n\nThis tool is part of the subdomain_enumeration category.\n\n**Endpoint:** `api/tools/dnsenum`\n\n**Returns:** DNS enumeration results\n\n## Files Included\n\n- `dnsenum_scan.yaml` - Tool configuration\n- `dnsenum_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: dnsenum_scan\ncapabilities: ['domain', 'dns-server', 'wordlist', 'additional-args']\ncategory: subdomain_enumeration\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'dnsenum']\n---\n\n# Dnsenum Scan\n\nExecute dnsenum for DNS enumeration with enhanced logging. domain: Target domain dns_server: DNS server to use wordlist: Wordlist for brute forcing additional_args: Additional dnsenum arguments\n\n## Parameters\n- **domain** (string, Required): Target domain\n- **dns_server** (string, Optional): DNS server to use\n- **wordlist** (string, Optional): Wordlist for brute forcing\n- **additional_args** (string, Optional): Additional dnsenum arguments\n\n\n## Usage\n\nThis tool is part of the subdomain_enumeration category.\n\n**Endpoint:** `api/tools/dnsenum`\n\n**Returns:** DNS enumeration results\n\n## Files Included\n\n- `dnsenum_scan.yaml` - Tool configuration\n- `dnsenum_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "dnsenum_scan.yaml",
          "content": "name: dnsenum_scan\ncategory: subdomain_enumeration\ntags: [network_scanning, vulnerability_assessment, penetration_testing, dnsenum]\nendpoint: api/tools/dnsenum\ndescription: 'Execute dnsenum for DNS enumeration with enhanced logging. domain: Target\n  domain dns_server: DNS server to use wordlist: Wordlist for brute forcing additional_args:\n  Additional dnsenum arguments'\nreturns: DNS enumeration results\nparameters:\n- name: domain\n  type: string\n  required: true\n  description: Target domain\n- name: dns_server\n  type: string\n  required: false\n  description: DNS server to use\n  default: ''\n- name: wordlist\n  type: string\n  required: false\n  description: Wordlist for brute forcing\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional dnsenum arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "dnsenum_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass DnsenumHandler(AbstractHandler):\n    \"\"\"Handler for dnsenum functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute dnsenum with enhanced logging\"\"\"\n        try:\n            domain = data.get(\"domain\", \"\")\n            dns_server = data.get(\"dns_server\", \"\")\n            wordlist = data.get(\"wordlist\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not domain:\n                logger.warning(\"ðŸŒ DNSenum called without domain parameter\")\n                return {\n    \n                    \"error\": \"Domain parameter is required\"\n                \n                }\n            command = f\"dnsenum {domain}\"\n            if dns_server:\n                command += f\" --dnsserver {dns_server}\"\n            if wordlist:\n                command += f\" --file {wordlist}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting DNSenum: {domain}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š DNSenum completed for {domain}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in dnsenum endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640289
    },
    {
      "id": "network_scanning-rustscan_fast_scan",
      "name": "Rustscan Fast Scan",
      "description": "Execute Rustscan for ultra-fast port scanning with enhanced logging. target: The target IP address or hostname ports: Specific ports to scan (e.g., \"22,80,443\") ulimit: File descriptor limit batch_size: Batch size for scanning timeout: Timeout in milliseconds scripts: Run Nmap scripts on discovered ports additional_args: Additional Rustscan arguments",
      "license": "MIT",
      "content": "---\nname: rustscan_fast_scan\ncapabilities: ['target', 'ports', 'ulimit', 'batch-size', 'timeout', 'scripts', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'rustscan']\n---\n\n# Rustscan Fast Scan\n\nExecute Rustscan for ultra-fast port scanning with enhanced logging. target: The target IP address or hostname ports: Specific ports to scan (e.g., \"22,80,443\") ulimit: File descriptor limit batch_size: Batch size for scanning timeout: Timeout in milliseconds scripts: Run Nmap scripts on discovered ports additional_args: Additional Rustscan arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or hostname\n- **ports** (string, Optional): Specific ports to scan (e.g., \"22,80,443\")\n- **ulimit** (integer, Optional) (default: 5000): File descriptor limit\n- **batch_size** (integer, Optional) (default: 4500): Batch size for scanning\n- **timeout** (integer, Optional) (default: 1500): Timeout in milliseconds\n- **scripts** (boolean, Optional): Run Nmap scripts on discovered ports\n- **additional_args** (string, Optional): Additional Rustscan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/rustscan`\n\n**Returns:** Ultra-fast port scanning results\n\n## Files Included\n\n- `rustscan_fast_scan.yaml` - Tool configuration\n- `rustscan_fast_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: rustscan_fast_scan\ncapabilities: ['target', 'ports', 'ulimit', 'batch-size', 'timeout', 'scripts', 'additional-args']\ncategory: network_scanning\ntags: ['vulnerability_assessment', 'penetration_testing', 'rustscan']\n---\n\n# Rustscan Fast Scan\n\nExecute Rustscan for ultra-fast port scanning with enhanced logging. target: The target IP address or hostname ports: Specific ports to scan (e.g., \"22,80,443\") ulimit: File descriptor limit batch_size: Batch size for scanning timeout: Timeout in milliseconds scripts: Run Nmap scripts on discovered ports additional_args: Additional Rustscan arguments\n\n## Parameters\n- **target** (string, Required): The target IP address or hostname\n- **ports** (string, Optional): Specific ports to scan (e.g., \"22,80,443\")\n- **ulimit** (integer, Optional) (default: 5000): File descriptor limit\n- **batch_size** (integer, Optional) (default: 4500): Batch size for scanning\n- **timeout** (integer, Optional) (default: 1500): Timeout in milliseconds\n- **scripts** (boolean, Optional): Run Nmap scripts on discovered ports\n- **additional_args** (string, Optional): Additional Rustscan arguments\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/rustscan`\n\n**Returns:** Ultra-fast port scanning results\n\n## Files Included\n\n- `rustscan_fast_scan.yaml` - Tool configuration\n- `rustscan_fast_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "rustscan_fast_scan.yaml",
          "content": "name: rustscan_fast_scan\ncategory: network_scanning\ntags: [vulnerability_assessment, penetration_testing, rustscan]\nendpoint: api/tools/rustscan\ndescription: 'Execute Rustscan for ultra-fast port scanning with enhanced logging.\n  target: The target IP address or hostname ports: Specific ports to scan (e.g., \"22,80,443\")\n  ulimit: File descriptor limit batch_size: Batch size for scanning timeout: Timeout\n  in milliseconds scripts: Run Nmap scripts on discovered ports additional_args: Additional\n  Rustscan arguments'\nreturns: Ultra-fast port scanning results\nparameters:\n- name: target\n  type: string\n  required: true\n  description: The target IP address or hostname\n- name: ports\n  type: string\n  required: false\n  description: Specific ports to scan (e.g., \"22,80,443\")\n  default: ''\n- name: ulimit\n  type: integer\n  required: false\n  description: File descriptor limit\n  default: 5000\n- name: batch_size\n  type: integer\n  required: false\n  description: Batch size for scanning\n  default: 4500\n- name: timeout\n  type: integer\n  required: false\n  description: Timeout in milliseconds\n  default: 1500\n- name: scripts\n  type: boolean\n  required: false\n  description: Run Nmap scripts on discovered ports\n  default: false\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Rustscan arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "rustscan_fast_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\nclass RustscanHandler(AbstractHandler):\n    \"\"\"Handler for rustscan functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute rustscan with enhanced logging\"\"\"\n        try:\n            target = data.get(\"target\", \"\")\n            ports = data.get(\"ports\", \"\")\n            ulimit = data.get(\"ulimit\", 5000)\n            batch_size = data.get(\"batch_size\", 4500)\n            timeout = data.get(\"timeout\", 1500)\n            scripts = data.get(\"scripts\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not target:\n                logger.warning(\"ðŸŽ¯ Rustscan called without target parameter\")\n                return {\"error\": \"Target parameter is required\"}\n            command = f\"rustscan -a {target} --ulimit {ulimit} -b {batch_size} -t {timeout}\"\n            if ports:\n                command += f\" -p {ports}\"\n            if scripts:\n                command += f\" -- -sC -sV\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"âš¡ Starting Rustscan: {target}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Rustscan completed for {target}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in rustscan endpoint: {str(e)}\")\n            return {\"error\": f\"Server error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640290
    },
    {
      "id": "web_application_scanning-feroxbuster_scan",
      "name": "Feroxbuster Scan",
      "description": "Execute Feroxbuster for recursive content discovery with enhanced logging. url: The target URL wordlist: Wordlist file to use threads: Number of threads additional_args: Additional Feroxbuster arguments",
      "license": "MIT",
      "content": "---\nname: feroxbuster_scan\ncapabilities: ['url', 'wordlist', 'threads', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'feroxbuster']\n---\n\n# Feroxbuster Scan\n\nExecute Feroxbuster for recursive content discovery with enhanced logging. url: The target URL wordlist: Wordlist file to use threads: Number of threads additional_args: Additional Feroxbuster arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Wordlist file to use\n- **threads** (integer, Optional) (default: 10): Number of threads\n- **additional_args** (string, Optional): Additional Feroxbuster arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/feroxbuster`\n\n**Returns:** Content discovery results\n\n## Files Included\n\n- `feroxbuster_scan.yaml` - Tool configuration\n- `feroxbuster_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: feroxbuster_scan\ncapabilities: ['url', 'wordlist', 'threads', 'additional-args']\ncategory: web_application_scanning\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'feroxbuster']\n---\n\n# Feroxbuster Scan\n\nExecute Feroxbuster for recursive content discovery with enhanced logging. url: The target URL wordlist: Wordlist file to use threads: Number of threads additional_args: Additional Feroxbuster arguments\n\n## Parameters\n- **url** (string, Required): The target URL\n- **wordlist** (string, Optional) (default: /usr/share/wordlists/dirb/common.txt): Wordlist file to use\n- **threads** (integer, Optional) (default: 10): Number of threads\n- **additional_args** (string, Optional): Additional Feroxbuster arguments\n\n\n## Usage\n\nThis tool is part of the web_application_scanning category.\n\n**Endpoint:** `api/tools/feroxbuster`\n\n**Returns:** Content discovery results\n\n## Files Included\n\n- `feroxbuster_scan.yaml` - Tool configuration\n- `feroxbuster_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "feroxbuster_scan.yaml",
          "content": "name: feroxbuster_scan\ncategory: web_application_scanning\ntags: [network_scanning, vulnerability_assessment, penetration_testing, feroxbuster]\nendpoint: api/tools/feroxbuster\ndescription: 'Execute Feroxbuster for recursive content discovery with enhanced logging.\n  url: The target URL wordlist: Wordlist file to use threads: Number of threads additional_args:\n  Additional Feroxbuster arguments'\nreturns: Content discovery results\nparameters:\n- name: url\n  type: string\n  required: true\n  description: The target URL\n- name: wordlist\n  type: string\n  required: false\n  description: Wordlist file to use\n  default: /usr/share/wordlists/dirb/common.txt\n- name: threads\n  type: integer\n  required: false\n  description: Number of threads\n  default: 10\n- name: additional_args\n  type: string\n  required: false\n  description: Additional Feroxbuster arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "feroxbuster_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass FeroxbusterHandler(AbstractHandler):\n    \"\"\"Handler for feroxbuster functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute feroxbuster with enhanced logging\"\"\"\n        try:\n            url = data.get(\"url\", \"\")\n            wordlist = data.get(\"wordlist\", \"/usr/share/wordlists/dirb/common.txt\")\n            threads = data.get(\"threads\", 10)\n            additional_args = data.get(\"additional_args\", \"\")\n            if not url:\n                logger.warning(\"ðŸŒ Feroxbuster called without URL parameter\")\n                return {\n    \n                    \"error\": \"URL parameter is required\"\n                \n                }\n            command = f\"feroxbuster -u {url} -w {wordlist} -t {threads}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Feroxbuster scan: {url}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Feroxbuster scan completed for {url}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in feroxbuster endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640291
    },
    {
      "id": "network_scanning-nc_connect",
      "name": "Nc Connect",
      "description": "Connect to a remote host and port using netcat (nc). Supports sending data and receiving responses. Ideal for CTF pwn challenges, port interaction, and network debugging.",
      "license": "MIT",
      "content": "---\nname: nc_connect\ncapabilities: ['host', 'port', 'data', 'timeout', 'udp']\ncategory: network_scanning\ntags: ['ctf', 'pwn', 'network', 'netcat']\n---\n\n# Nc Connect\n\nConnect to a remote host and port using netcat (nc). Supports sending data and receiving responses. Ideal for CTF pwn challenges, port interaction, and network debugging.\n\n## Parameters\n- **host** (string, Required): Target hostname or IP address\n- **port** (integer, Required): Target port number\n- **data** (string, Optional): Data to send after connecting\n- **timeout** (integer, Optional) (default: 10): Connection timeout in seconds\n- **udp** (boolean, Optional): Use UDP instead of TCP\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nc_connect`\n\n**Returns:** Connection output including sent and received data\n\n## Files Included\n\n- `nc_connect.yaml` - Tool configuration\n- `nc_connect.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: nc_connect\ncapabilities: ['host', 'port', 'data', 'timeout', 'udp']\ncategory: network_scanning\ntags: ['ctf', 'pwn', 'network', 'netcat']\n---\n\n# Nc Connect\n\nConnect to a remote host and port using netcat (nc). Supports sending data and receiving responses. Ideal for CTF pwn challenges, port interaction, and network debugging.\n\n## Parameters\n- **host** (string, Required): Target hostname or IP address\n- **port** (integer, Required): Target port number\n- **data** (string, Optional): Data to send after connecting\n- **timeout** (integer, Optional) (default: 10): Connection timeout in seconds\n- **udp** (boolean, Optional): Use UDP instead of TCP\n\n\n## Usage\n\nThis tool is part of the network_scanning category.\n\n**Endpoint:** `api/tools/nc_connect`\n\n**Returns:** Connection output including sent and received data\n\n## Files Included\n\n- `nc_connect.yaml` - Tool configuration\n- `nc_connect.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "nc_connect.yaml",
          "content": "name: nc_connect\ncategory: network_scanning\ntags: [ctf, pwn, network, netcat]\nendpoint: api/tools/nc_connect\ndescription: 'Connect to a remote host and port using netcat (nc). Supports sending data and receiving responses. Ideal for CTF pwn challenges, port interaction, and network debugging.'\nreturns: Connection output including sent and received data\nparameters:\n- name: host\n  type: string\n  required: true\n  description: Target hostname or IP address\n- name: port\n  type: integer\n  required: true\n  description: Target port number\n- name: data\n  type: string\n  required: false\n  description: Data to send after connecting\n  default: ''\n- name: timeout\n  type: integer\n  required: false\n  description: Connection timeout in seconds\n  default: 10\n- name: udp\n  type: boolean\n  required: false\n  description: Use UDP instead of TCP\n  default: false\n",
          "language": "yaml"
        },
        {
          "name": "nc_connect.py",
          "content": "import logging\nfrom typing import Dict, Any\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass NcConnectHandler(AbstractHandler):\n    \"\"\"\n    Netcat connection handler.\n    Connects to remote hosts and ports, supports sending/receiving data.\n    Ideal for CTF pwn challenges and network interaction.\n    \"\"\"\n\n    def __init__(self, config: Dict):\n        super().__init__(config)\n\n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n\n    def handle(self, data: Dict) -> Any:\n        \"\"\"Connect to remote host using netcat\"\"\"\n        try:\n            host = data.get(\"host\", \"\")\n            port = data.get(\"port\", 0)\n            send_data = data.get(\"data\", \"\")\n            timeout = data.get(\"timeout\", 10)\n            udp = data.get(\"udp\", False)\n\n            if not host:\n                logger.warning(\"ðŸ”Œ nc_connect called without host\")\n                return {\"error\": \"Host parameter is required\"}\n\n            if not port:\n                logger.warning(\"ðŸ”Œ nc_connect called without port\")\n                return {\"error\": \"Port parameter is required\"}\n\n            # Build nc command\n            command = \"nc\"\n            \n            # Add verbose flag\n            command += \" -v\"\n            \n            # Add timeout\n            command += f\" -w {timeout}\"\n            \n            # Add UDP flag if needed\n            if udp:\n                command += \" -u\"\n            \n            # Add host and port\n            command += f\" {host} {port}\"\n\n            # If we have data to send, pipe it\n            if send_data:\n                # Escape special characters\n                escaped_data = send_data.replace(\"\\\\\", \"\\\\\\\\\").replace('\"', '\\\\\"').replace(\"$\", \"\\\\$\")\n                command = f'echo -e \"{escaped_data}\" | {command}'\n\n            logger.info(f\"ðŸ”Œ Connecting to {host}:{port} {'(UDP)' if udp else '(TCP)'}\")\n            result = execute_command(command, timeout=timeout + 5)\n\n            logger.info(f\"ðŸ“Š nc connection completed for {host}:{port}\")\n            result[\"host\"] = host\n            result[\"port\"] = port\n            result[\"protocol\"] = \"UDP\" if udp else \"TCP\"\n            return result\n\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in nc_connect: {str(e)}\")\n            return {\"error\": f\"Connection error: {str(e)}\"}\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640292
    },
    {
      "id": "subdomain_enumeration-fierce_scan",
      "name": "Fierce Scan",
      "description": "Execute fierce for DNS reconnaissance with enhanced logging. domain: Target domain dns_server: DNS server to use additional_args: Additional fierce arguments",
      "license": "MIT",
      "content": "---\nname: fierce_scan\ncapabilities: ['domain', 'dns-server', 'additional-args']\ncategory: subdomain_enumeration\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'fierce']\n---\n\n# Fierce Scan\n\nExecute fierce for DNS reconnaissance with enhanced logging. domain: Target domain dns_server: DNS server to use additional_args: Additional fierce arguments\n\n## Parameters\n- **domain** (string, Required): Target domain\n- **dns_server** (string, Optional): DNS server to use\n- **additional_args** (string, Optional): Additional fierce arguments\n\n\n## Usage\n\nThis tool is part of the subdomain_enumeration category.\n\n**Endpoint:** `api/tools/fierce`\n\n**Returns:** DNS reconnaissance results\n\n## Files Included\n\n- `fierce_scan.yaml` - Tool configuration\n- `fierce_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
      "files": [
        {
          "name": "manifest.md",
          "content": "---\nname: fierce_scan\ncapabilities: ['domain', 'dns-server', 'additional-args']\ncategory: subdomain_enumeration\ntags: ['network_scanning', 'vulnerability_assessment', 'penetration_testing', 'fierce']\n---\n\n# Fierce Scan\n\nExecute fierce for DNS reconnaissance with enhanced logging. domain: Target domain dns_server: DNS server to use additional_args: Additional fierce arguments\n\n## Parameters\n- **domain** (string, Required): Target domain\n- **dns_server** (string, Optional): DNS server to use\n- **additional_args** (string, Optional): Additional fierce arguments\n\n\n## Usage\n\nThis tool is part of the subdomain_enumeration category.\n\n**Endpoint:** `api/tools/fierce`\n\n**Returns:** DNS reconnaissance results\n\n## Files Included\n\n- `fierce_scan.yaml` - Tool configuration\n- `fierce_scan.py` - Python implementation\n\n---\n\n*Converted from MCP tool - Source: backend/dynamic_engine/handlers/*\n",
          "language": "markdown"
        },
        {
          "name": "fierce_scan.yaml",
          "content": "name: fierce_scan\ncategory: subdomain_enumeration\ntags: [network_scanning, vulnerability_assessment, penetration_testing, fierce]\nendpoint: api/tools/fierce\ndescription: 'Execute fierce for DNS reconnaissance with enhanced logging. domain:\n  Target domain dns_server: DNS server to use additional_args: Additional fierce arguments'\nreturns: DNS reconnaissance results\nparameters:\n- name: domain\n  type: string\n  required: true\n  description: Target domain\n- name: dns_server\n  type: string\n  required: false\n  description: DNS server to use\n  default: ''\n- name: additional_args\n  type: string\n  required: false\n  description: Additional fierce arguments\n  default: ''\n",
          "language": "yaml"
        },
        {
          "name": "fierce_scan.py",
          "content": "from typing import Any, Dict\nimport logging\n\nfrom dynamic_engine.mcp.handler import AbstractHandler, HandlerType\nfrom dynamic_engine.runtime.command.command_executor import execute_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass FierceHandler(AbstractHandler):\n    \"\"\"Handler for fierce functionality\"\"\"\n    \n    def type(self) -> HandlerType:\n        return HandlerType.PYTHON\n    \n    def handle(self, data: Dict) -> Any:\n        \"\"\"Execute fierce with enhanced logging\"\"\"\n        try:\n            domain = data.get(\"domain\", \"\")\n            dns_server = data.get(\"dns_server\", \"\")\n            additional_args = data.get(\"additional_args\", \"\")\n            if not domain:\n                logger.warning(\"ðŸŒ Fierce called without domain parameter\")\n                return {\n    \n                    \"error\": \"Domain parameter is required\"\n                \n                }\n            command = f\"fierce --domain {domain}\"\n            if dns_server:\n                command += f\" --dns-servers {dns_server}\"\n            if additional_args:\n                command += f\" {additional_args}\"\n            logger.info(f\"ðŸ” Starting Fierce DNS recon: {domain}\")\n            result = execute_command(command)\n            logger.info(f\"ðŸ“Š Fierce completed for {domain}\")\n            return result\n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Error in fierce endpoint: {str(e)}\")\n            return {\n    \n                \"error\": f\"Server error: {str(e)}\"\n            \n            }\n",
          "language": "python"
        }
      ],
      "source": "mcp",
      "updatedAt": 1767080640293
    }
  ],
  "total": 30,
  "scanned": 30,
  "categories": [
    "binary_vulnerability_analysis",
    "subdomain_enumeration",
    "container_scanning",
    "network_scanning",
    "binary_exploitation",
    "web_application_scanning"
  ],
  "generated_at": "2025-12-30T15:44:00.293538"
}
